
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Building
 * 
 */
export type Building = $Result.DefaultSelection<Prisma.$BuildingPayload>
/**
 * Model Department
 * 
 */
export type Department = $Result.DefaultSelection<Prisma.$DepartmentPayload>
/**
 * Model Service
 * 
 */
export type Service = $Result.DefaultSelection<Prisma.$ServicePayload>
/**
 * Model Porter
 * 
 */
export type Porter = $Result.DefaultSelection<Prisma.$PorterPayload>
/**
 * Model Shift
 * 
 */
export type Shift = $Result.DefaultSelection<Prisma.$ShiftPayload>
/**
 * Model ShiftPattern
 * 
 */
export type ShiftPattern = $Result.DefaultSelection<Prisma.$ShiftPatternPayload>
/**
 * Model DepartmentSchedule
 * 
 */
export type DepartmentSchedule = $Result.DefaultSelection<Prisma.$DepartmentSchedulePayload>
/**
 * Model DepartmentSchedulePeriod
 * 
 */
export type DepartmentSchedulePeriod = $Result.DefaultSelection<Prisma.$DepartmentSchedulePeriodPayload>
/**
 * Model Capability
 * 
 */
export type Capability = $Result.DefaultSelection<Prisma.$CapabilityPayload>
/**
 * Model PorterCapability
 * 
 */
export type PorterCapability = $Result.DefaultSelection<Prisma.$PorterCapabilityPayload>
/**
 * Model DepartmentCapability
 * 
 */
export type DepartmentCapability = $Result.DefaultSelection<Prisma.$DepartmentCapabilityPayload>
/**
 * Model ServiceCapability
 * 
 */
export type ServiceCapability = $Result.DefaultSelection<Prisma.$ServiceCapabilityPayload>
/**
 * Model Allocation
 * 
 */
export type Allocation = $Result.DefaultSelection<Prisma.$AllocationPayload>
/**
 * Model Availability
 * 
 */
export type Availability = $Result.DefaultSelection<Prisma.$AvailabilityPayload>
/**
 * Model SystemSetting
 * 
 */
export type SystemSetting = $Result.DefaultSelection<Prisma.$SystemSettingPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const ContractType: {
  SHIFT: 'SHIFT',
  FIXED: 'FIXED',
  RELIEF: 'RELIEF'
};

export type ContractType = (typeof ContractType)[keyof typeof ContractType]


export const PorterType: {
  PORTER: 'PORTER',
  SUPERVISOR: 'SUPERVISOR'
};

export type PorterType = (typeof PorterType)[keyof typeof PorterType]


export const ShiftMode: {
  DAY: 'DAY',
  NIGHT: 'NIGHT',
  MIXED: 'MIXED'
};

export type ShiftMode = (typeof ShiftMode)[keyof typeof ShiftMode]


export const DayOfWeek: {
  MONDAY: 'MONDAY',
  TUESDAY: 'TUESDAY',
  WEDNESDAY: 'WEDNESDAY',
  THURSDAY: 'THURSDAY',
  FRIDAY: 'FRIDAY',
  SATURDAY: 'SATURDAY',
  SUNDAY: 'SUNDAY'
};

export type DayOfWeek = (typeof DayOfWeek)[keyof typeof DayOfWeek]


export const RequiredLevel: {
  REQUIRED: 'REQUIRED',
  PREFERRED: 'PREFERRED'
};

export type RequiredLevel = (typeof RequiredLevel)[keyof typeof RequiredLevel]


export const AllocationType: {
  REGULAR: 'REGULAR',
  TEMPORARY: 'TEMPORARY',
  RELIEF: 'RELIEF'
};

export type AllocationType = (typeof AllocationType)[keyof typeof AllocationType]


export const AvailabilityStatus: {
  AVAILABLE: 'AVAILABLE',
  UNAVAILABLE: 'UNAVAILABLE',
  OVERTIME: 'OVERTIME'
};

export type AvailabilityStatus = (typeof AvailabilityStatus)[keyof typeof AvailabilityStatus]

}

export type ContractType = $Enums.ContractType

export const ContractType: typeof $Enums.ContractType

export type PorterType = $Enums.PorterType

export const PorterType: typeof $Enums.PorterType

export type ShiftMode = $Enums.ShiftMode

export const ShiftMode: typeof $Enums.ShiftMode

export type DayOfWeek = $Enums.DayOfWeek

export const DayOfWeek: typeof $Enums.DayOfWeek

export type RequiredLevel = $Enums.RequiredLevel

export const RequiredLevel: typeof $Enums.RequiredLevel

export type AllocationType = $Enums.AllocationType

export const AllocationType: typeof $Enums.AllocationType

export type AvailabilityStatus = $Enums.AvailabilityStatus

export const AvailabilityStatus: typeof $Enums.AvailabilityStatus

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Buildings
 * const buildings = await prisma.building.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Buildings
   * const buildings = await prisma.building.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.building`: Exposes CRUD operations for the **Building** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Buildings
    * const buildings = await prisma.building.findMany()
    * ```
    */
  get building(): Prisma.BuildingDelegate<ExtArgs>;

  /**
   * `prisma.department`: Exposes CRUD operations for the **Department** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Departments
    * const departments = await prisma.department.findMany()
    * ```
    */
  get department(): Prisma.DepartmentDelegate<ExtArgs>;

  /**
   * `prisma.service`: Exposes CRUD operations for the **Service** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Services
    * const services = await prisma.service.findMany()
    * ```
    */
  get service(): Prisma.ServiceDelegate<ExtArgs>;

  /**
   * `prisma.porter`: Exposes CRUD operations for the **Porter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Porters
    * const porters = await prisma.porter.findMany()
    * ```
    */
  get porter(): Prisma.PorterDelegate<ExtArgs>;

  /**
   * `prisma.shift`: Exposes CRUD operations for the **Shift** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Shifts
    * const shifts = await prisma.shift.findMany()
    * ```
    */
  get shift(): Prisma.ShiftDelegate<ExtArgs>;

  /**
   * `prisma.shiftPattern`: Exposes CRUD operations for the **ShiftPattern** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ShiftPatterns
    * const shiftPatterns = await prisma.shiftPattern.findMany()
    * ```
    */
  get shiftPattern(): Prisma.ShiftPatternDelegate<ExtArgs>;

  /**
   * `prisma.departmentSchedule`: Exposes CRUD operations for the **DepartmentSchedule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DepartmentSchedules
    * const departmentSchedules = await prisma.departmentSchedule.findMany()
    * ```
    */
  get departmentSchedule(): Prisma.DepartmentScheduleDelegate<ExtArgs>;

  /**
   * `prisma.departmentSchedulePeriod`: Exposes CRUD operations for the **DepartmentSchedulePeriod** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DepartmentSchedulePeriods
    * const departmentSchedulePeriods = await prisma.departmentSchedulePeriod.findMany()
    * ```
    */
  get departmentSchedulePeriod(): Prisma.DepartmentSchedulePeriodDelegate<ExtArgs>;

  /**
   * `prisma.capability`: Exposes CRUD operations for the **Capability** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Capabilities
    * const capabilities = await prisma.capability.findMany()
    * ```
    */
  get capability(): Prisma.CapabilityDelegate<ExtArgs>;

  /**
   * `prisma.porterCapability`: Exposes CRUD operations for the **PorterCapability** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PorterCapabilities
    * const porterCapabilities = await prisma.porterCapability.findMany()
    * ```
    */
  get porterCapability(): Prisma.PorterCapabilityDelegate<ExtArgs>;

  /**
   * `prisma.departmentCapability`: Exposes CRUD operations for the **DepartmentCapability** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DepartmentCapabilities
    * const departmentCapabilities = await prisma.departmentCapability.findMany()
    * ```
    */
  get departmentCapability(): Prisma.DepartmentCapabilityDelegate<ExtArgs>;

  /**
   * `prisma.serviceCapability`: Exposes CRUD operations for the **ServiceCapability** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceCapabilities
    * const serviceCapabilities = await prisma.serviceCapability.findMany()
    * ```
    */
  get serviceCapability(): Prisma.ServiceCapabilityDelegate<ExtArgs>;

  /**
   * `prisma.allocation`: Exposes CRUD operations for the **Allocation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Allocations
    * const allocations = await prisma.allocation.findMany()
    * ```
    */
  get allocation(): Prisma.AllocationDelegate<ExtArgs>;

  /**
   * `prisma.availability`: Exposes CRUD operations for the **Availability** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Availabilities
    * const availabilities = await prisma.availability.findMany()
    * ```
    */
  get availability(): Prisma.AvailabilityDelegate<ExtArgs>;

  /**
   * `prisma.systemSetting`: Exposes CRUD operations for the **SystemSetting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemSettings
    * const systemSettings = await prisma.systemSetting.findMany()
    * ```
    */
  get systemSetting(): Prisma.SystemSettingDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Building: 'Building',
    Department: 'Department',
    Service: 'Service',
    Porter: 'Porter',
    Shift: 'Shift',
    ShiftPattern: 'ShiftPattern',
    DepartmentSchedule: 'DepartmentSchedule',
    DepartmentSchedulePeriod: 'DepartmentSchedulePeriod',
    Capability: 'Capability',
    PorterCapability: 'PorterCapability',
    DepartmentCapability: 'DepartmentCapability',
    ServiceCapability: 'ServiceCapability',
    Allocation: 'Allocation',
    Availability: 'Availability',
    SystemSetting: 'SystemSetting'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "building" | "department" | "service" | "porter" | "shift" | "shiftPattern" | "departmentSchedule" | "departmentSchedulePeriod" | "capability" | "porterCapability" | "departmentCapability" | "serviceCapability" | "allocation" | "availability" | "systemSetting"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Building: {
        payload: Prisma.$BuildingPayload<ExtArgs>
        fields: Prisma.BuildingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BuildingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuildingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BuildingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuildingPayload>
          }
          findFirst: {
            args: Prisma.BuildingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuildingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BuildingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuildingPayload>
          }
          findMany: {
            args: Prisma.BuildingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuildingPayload>[]
          }
          create: {
            args: Prisma.BuildingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuildingPayload>
          }
          createMany: {
            args: Prisma.BuildingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BuildingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuildingPayload>
          }
          update: {
            args: Prisma.BuildingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuildingPayload>
          }
          deleteMany: {
            args: Prisma.BuildingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BuildingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BuildingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuildingPayload>
          }
          aggregate: {
            args: Prisma.BuildingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBuilding>
          }
          groupBy: {
            args: Prisma.BuildingGroupByArgs<ExtArgs>
            result: $Utils.Optional<BuildingGroupByOutputType>[]
          }
          count: {
            args: Prisma.BuildingCountArgs<ExtArgs>
            result: $Utils.Optional<BuildingCountAggregateOutputType> | number
          }
        }
      }
      Department: {
        payload: Prisma.$DepartmentPayload<ExtArgs>
        fields: Prisma.DepartmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DepartmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DepartmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          findFirst: {
            args: Prisma.DepartmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DepartmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          findMany: {
            args: Prisma.DepartmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          create: {
            args: Prisma.DepartmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          createMany: {
            args: Prisma.DepartmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DepartmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          update: {
            args: Prisma.DepartmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          deleteMany: {
            args: Prisma.DepartmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DepartmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DepartmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          aggregate: {
            args: Prisma.DepartmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDepartment>
          }
          groupBy: {
            args: Prisma.DepartmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DepartmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DepartmentCountArgs<ExtArgs>
            result: $Utils.Optional<DepartmentCountAggregateOutputType> | number
          }
        }
      }
      Service: {
        payload: Prisma.$ServicePayload<ExtArgs>
        fields: Prisma.ServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findFirst: {
            args: Prisma.ServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findMany: {
            args: Prisma.ServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          create: {
            args: Prisma.ServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          createMany: {
            args: Prisma.ServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          update: {
            args: Prisma.ServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          deleteMany: {
            args: Prisma.ServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          aggregate: {
            args: Prisma.ServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateService>
          }
          groupBy: {
            args: Prisma.ServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceCountAggregateOutputType> | number
          }
        }
      }
      Porter: {
        payload: Prisma.$PorterPayload<ExtArgs>
        fields: Prisma.PorterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PorterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PorterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PorterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PorterPayload>
          }
          findFirst: {
            args: Prisma.PorterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PorterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PorterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PorterPayload>
          }
          findMany: {
            args: Prisma.PorterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PorterPayload>[]
          }
          create: {
            args: Prisma.PorterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PorterPayload>
          }
          createMany: {
            args: Prisma.PorterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PorterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PorterPayload>
          }
          update: {
            args: Prisma.PorterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PorterPayload>
          }
          deleteMany: {
            args: Prisma.PorterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PorterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PorterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PorterPayload>
          }
          aggregate: {
            args: Prisma.PorterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePorter>
          }
          groupBy: {
            args: Prisma.PorterGroupByArgs<ExtArgs>
            result: $Utils.Optional<PorterGroupByOutputType>[]
          }
          count: {
            args: Prisma.PorterCountArgs<ExtArgs>
            result: $Utils.Optional<PorterCountAggregateOutputType> | number
          }
        }
      }
      Shift: {
        payload: Prisma.$ShiftPayload<ExtArgs>
        fields: Prisma.ShiftFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShiftFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShiftFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>
          }
          findFirst: {
            args: Prisma.ShiftFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShiftFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>
          }
          findMany: {
            args: Prisma.ShiftFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>[]
          }
          create: {
            args: Prisma.ShiftCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>
          }
          createMany: {
            args: Prisma.ShiftCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ShiftDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>
          }
          update: {
            args: Prisma.ShiftUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>
          }
          deleteMany: {
            args: Prisma.ShiftDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShiftUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ShiftUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>
          }
          aggregate: {
            args: Prisma.ShiftAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShift>
          }
          groupBy: {
            args: Prisma.ShiftGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShiftGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShiftCountArgs<ExtArgs>
            result: $Utils.Optional<ShiftCountAggregateOutputType> | number
          }
        }
      }
      ShiftPattern: {
        payload: Prisma.$ShiftPatternPayload<ExtArgs>
        fields: Prisma.ShiftPatternFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShiftPatternFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPatternPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShiftPatternFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPatternPayload>
          }
          findFirst: {
            args: Prisma.ShiftPatternFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPatternPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShiftPatternFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPatternPayload>
          }
          findMany: {
            args: Prisma.ShiftPatternFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPatternPayload>[]
          }
          create: {
            args: Prisma.ShiftPatternCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPatternPayload>
          }
          createMany: {
            args: Prisma.ShiftPatternCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ShiftPatternDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPatternPayload>
          }
          update: {
            args: Prisma.ShiftPatternUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPatternPayload>
          }
          deleteMany: {
            args: Prisma.ShiftPatternDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShiftPatternUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ShiftPatternUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPatternPayload>
          }
          aggregate: {
            args: Prisma.ShiftPatternAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShiftPattern>
          }
          groupBy: {
            args: Prisma.ShiftPatternGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShiftPatternGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShiftPatternCountArgs<ExtArgs>
            result: $Utils.Optional<ShiftPatternCountAggregateOutputType> | number
          }
        }
      }
      DepartmentSchedule: {
        payload: Prisma.$DepartmentSchedulePayload<ExtArgs>
        fields: Prisma.DepartmentScheduleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DepartmentScheduleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentSchedulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DepartmentScheduleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentSchedulePayload>
          }
          findFirst: {
            args: Prisma.DepartmentScheduleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentSchedulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DepartmentScheduleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentSchedulePayload>
          }
          findMany: {
            args: Prisma.DepartmentScheduleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentSchedulePayload>[]
          }
          create: {
            args: Prisma.DepartmentScheduleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentSchedulePayload>
          }
          createMany: {
            args: Prisma.DepartmentScheduleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DepartmentScheduleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentSchedulePayload>
          }
          update: {
            args: Prisma.DepartmentScheduleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentSchedulePayload>
          }
          deleteMany: {
            args: Prisma.DepartmentScheduleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DepartmentScheduleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DepartmentScheduleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentSchedulePayload>
          }
          aggregate: {
            args: Prisma.DepartmentScheduleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDepartmentSchedule>
          }
          groupBy: {
            args: Prisma.DepartmentScheduleGroupByArgs<ExtArgs>
            result: $Utils.Optional<DepartmentScheduleGroupByOutputType>[]
          }
          count: {
            args: Prisma.DepartmentScheduleCountArgs<ExtArgs>
            result: $Utils.Optional<DepartmentScheduleCountAggregateOutputType> | number
          }
        }
      }
      DepartmentSchedulePeriod: {
        payload: Prisma.$DepartmentSchedulePeriodPayload<ExtArgs>
        fields: Prisma.DepartmentSchedulePeriodFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DepartmentSchedulePeriodFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentSchedulePeriodPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DepartmentSchedulePeriodFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentSchedulePeriodPayload>
          }
          findFirst: {
            args: Prisma.DepartmentSchedulePeriodFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentSchedulePeriodPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DepartmentSchedulePeriodFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentSchedulePeriodPayload>
          }
          findMany: {
            args: Prisma.DepartmentSchedulePeriodFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentSchedulePeriodPayload>[]
          }
          create: {
            args: Prisma.DepartmentSchedulePeriodCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentSchedulePeriodPayload>
          }
          createMany: {
            args: Prisma.DepartmentSchedulePeriodCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DepartmentSchedulePeriodDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentSchedulePeriodPayload>
          }
          update: {
            args: Prisma.DepartmentSchedulePeriodUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentSchedulePeriodPayload>
          }
          deleteMany: {
            args: Prisma.DepartmentSchedulePeriodDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DepartmentSchedulePeriodUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DepartmentSchedulePeriodUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentSchedulePeriodPayload>
          }
          aggregate: {
            args: Prisma.DepartmentSchedulePeriodAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDepartmentSchedulePeriod>
          }
          groupBy: {
            args: Prisma.DepartmentSchedulePeriodGroupByArgs<ExtArgs>
            result: $Utils.Optional<DepartmentSchedulePeriodGroupByOutputType>[]
          }
          count: {
            args: Prisma.DepartmentSchedulePeriodCountArgs<ExtArgs>
            result: $Utils.Optional<DepartmentSchedulePeriodCountAggregateOutputType> | number
          }
        }
      }
      Capability: {
        payload: Prisma.$CapabilityPayload<ExtArgs>
        fields: Prisma.CapabilityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CapabilityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapabilityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CapabilityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapabilityPayload>
          }
          findFirst: {
            args: Prisma.CapabilityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapabilityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CapabilityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapabilityPayload>
          }
          findMany: {
            args: Prisma.CapabilityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapabilityPayload>[]
          }
          create: {
            args: Prisma.CapabilityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapabilityPayload>
          }
          createMany: {
            args: Prisma.CapabilityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CapabilityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapabilityPayload>
          }
          update: {
            args: Prisma.CapabilityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapabilityPayload>
          }
          deleteMany: {
            args: Prisma.CapabilityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CapabilityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CapabilityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapabilityPayload>
          }
          aggregate: {
            args: Prisma.CapabilityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCapability>
          }
          groupBy: {
            args: Prisma.CapabilityGroupByArgs<ExtArgs>
            result: $Utils.Optional<CapabilityGroupByOutputType>[]
          }
          count: {
            args: Prisma.CapabilityCountArgs<ExtArgs>
            result: $Utils.Optional<CapabilityCountAggregateOutputType> | number
          }
        }
      }
      PorterCapability: {
        payload: Prisma.$PorterCapabilityPayload<ExtArgs>
        fields: Prisma.PorterCapabilityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PorterCapabilityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PorterCapabilityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PorterCapabilityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PorterCapabilityPayload>
          }
          findFirst: {
            args: Prisma.PorterCapabilityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PorterCapabilityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PorterCapabilityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PorterCapabilityPayload>
          }
          findMany: {
            args: Prisma.PorterCapabilityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PorterCapabilityPayload>[]
          }
          create: {
            args: Prisma.PorterCapabilityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PorterCapabilityPayload>
          }
          createMany: {
            args: Prisma.PorterCapabilityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PorterCapabilityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PorterCapabilityPayload>
          }
          update: {
            args: Prisma.PorterCapabilityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PorterCapabilityPayload>
          }
          deleteMany: {
            args: Prisma.PorterCapabilityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PorterCapabilityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PorterCapabilityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PorterCapabilityPayload>
          }
          aggregate: {
            args: Prisma.PorterCapabilityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePorterCapability>
          }
          groupBy: {
            args: Prisma.PorterCapabilityGroupByArgs<ExtArgs>
            result: $Utils.Optional<PorterCapabilityGroupByOutputType>[]
          }
          count: {
            args: Prisma.PorterCapabilityCountArgs<ExtArgs>
            result: $Utils.Optional<PorterCapabilityCountAggregateOutputType> | number
          }
        }
      }
      DepartmentCapability: {
        payload: Prisma.$DepartmentCapabilityPayload<ExtArgs>
        fields: Prisma.DepartmentCapabilityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DepartmentCapabilityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentCapabilityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DepartmentCapabilityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentCapabilityPayload>
          }
          findFirst: {
            args: Prisma.DepartmentCapabilityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentCapabilityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DepartmentCapabilityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentCapabilityPayload>
          }
          findMany: {
            args: Prisma.DepartmentCapabilityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentCapabilityPayload>[]
          }
          create: {
            args: Prisma.DepartmentCapabilityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentCapabilityPayload>
          }
          createMany: {
            args: Prisma.DepartmentCapabilityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DepartmentCapabilityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentCapabilityPayload>
          }
          update: {
            args: Prisma.DepartmentCapabilityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentCapabilityPayload>
          }
          deleteMany: {
            args: Prisma.DepartmentCapabilityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DepartmentCapabilityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DepartmentCapabilityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentCapabilityPayload>
          }
          aggregate: {
            args: Prisma.DepartmentCapabilityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDepartmentCapability>
          }
          groupBy: {
            args: Prisma.DepartmentCapabilityGroupByArgs<ExtArgs>
            result: $Utils.Optional<DepartmentCapabilityGroupByOutputType>[]
          }
          count: {
            args: Prisma.DepartmentCapabilityCountArgs<ExtArgs>
            result: $Utils.Optional<DepartmentCapabilityCountAggregateOutputType> | number
          }
        }
      }
      ServiceCapability: {
        payload: Prisma.$ServiceCapabilityPayload<ExtArgs>
        fields: Prisma.ServiceCapabilityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceCapabilityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCapabilityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceCapabilityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCapabilityPayload>
          }
          findFirst: {
            args: Prisma.ServiceCapabilityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCapabilityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceCapabilityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCapabilityPayload>
          }
          findMany: {
            args: Prisma.ServiceCapabilityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCapabilityPayload>[]
          }
          create: {
            args: Prisma.ServiceCapabilityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCapabilityPayload>
          }
          createMany: {
            args: Prisma.ServiceCapabilityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ServiceCapabilityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCapabilityPayload>
          }
          update: {
            args: Prisma.ServiceCapabilityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCapabilityPayload>
          }
          deleteMany: {
            args: Prisma.ServiceCapabilityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceCapabilityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ServiceCapabilityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCapabilityPayload>
          }
          aggregate: {
            args: Prisma.ServiceCapabilityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceCapability>
          }
          groupBy: {
            args: Prisma.ServiceCapabilityGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceCapabilityGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceCapabilityCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceCapabilityCountAggregateOutputType> | number
          }
        }
      }
      Allocation: {
        payload: Prisma.$AllocationPayload<ExtArgs>
        fields: Prisma.AllocationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AllocationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllocationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AllocationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllocationPayload>
          }
          findFirst: {
            args: Prisma.AllocationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllocationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AllocationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllocationPayload>
          }
          findMany: {
            args: Prisma.AllocationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllocationPayload>[]
          }
          create: {
            args: Prisma.AllocationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllocationPayload>
          }
          createMany: {
            args: Prisma.AllocationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AllocationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllocationPayload>
          }
          update: {
            args: Prisma.AllocationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllocationPayload>
          }
          deleteMany: {
            args: Prisma.AllocationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AllocationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AllocationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllocationPayload>
          }
          aggregate: {
            args: Prisma.AllocationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAllocation>
          }
          groupBy: {
            args: Prisma.AllocationGroupByArgs<ExtArgs>
            result: $Utils.Optional<AllocationGroupByOutputType>[]
          }
          count: {
            args: Prisma.AllocationCountArgs<ExtArgs>
            result: $Utils.Optional<AllocationCountAggregateOutputType> | number
          }
        }
      }
      Availability: {
        payload: Prisma.$AvailabilityPayload<ExtArgs>
        fields: Prisma.AvailabilityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AvailabilityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AvailabilityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilityPayload>
          }
          findFirst: {
            args: Prisma.AvailabilityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AvailabilityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilityPayload>
          }
          findMany: {
            args: Prisma.AvailabilityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilityPayload>[]
          }
          create: {
            args: Prisma.AvailabilityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilityPayload>
          }
          createMany: {
            args: Prisma.AvailabilityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AvailabilityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilityPayload>
          }
          update: {
            args: Prisma.AvailabilityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilityPayload>
          }
          deleteMany: {
            args: Prisma.AvailabilityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AvailabilityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AvailabilityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilityPayload>
          }
          aggregate: {
            args: Prisma.AvailabilityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAvailability>
          }
          groupBy: {
            args: Prisma.AvailabilityGroupByArgs<ExtArgs>
            result: $Utils.Optional<AvailabilityGroupByOutputType>[]
          }
          count: {
            args: Prisma.AvailabilityCountArgs<ExtArgs>
            result: $Utils.Optional<AvailabilityCountAggregateOutputType> | number
          }
        }
      }
      SystemSetting: {
        payload: Prisma.$SystemSettingPayload<ExtArgs>
        fields: Prisma.SystemSettingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemSettingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemSettingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          findFirst: {
            args: Prisma.SystemSettingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemSettingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          findMany: {
            args: Prisma.SystemSettingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>[]
          }
          create: {
            args: Prisma.SystemSettingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          createMany: {
            args: Prisma.SystemSettingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SystemSettingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          update: {
            args: Prisma.SystemSettingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          deleteMany: {
            args: Prisma.SystemSettingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemSettingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SystemSettingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          aggregate: {
            args: Prisma.SystemSettingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemSetting>
          }
          groupBy: {
            args: Prisma.SystemSettingGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemSettingGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemSettingCountArgs<ExtArgs>
            result: $Utils.Optional<SystemSettingCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type BuildingCountOutputType
   */

  export type BuildingCountOutputType = {
    departments: number
  }

  export type BuildingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    departments?: boolean | BuildingCountOutputTypeCountDepartmentsArgs
  }

  // Custom InputTypes
  /**
   * BuildingCountOutputType without action
   */
  export type BuildingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildingCountOutputType
     */
    select?: BuildingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BuildingCountOutputType without action
   */
  export type BuildingCountOutputTypeCountDepartmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentWhereInput
  }


  /**
   * Count Type DepartmentCountOutputType
   */

  export type DepartmentCountOutputType = {
    services: number
    porters: number
    allocations: number
    departmentCapabilities: number
  }

  export type DepartmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    services?: boolean | DepartmentCountOutputTypeCountServicesArgs
    porters?: boolean | DepartmentCountOutputTypeCountPortersArgs
    allocations?: boolean | DepartmentCountOutputTypeCountAllocationsArgs
    departmentCapabilities?: boolean | DepartmentCountOutputTypeCountDepartmentCapabilitiesArgs
  }

  // Custom InputTypes
  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentCountOutputType
     */
    select?: DepartmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountPortersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PorterWhereInput
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountAllocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AllocationWhereInput
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountDepartmentCapabilitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentCapabilityWhereInput
  }


  /**
   * Count Type ServiceCountOutputType
   */

  export type ServiceCountOutputType = {
    allocations: number
    serviceCapabilities: number
  }

  export type ServiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    allocations?: boolean | ServiceCountOutputTypeCountAllocationsArgs
    serviceCapabilities?: boolean | ServiceCountOutputTypeCountServiceCapabilitiesArgs
  }

  // Custom InputTypes
  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCountOutputType
     */
    select?: ServiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountAllocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AllocationWhereInput
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountServiceCapabilitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceCapabilityWhereInput
  }


  /**
   * Count Type PorterCountOutputType
   */

  export type PorterCountOutputType = {
    allocations: number
    availability: number
    porterCapabilities: number
  }

  export type PorterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    allocations?: boolean | PorterCountOutputTypeCountAllocationsArgs
    availability?: boolean | PorterCountOutputTypeCountAvailabilityArgs
    porterCapabilities?: boolean | PorterCountOutputTypeCountPorterCapabilitiesArgs
  }

  // Custom InputTypes
  /**
   * PorterCountOutputType without action
   */
  export type PorterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PorterCountOutputType
     */
    select?: PorterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PorterCountOutputType without action
   */
  export type PorterCountOutputTypeCountAllocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AllocationWhereInput
  }

  /**
   * PorterCountOutputType without action
   */
  export type PorterCountOutputTypeCountAvailabilityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AvailabilityWhereInput
  }

  /**
   * PorterCountOutputType without action
   */
  export type PorterCountOutputTypeCountPorterCapabilitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PorterCapabilityWhereInput
  }


  /**
   * Count Type ShiftCountOutputType
   */

  export type ShiftCountOutputType = {
    porters: number
  }

  export type ShiftCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    porters?: boolean | ShiftCountOutputTypeCountPortersArgs
  }

  // Custom InputTypes
  /**
   * ShiftCountOutputType without action
   */
  export type ShiftCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftCountOutputType
     */
    select?: ShiftCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ShiftCountOutputType without action
   */
  export type ShiftCountOutputTypeCountPortersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PorterWhereInput
  }


  /**
   * Count Type ShiftPatternCountOutputType
   */

  export type ShiftPatternCountOutputType = {
    shifts: number
  }

  export type ShiftPatternCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shifts?: boolean | ShiftPatternCountOutputTypeCountShiftsArgs
  }

  // Custom InputTypes
  /**
   * ShiftPatternCountOutputType without action
   */
  export type ShiftPatternCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftPatternCountOutputType
     */
    select?: ShiftPatternCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ShiftPatternCountOutputType without action
   */
  export type ShiftPatternCountOutputTypeCountShiftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShiftWhereInput
  }


  /**
   * Count Type DepartmentScheduleCountOutputType
   */

  export type DepartmentScheduleCountOutputType = {
    departments: number
    periods: number
  }

  export type DepartmentScheduleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    departments?: boolean | DepartmentScheduleCountOutputTypeCountDepartmentsArgs
    periods?: boolean | DepartmentScheduleCountOutputTypeCountPeriodsArgs
  }

  // Custom InputTypes
  /**
   * DepartmentScheduleCountOutputType without action
   */
  export type DepartmentScheduleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentScheduleCountOutputType
     */
    select?: DepartmentScheduleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DepartmentScheduleCountOutputType without action
   */
  export type DepartmentScheduleCountOutputTypeCountDepartmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentWhereInput
  }

  /**
   * DepartmentScheduleCountOutputType without action
   */
  export type DepartmentScheduleCountOutputTypeCountPeriodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentSchedulePeriodWhereInput
  }


  /**
   * Count Type CapabilityCountOutputType
   */

  export type CapabilityCountOutputType = {
    porterCapabilities: number
    departmentCapabilities: number
    serviceCapabilities: number
  }

  export type CapabilityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    porterCapabilities?: boolean | CapabilityCountOutputTypeCountPorterCapabilitiesArgs
    departmentCapabilities?: boolean | CapabilityCountOutputTypeCountDepartmentCapabilitiesArgs
    serviceCapabilities?: boolean | CapabilityCountOutputTypeCountServiceCapabilitiesArgs
  }

  // Custom InputTypes
  /**
   * CapabilityCountOutputType without action
   */
  export type CapabilityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapabilityCountOutputType
     */
    select?: CapabilityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CapabilityCountOutputType without action
   */
  export type CapabilityCountOutputTypeCountPorterCapabilitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PorterCapabilityWhereInput
  }

  /**
   * CapabilityCountOutputType without action
   */
  export type CapabilityCountOutputTypeCountDepartmentCapabilitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentCapabilityWhereInput
  }

  /**
   * CapabilityCountOutputType without action
   */
  export type CapabilityCountOutputTypeCountServiceCapabilitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceCapabilityWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Building
   */

  export type AggregateBuilding = {
    _count: BuildingCountAggregateOutputType | null
    _min: BuildingMinAggregateOutputType | null
    _max: BuildingMaxAggregateOutputType | null
  }

  export type BuildingMinAggregateOutputType = {
    id: string | null
    name: string | null
    location: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BuildingMaxAggregateOutputType = {
    id: string | null
    name: string | null
    location: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BuildingCountAggregateOutputType = {
    id: number
    name: number
    location: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BuildingMinAggregateInputType = {
    id?: true
    name?: true
    location?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BuildingMaxAggregateInputType = {
    id?: true
    name?: true
    location?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BuildingCountAggregateInputType = {
    id?: true
    name?: true
    location?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BuildingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Building to aggregate.
     */
    where?: BuildingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Buildings to fetch.
     */
    orderBy?: BuildingOrderByWithRelationInput | BuildingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BuildingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Buildings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Buildings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Buildings
    **/
    _count?: true | BuildingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BuildingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BuildingMaxAggregateInputType
  }

  export type GetBuildingAggregateType<T extends BuildingAggregateArgs> = {
        [P in keyof T & keyof AggregateBuilding]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBuilding[P]>
      : GetScalarType<T[P], AggregateBuilding[P]>
  }




  export type BuildingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BuildingWhereInput
    orderBy?: BuildingOrderByWithAggregationInput | BuildingOrderByWithAggregationInput[]
    by: BuildingScalarFieldEnum[] | BuildingScalarFieldEnum
    having?: BuildingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BuildingCountAggregateInputType | true
    _min?: BuildingMinAggregateInputType
    _max?: BuildingMaxAggregateInputType
  }

  export type BuildingGroupByOutputType = {
    id: string
    name: string
    location: string | null
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: BuildingCountAggregateOutputType | null
    _min: BuildingMinAggregateOutputType | null
    _max: BuildingMaxAggregateOutputType | null
  }

  type GetBuildingGroupByPayload<T extends BuildingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BuildingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BuildingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BuildingGroupByOutputType[P]>
            : GetScalarType<T[P], BuildingGroupByOutputType[P]>
        }
      >
    >


  export type BuildingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    location?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    departments?: boolean | Building$departmentsArgs<ExtArgs>
    _count?: boolean | BuildingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["building"]>


  export type BuildingSelectScalar = {
    id?: boolean
    name?: boolean
    location?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BuildingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    departments?: boolean | Building$departmentsArgs<ExtArgs>
    _count?: boolean | BuildingCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $BuildingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Building"
    objects: {
      departments: Prisma.$DepartmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      location: string | null
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["building"]>
    composites: {}
  }

  type BuildingGetPayload<S extends boolean | null | undefined | BuildingDefaultArgs> = $Result.GetResult<Prisma.$BuildingPayload, S>

  type BuildingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BuildingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BuildingCountAggregateInputType | true
    }

  export interface BuildingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Building'], meta: { name: 'Building' } }
    /**
     * Find zero or one Building that matches the filter.
     * @param {BuildingFindUniqueArgs} args - Arguments to find a Building
     * @example
     * // Get one Building
     * const building = await prisma.building.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BuildingFindUniqueArgs>(args: SelectSubset<T, BuildingFindUniqueArgs<ExtArgs>>): Prisma__BuildingClient<$Result.GetResult<Prisma.$BuildingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Building that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BuildingFindUniqueOrThrowArgs} args - Arguments to find a Building
     * @example
     * // Get one Building
     * const building = await prisma.building.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BuildingFindUniqueOrThrowArgs>(args: SelectSubset<T, BuildingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BuildingClient<$Result.GetResult<Prisma.$BuildingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Building that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildingFindFirstArgs} args - Arguments to find a Building
     * @example
     * // Get one Building
     * const building = await prisma.building.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BuildingFindFirstArgs>(args?: SelectSubset<T, BuildingFindFirstArgs<ExtArgs>>): Prisma__BuildingClient<$Result.GetResult<Prisma.$BuildingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Building that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildingFindFirstOrThrowArgs} args - Arguments to find a Building
     * @example
     * // Get one Building
     * const building = await prisma.building.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BuildingFindFirstOrThrowArgs>(args?: SelectSubset<T, BuildingFindFirstOrThrowArgs<ExtArgs>>): Prisma__BuildingClient<$Result.GetResult<Prisma.$BuildingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Buildings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Buildings
     * const buildings = await prisma.building.findMany()
     * 
     * // Get first 10 Buildings
     * const buildings = await prisma.building.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const buildingWithIdOnly = await prisma.building.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BuildingFindManyArgs>(args?: SelectSubset<T, BuildingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuildingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Building.
     * @param {BuildingCreateArgs} args - Arguments to create a Building.
     * @example
     * // Create one Building
     * const Building = await prisma.building.create({
     *   data: {
     *     // ... data to create a Building
     *   }
     * })
     * 
     */
    create<T extends BuildingCreateArgs>(args: SelectSubset<T, BuildingCreateArgs<ExtArgs>>): Prisma__BuildingClient<$Result.GetResult<Prisma.$BuildingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Buildings.
     * @param {BuildingCreateManyArgs} args - Arguments to create many Buildings.
     * @example
     * // Create many Buildings
     * const building = await prisma.building.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BuildingCreateManyArgs>(args?: SelectSubset<T, BuildingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Building.
     * @param {BuildingDeleteArgs} args - Arguments to delete one Building.
     * @example
     * // Delete one Building
     * const Building = await prisma.building.delete({
     *   where: {
     *     // ... filter to delete one Building
     *   }
     * })
     * 
     */
    delete<T extends BuildingDeleteArgs>(args: SelectSubset<T, BuildingDeleteArgs<ExtArgs>>): Prisma__BuildingClient<$Result.GetResult<Prisma.$BuildingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Building.
     * @param {BuildingUpdateArgs} args - Arguments to update one Building.
     * @example
     * // Update one Building
     * const building = await prisma.building.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BuildingUpdateArgs>(args: SelectSubset<T, BuildingUpdateArgs<ExtArgs>>): Prisma__BuildingClient<$Result.GetResult<Prisma.$BuildingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Buildings.
     * @param {BuildingDeleteManyArgs} args - Arguments to filter Buildings to delete.
     * @example
     * // Delete a few Buildings
     * const { count } = await prisma.building.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BuildingDeleteManyArgs>(args?: SelectSubset<T, BuildingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Buildings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Buildings
     * const building = await prisma.building.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BuildingUpdateManyArgs>(args: SelectSubset<T, BuildingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Building.
     * @param {BuildingUpsertArgs} args - Arguments to update or create a Building.
     * @example
     * // Update or create a Building
     * const building = await prisma.building.upsert({
     *   create: {
     *     // ... data to create a Building
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Building we want to update
     *   }
     * })
     */
    upsert<T extends BuildingUpsertArgs>(args: SelectSubset<T, BuildingUpsertArgs<ExtArgs>>): Prisma__BuildingClient<$Result.GetResult<Prisma.$BuildingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Buildings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildingCountArgs} args - Arguments to filter Buildings to count.
     * @example
     * // Count the number of Buildings
     * const count = await prisma.building.count({
     *   where: {
     *     // ... the filter for the Buildings we want to count
     *   }
     * })
    **/
    count<T extends BuildingCountArgs>(
      args?: Subset<T, BuildingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BuildingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Building.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BuildingAggregateArgs>(args: Subset<T, BuildingAggregateArgs>): Prisma.PrismaPromise<GetBuildingAggregateType<T>>

    /**
     * Group by Building.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BuildingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BuildingGroupByArgs['orderBy'] }
        : { orderBy?: BuildingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BuildingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBuildingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Building model
   */
  readonly fields: BuildingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Building.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BuildingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    departments<T extends Building$departmentsArgs<ExtArgs> = {}>(args?: Subset<T, Building$departmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Building model
   */ 
  interface BuildingFieldRefs {
    readonly id: FieldRef<"Building", 'String'>
    readonly name: FieldRef<"Building", 'String'>
    readonly location: FieldRef<"Building", 'String'>
    readonly description: FieldRef<"Building", 'String'>
    readonly createdAt: FieldRef<"Building", 'DateTime'>
    readonly updatedAt: FieldRef<"Building", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Building findUnique
   */
  export type BuildingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Building
     */
    select?: BuildingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingInclude<ExtArgs> | null
    /**
     * Filter, which Building to fetch.
     */
    where: BuildingWhereUniqueInput
  }

  /**
   * Building findUniqueOrThrow
   */
  export type BuildingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Building
     */
    select?: BuildingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingInclude<ExtArgs> | null
    /**
     * Filter, which Building to fetch.
     */
    where: BuildingWhereUniqueInput
  }

  /**
   * Building findFirst
   */
  export type BuildingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Building
     */
    select?: BuildingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingInclude<ExtArgs> | null
    /**
     * Filter, which Building to fetch.
     */
    where?: BuildingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Buildings to fetch.
     */
    orderBy?: BuildingOrderByWithRelationInput | BuildingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Buildings.
     */
    cursor?: BuildingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Buildings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Buildings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Buildings.
     */
    distinct?: BuildingScalarFieldEnum | BuildingScalarFieldEnum[]
  }

  /**
   * Building findFirstOrThrow
   */
  export type BuildingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Building
     */
    select?: BuildingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingInclude<ExtArgs> | null
    /**
     * Filter, which Building to fetch.
     */
    where?: BuildingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Buildings to fetch.
     */
    orderBy?: BuildingOrderByWithRelationInput | BuildingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Buildings.
     */
    cursor?: BuildingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Buildings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Buildings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Buildings.
     */
    distinct?: BuildingScalarFieldEnum | BuildingScalarFieldEnum[]
  }

  /**
   * Building findMany
   */
  export type BuildingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Building
     */
    select?: BuildingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingInclude<ExtArgs> | null
    /**
     * Filter, which Buildings to fetch.
     */
    where?: BuildingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Buildings to fetch.
     */
    orderBy?: BuildingOrderByWithRelationInput | BuildingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Buildings.
     */
    cursor?: BuildingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Buildings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Buildings.
     */
    skip?: number
    distinct?: BuildingScalarFieldEnum | BuildingScalarFieldEnum[]
  }

  /**
   * Building create
   */
  export type BuildingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Building
     */
    select?: BuildingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingInclude<ExtArgs> | null
    /**
     * The data needed to create a Building.
     */
    data: XOR<BuildingCreateInput, BuildingUncheckedCreateInput>
  }

  /**
   * Building createMany
   */
  export type BuildingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Buildings.
     */
    data: BuildingCreateManyInput | BuildingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Building update
   */
  export type BuildingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Building
     */
    select?: BuildingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingInclude<ExtArgs> | null
    /**
     * The data needed to update a Building.
     */
    data: XOR<BuildingUpdateInput, BuildingUncheckedUpdateInput>
    /**
     * Choose, which Building to update.
     */
    where: BuildingWhereUniqueInput
  }

  /**
   * Building updateMany
   */
  export type BuildingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Buildings.
     */
    data: XOR<BuildingUpdateManyMutationInput, BuildingUncheckedUpdateManyInput>
    /**
     * Filter which Buildings to update
     */
    where?: BuildingWhereInput
  }

  /**
   * Building upsert
   */
  export type BuildingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Building
     */
    select?: BuildingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingInclude<ExtArgs> | null
    /**
     * The filter to search for the Building to update in case it exists.
     */
    where: BuildingWhereUniqueInput
    /**
     * In case the Building found by the `where` argument doesn't exist, create a new Building with this data.
     */
    create: XOR<BuildingCreateInput, BuildingUncheckedCreateInput>
    /**
     * In case the Building was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BuildingUpdateInput, BuildingUncheckedUpdateInput>
  }

  /**
   * Building delete
   */
  export type BuildingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Building
     */
    select?: BuildingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingInclude<ExtArgs> | null
    /**
     * Filter which Building to delete.
     */
    where: BuildingWhereUniqueInput
  }

  /**
   * Building deleteMany
   */
  export type BuildingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Buildings to delete
     */
    where?: BuildingWhereInput
  }

  /**
   * Building.departments
   */
  export type Building$departmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    where?: DepartmentWhereInput
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    cursor?: DepartmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Building without action
   */
  export type BuildingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Building
     */
    select?: BuildingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingInclude<ExtArgs> | null
  }


  /**
   * Model Department
   */

  export type AggregateDepartment = {
    _count: DepartmentCountAggregateOutputType | null
    _min: DepartmentMinAggregateOutputType | null
    _max: DepartmentMaxAggregateOutputType | null
  }

  export type DepartmentMinAggregateOutputType = {
    id: string | null
    name: string | null
    buildingId: string | null
    scheduleId: string | null
    description: string | null
    is247: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepartmentMaxAggregateOutputType = {
    id: string | null
    name: string | null
    buildingId: string | null
    scheduleId: string | null
    description: string | null
    is247: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepartmentCountAggregateOutputType = {
    id: number
    name: number
    buildingId: number
    scheduleId: number
    description: number
    is247: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DepartmentMinAggregateInputType = {
    id?: true
    name?: true
    buildingId?: true
    scheduleId?: true
    description?: true
    is247?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepartmentMaxAggregateInputType = {
    id?: true
    name?: true
    buildingId?: true
    scheduleId?: true
    description?: true
    is247?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepartmentCountAggregateInputType = {
    id?: true
    name?: true
    buildingId?: true
    scheduleId?: true
    description?: true
    is247?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DepartmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Department to aggregate.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Departments
    **/
    _count?: true | DepartmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DepartmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DepartmentMaxAggregateInputType
  }

  export type GetDepartmentAggregateType<T extends DepartmentAggregateArgs> = {
        [P in keyof T & keyof AggregateDepartment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDepartment[P]>
      : GetScalarType<T[P], AggregateDepartment[P]>
  }




  export type DepartmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentWhereInput
    orderBy?: DepartmentOrderByWithAggregationInput | DepartmentOrderByWithAggregationInput[]
    by: DepartmentScalarFieldEnum[] | DepartmentScalarFieldEnum
    having?: DepartmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DepartmentCountAggregateInputType | true
    _min?: DepartmentMinAggregateInputType
    _max?: DepartmentMaxAggregateInputType
  }

  export type DepartmentGroupByOutputType = {
    id: string
    name: string
    buildingId: string
    scheduleId: string | null
    description: string | null
    is247: boolean
    createdAt: Date
    updatedAt: Date
    _count: DepartmentCountAggregateOutputType | null
    _min: DepartmentMinAggregateOutputType | null
    _max: DepartmentMaxAggregateOutputType | null
  }

  type GetDepartmentGroupByPayload<T extends DepartmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DepartmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DepartmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DepartmentGroupByOutputType[P]>
            : GetScalarType<T[P], DepartmentGroupByOutputType[P]>
        }
      >
    >


  export type DepartmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    buildingId?: boolean
    scheduleId?: boolean
    description?: boolean
    is247?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    building?: boolean | BuildingDefaultArgs<ExtArgs>
    schedule?: boolean | Department$scheduleArgs<ExtArgs>
    services?: boolean | Department$servicesArgs<ExtArgs>
    porters?: boolean | Department$portersArgs<ExtArgs>
    allocations?: boolean | Department$allocationsArgs<ExtArgs>
    departmentCapabilities?: boolean | Department$departmentCapabilitiesArgs<ExtArgs>
    _count?: boolean | DepartmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["department"]>


  export type DepartmentSelectScalar = {
    id?: boolean
    name?: boolean
    buildingId?: boolean
    scheduleId?: boolean
    description?: boolean
    is247?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DepartmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    building?: boolean | BuildingDefaultArgs<ExtArgs>
    schedule?: boolean | Department$scheduleArgs<ExtArgs>
    services?: boolean | Department$servicesArgs<ExtArgs>
    porters?: boolean | Department$portersArgs<ExtArgs>
    allocations?: boolean | Department$allocationsArgs<ExtArgs>
    departmentCapabilities?: boolean | Department$departmentCapabilitiesArgs<ExtArgs>
    _count?: boolean | DepartmentCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $DepartmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Department"
    objects: {
      building: Prisma.$BuildingPayload<ExtArgs>
      schedule: Prisma.$DepartmentSchedulePayload<ExtArgs> | null
      services: Prisma.$ServicePayload<ExtArgs>[]
      porters: Prisma.$PorterPayload<ExtArgs>[]
      allocations: Prisma.$AllocationPayload<ExtArgs>[]
      departmentCapabilities: Prisma.$DepartmentCapabilityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      buildingId: string
      scheduleId: string | null
      description: string | null
      is247: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["department"]>
    composites: {}
  }

  type DepartmentGetPayload<S extends boolean | null | undefined | DepartmentDefaultArgs> = $Result.GetResult<Prisma.$DepartmentPayload, S>

  type DepartmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DepartmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DepartmentCountAggregateInputType | true
    }

  export interface DepartmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Department'], meta: { name: 'Department' } }
    /**
     * Find zero or one Department that matches the filter.
     * @param {DepartmentFindUniqueArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DepartmentFindUniqueArgs>(args: SelectSubset<T, DepartmentFindUniqueArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Department that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DepartmentFindUniqueOrThrowArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DepartmentFindUniqueOrThrowArgs>(args: SelectSubset<T, DepartmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Department that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindFirstArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DepartmentFindFirstArgs>(args?: SelectSubset<T, DepartmentFindFirstArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Department that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindFirstOrThrowArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DepartmentFindFirstOrThrowArgs>(args?: SelectSubset<T, DepartmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Departments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Departments
     * const departments = await prisma.department.findMany()
     * 
     * // Get first 10 Departments
     * const departments = await prisma.department.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const departmentWithIdOnly = await prisma.department.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DepartmentFindManyArgs>(args?: SelectSubset<T, DepartmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Department.
     * @param {DepartmentCreateArgs} args - Arguments to create a Department.
     * @example
     * // Create one Department
     * const Department = await prisma.department.create({
     *   data: {
     *     // ... data to create a Department
     *   }
     * })
     * 
     */
    create<T extends DepartmentCreateArgs>(args: SelectSubset<T, DepartmentCreateArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Departments.
     * @param {DepartmentCreateManyArgs} args - Arguments to create many Departments.
     * @example
     * // Create many Departments
     * const department = await prisma.department.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DepartmentCreateManyArgs>(args?: SelectSubset<T, DepartmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Department.
     * @param {DepartmentDeleteArgs} args - Arguments to delete one Department.
     * @example
     * // Delete one Department
     * const Department = await prisma.department.delete({
     *   where: {
     *     // ... filter to delete one Department
     *   }
     * })
     * 
     */
    delete<T extends DepartmentDeleteArgs>(args: SelectSubset<T, DepartmentDeleteArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Department.
     * @param {DepartmentUpdateArgs} args - Arguments to update one Department.
     * @example
     * // Update one Department
     * const department = await prisma.department.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DepartmentUpdateArgs>(args: SelectSubset<T, DepartmentUpdateArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Departments.
     * @param {DepartmentDeleteManyArgs} args - Arguments to filter Departments to delete.
     * @example
     * // Delete a few Departments
     * const { count } = await prisma.department.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DepartmentDeleteManyArgs>(args?: SelectSubset<T, DepartmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Departments
     * const department = await prisma.department.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DepartmentUpdateManyArgs>(args: SelectSubset<T, DepartmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Department.
     * @param {DepartmentUpsertArgs} args - Arguments to update or create a Department.
     * @example
     * // Update or create a Department
     * const department = await prisma.department.upsert({
     *   create: {
     *     // ... data to create a Department
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Department we want to update
     *   }
     * })
     */
    upsert<T extends DepartmentUpsertArgs>(args: SelectSubset<T, DepartmentUpsertArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentCountArgs} args - Arguments to filter Departments to count.
     * @example
     * // Count the number of Departments
     * const count = await prisma.department.count({
     *   where: {
     *     // ... the filter for the Departments we want to count
     *   }
     * })
    **/
    count<T extends DepartmentCountArgs>(
      args?: Subset<T, DepartmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DepartmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DepartmentAggregateArgs>(args: Subset<T, DepartmentAggregateArgs>): Prisma.PrismaPromise<GetDepartmentAggregateType<T>>

    /**
     * Group by Department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DepartmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DepartmentGroupByArgs['orderBy'] }
        : { orderBy?: DepartmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DepartmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDepartmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Department model
   */
  readonly fields: DepartmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Department.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DepartmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    building<T extends BuildingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BuildingDefaultArgs<ExtArgs>>): Prisma__BuildingClient<$Result.GetResult<Prisma.$BuildingPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    schedule<T extends Department$scheduleArgs<ExtArgs> = {}>(args?: Subset<T, Department$scheduleArgs<ExtArgs>>): Prisma__DepartmentScheduleClient<$Result.GetResult<Prisma.$DepartmentSchedulePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    services<T extends Department$servicesArgs<ExtArgs> = {}>(args?: Subset<T, Department$servicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findMany"> | Null>
    porters<T extends Department$portersArgs<ExtArgs> = {}>(args?: Subset<T, Department$portersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PorterPayload<ExtArgs>, T, "findMany"> | Null>
    allocations<T extends Department$allocationsArgs<ExtArgs> = {}>(args?: Subset<T, Department$allocationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AllocationPayload<ExtArgs>, T, "findMany"> | Null>
    departmentCapabilities<T extends Department$departmentCapabilitiesArgs<ExtArgs> = {}>(args?: Subset<T, Department$departmentCapabilitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentCapabilityPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Department model
   */ 
  interface DepartmentFieldRefs {
    readonly id: FieldRef<"Department", 'String'>
    readonly name: FieldRef<"Department", 'String'>
    readonly buildingId: FieldRef<"Department", 'String'>
    readonly scheduleId: FieldRef<"Department", 'String'>
    readonly description: FieldRef<"Department", 'String'>
    readonly is247: FieldRef<"Department", 'Boolean'>
    readonly createdAt: FieldRef<"Department", 'DateTime'>
    readonly updatedAt: FieldRef<"Department", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Department findUnique
   */
  export type DepartmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department findUniqueOrThrow
   */
  export type DepartmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department findFirst
   */
  export type DepartmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departments.
     */
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department findFirstOrThrow
   */
  export type DepartmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departments.
     */
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department findMany
   */
  export type DepartmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Departments to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department create
   */
  export type DepartmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Department.
     */
    data: XOR<DepartmentCreateInput, DepartmentUncheckedCreateInput>
  }

  /**
   * Department createMany
   */
  export type DepartmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Departments.
     */
    data: DepartmentCreateManyInput | DepartmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Department update
   */
  export type DepartmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Department.
     */
    data: XOR<DepartmentUpdateInput, DepartmentUncheckedUpdateInput>
    /**
     * Choose, which Department to update.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department updateMany
   */
  export type DepartmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Departments.
     */
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyInput>
    /**
     * Filter which Departments to update
     */
    where?: DepartmentWhereInput
  }

  /**
   * Department upsert
   */
  export type DepartmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Department to update in case it exists.
     */
    where: DepartmentWhereUniqueInput
    /**
     * In case the Department found by the `where` argument doesn't exist, create a new Department with this data.
     */
    create: XOR<DepartmentCreateInput, DepartmentUncheckedCreateInput>
    /**
     * In case the Department was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DepartmentUpdateInput, DepartmentUncheckedUpdateInput>
  }

  /**
   * Department delete
   */
  export type DepartmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter which Department to delete.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department deleteMany
   */
  export type DepartmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Departments to delete
     */
    where?: DepartmentWhereInput
  }

  /**
   * Department.schedule
   */
  export type Department$scheduleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentSchedule
     */
    select?: DepartmentScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentScheduleInclude<ExtArgs> | null
    where?: DepartmentScheduleWhereInput
  }

  /**
   * Department.services
   */
  export type Department$servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    cursor?: ServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Department.porters
   */
  export type Department$portersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Porter
     */
    select?: PorterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PorterInclude<ExtArgs> | null
    where?: PorterWhereInput
    orderBy?: PorterOrderByWithRelationInput | PorterOrderByWithRelationInput[]
    cursor?: PorterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PorterScalarFieldEnum | PorterScalarFieldEnum[]
  }

  /**
   * Department.allocations
   */
  export type Department$allocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allocation
     */
    select?: AllocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllocationInclude<ExtArgs> | null
    where?: AllocationWhereInput
    orderBy?: AllocationOrderByWithRelationInput | AllocationOrderByWithRelationInput[]
    cursor?: AllocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AllocationScalarFieldEnum | AllocationScalarFieldEnum[]
  }

  /**
   * Department.departmentCapabilities
   */
  export type Department$departmentCapabilitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentCapability
     */
    select?: DepartmentCapabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentCapabilityInclude<ExtArgs> | null
    where?: DepartmentCapabilityWhereInput
    orderBy?: DepartmentCapabilityOrderByWithRelationInput | DepartmentCapabilityOrderByWithRelationInput[]
    cursor?: DepartmentCapabilityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DepartmentCapabilityScalarFieldEnum | DepartmentCapabilityScalarFieldEnum[]
  }

  /**
   * Department without action
   */
  export type DepartmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
  }


  /**
   * Model Service
   */

  export type AggregateService = {
    _count: ServiceCountAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  export type ServiceMinAggregateOutputType = {
    id: string | null
    name: string | null
    departmentId: string | null
    description: string | null
    isActive: boolean | null
    inheritsSchedule: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceMaxAggregateOutputType = {
    id: string | null
    name: string | null
    departmentId: string | null
    description: string | null
    isActive: boolean | null
    inheritsSchedule: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceCountAggregateOutputType = {
    id: number
    name: number
    departmentId: number
    description: number
    isActive: number
    inheritsSchedule: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ServiceMinAggregateInputType = {
    id?: true
    name?: true
    departmentId?: true
    description?: true
    isActive?: true
    inheritsSchedule?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceMaxAggregateInputType = {
    id?: true
    name?: true
    departmentId?: true
    description?: true
    isActive?: true
    inheritsSchedule?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceCountAggregateInputType = {
    id?: true
    name?: true
    departmentId?: true
    description?: true
    isActive?: true
    inheritsSchedule?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Service to aggregate.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Services
    **/
    _count?: true | ServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceMaxAggregateInputType
  }

  export type GetServiceAggregateType<T extends ServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateService[P]>
      : GetScalarType<T[P], AggregateService[P]>
  }




  export type ServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithAggregationInput | ServiceOrderByWithAggregationInput[]
    by: ServiceScalarFieldEnum[] | ServiceScalarFieldEnum
    having?: ServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceCountAggregateInputType | true
    _min?: ServiceMinAggregateInputType
    _max?: ServiceMaxAggregateInputType
  }

  export type ServiceGroupByOutputType = {
    id: string
    name: string
    departmentId: string
    description: string | null
    isActive: boolean
    inheritsSchedule: boolean
    createdAt: Date
    updatedAt: Date
    _count: ServiceCountAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  type GetServiceGroupByPayload<T extends ServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceGroupByOutputType[P]>
        }
      >
    >


  export type ServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    departmentId?: boolean
    description?: boolean
    isActive?: boolean
    inheritsSchedule?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
    allocations?: boolean | Service$allocationsArgs<ExtArgs>
    serviceCapabilities?: boolean | Service$serviceCapabilitiesArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>


  export type ServiceSelectScalar = {
    id?: boolean
    name?: boolean
    departmentId?: boolean
    description?: boolean
    isActive?: boolean
    inheritsSchedule?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
    allocations?: boolean | Service$allocationsArgs<ExtArgs>
    serviceCapabilities?: boolean | Service$serviceCapabilitiesArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Service"
    objects: {
      department: Prisma.$DepartmentPayload<ExtArgs>
      allocations: Prisma.$AllocationPayload<ExtArgs>[]
      serviceCapabilities: Prisma.$ServiceCapabilityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      departmentId: string
      description: string | null
      isActive: boolean
      inheritsSchedule: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["service"]>
    composites: {}
  }

  type ServiceGetPayload<S extends boolean | null | undefined | ServiceDefaultArgs> = $Result.GetResult<Prisma.$ServicePayload, S>

  type ServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ServiceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ServiceCountAggregateInputType | true
    }

  export interface ServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Service'], meta: { name: 'Service' } }
    /**
     * Find zero or one Service that matches the filter.
     * @param {ServiceFindUniqueArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceFindUniqueArgs>(args: SelectSubset<T, ServiceFindUniqueArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Service that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ServiceFindUniqueOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Service that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceFindFirstArgs>(args?: SelectSubset<T, ServiceFindFirstArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Service that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Services
     * const services = await prisma.service.findMany()
     * 
     * // Get first 10 Services
     * const services = await prisma.service.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceWithIdOnly = await prisma.service.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceFindManyArgs>(args?: SelectSubset<T, ServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Service.
     * @param {ServiceCreateArgs} args - Arguments to create a Service.
     * @example
     * // Create one Service
     * const Service = await prisma.service.create({
     *   data: {
     *     // ... data to create a Service
     *   }
     * })
     * 
     */
    create<T extends ServiceCreateArgs>(args: SelectSubset<T, ServiceCreateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Services.
     * @param {ServiceCreateManyArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceCreateManyArgs>(args?: SelectSubset<T, ServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Service.
     * @param {ServiceDeleteArgs} args - Arguments to delete one Service.
     * @example
     * // Delete one Service
     * const Service = await prisma.service.delete({
     *   where: {
     *     // ... filter to delete one Service
     *   }
     * })
     * 
     */
    delete<T extends ServiceDeleteArgs>(args: SelectSubset<T, ServiceDeleteArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Service.
     * @param {ServiceUpdateArgs} args - Arguments to update one Service.
     * @example
     * // Update one Service
     * const service = await prisma.service.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceUpdateArgs>(args: SelectSubset<T, ServiceUpdateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Services.
     * @param {ServiceDeleteManyArgs} args - Arguments to filter Services to delete.
     * @example
     * // Delete a few Services
     * const { count } = await prisma.service.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceDeleteManyArgs>(args?: SelectSubset<T, ServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceUpdateManyArgs>(args: SelectSubset<T, ServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Service.
     * @param {ServiceUpsertArgs} args - Arguments to update or create a Service.
     * @example
     * // Update or create a Service
     * const service = await prisma.service.upsert({
     *   create: {
     *     // ... data to create a Service
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Service we want to update
     *   }
     * })
     */
    upsert<T extends ServiceUpsertArgs>(args: SelectSubset<T, ServiceUpsertArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCountArgs} args - Arguments to filter Services to count.
     * @example
     * // Count the number of Services
     * const count = await prisma.service.count({
     *   where: {
     *     // ... the filter for the Services we want to count
     *   }
     * })
    **/
    count<T extends ServiceCountArgs>(
      args?: Subset<T, ServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceAggregateArgs>(args: Subset<T, ServiceAggregateArgs>): Prisma.PrismaPromise<GetServiceAggregateType<T>>

    /**
     * Group by Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceGroupByArgs['orderBy'] }
        : { orderBy?: ServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Service model
   */
  readonly fields: ServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Service.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    department<T extends DepartmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DepartmentDefaultArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    allocations<T extends Service$allocationsArgs<ExtArgs> = {}>(args?: Subset<T, Service$allocationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AllocationPayload<ExtArgs>, T, "findMany"> | Null>
    serviceCapabilities<T extends Service$serviceCapabilitiesArgs<ExtArgs> = {}>(args?: Subset<T, Service$serviceCapabilitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceCapabilityPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Service model
   */ 
  interface ServiceFieldRefs {
    readonly id: FieldRef<"Service", 'String'>
    readonly name: FieldRef<"Service", 'String'>
    readonly departmentId: FieldRef<"Service", 'String'>
    readonly description: FieldRef<"Service", 'String'>
    readonly isActive: FieldRef<"Service", 'Boolean'>
    readonly inheritsSchedule: FieldRef<"Service", 'Boolean'>
    readonly createdAt: FieldRef<"Service", 'DateTime'>
    readonly updatedAt: FieldRef<"Service", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Service findUnique
   */
  export type ServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findUniqueOrThrow
   */
  export type ServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findFirst
   */
  export type ServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findFirstOrThrow
   */
  export type ServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findMany
   */
  export type ServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Services to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service create
   */
  export type ServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Service.
     */
    data: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
  }

  /**
   * Service createMany
   */
  export type ServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Service update
   */
  export type ServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Service.
     */
    data: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
    /**
     * Choose, which Service to update.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service updateMany
   */
  export type ServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput
  }

  /**
   * Service upsert
   */
  export type ServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Service to update in case it exists.
     */
    where: ServiceWhereUniqueInput
    /**
     * In case the Service found by the `where` argument doesn't exist, create a new Service with this data.
     */
    create: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
    /**
     * In case the Service was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
  }

  /**
   * Service delete
   */
  export type ServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter which Service to delete.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service deleteMany
   */
  export type ServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Services to delete
     */
    where?: ServiceWhereInput
  }

  /**
   * Service.allocations
   */
  export type Service$allocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allocation
     */
    select?: AllocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllocationInclude<ExtArgs> | null
    where?: AllocationWhereInput
    orderBy?: AllocationOrderByWithRelationInput | AllocationOrderByWithRelationInput[]
    cursor?: AllocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AllocationScalarFieldEnum | AllocationScalarFieldEnum[]
  }

  /**
   * Service.serviceCapabilities
   */
  export type Service$serviceCapabilitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCapability
     */
    select?: ServiceCapabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCapabilityInclude<ExtArgs> | null
    where?: ServiceCapabilityWhereInput
    orderBy?: ServiceCapabilityOrderByWithRelationInput | ServiceCapabilityOrderByWithRelationInput[]
    cursor?: ServiceCapabilityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceCapabilityScalarFieldEnum | ServiceCapabilityScalarFieldEnum[]
  }

  /**
   * Service without action
   */
  export type ServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
  }


  /**
   * Model Porter
   */

  export type AggregatePorter = {
    _count: PorterCountAggregateOutputType | null
    _avg: PorterAvgAggregateOutputType | null
    _sum: PorterSumAggregateOutputType | null
    _min: PorterMinAggregateOutputType | null
    _max: PorterMaxAggregateOutputType | null
  }

  export type PorterAvgAggregateOutputType = {
    weeklyMinHours: number | null
    contractedHours: number | null
  }

  export type PorterSumAggregateOutputType = {
    weeklyMinHours: number | null
    contractedHours: number | null
  }

  export type PorterMinAggregateOutputType = {
    id: string | null
    name: string | null
    contractType: $Enums.ContractType | null
    shiftId: string | null
    weeklyMinHours: number | null
    contractedHours: number | null
    regularDepartmentId: string | null
    porterType: $Enums.PorterType | null
    countsTowardsStaffing: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PorterMaxAggregateOutputType = {
    id: string | null
    name: string | null
    contractType: $Enums.ContractType | null
    shiftId: string | null
    weeklyMinHours: number | null
    contractedHours: number | null
    regularDepartmentId: string | null
    porterType: $Enums.PorterType | null
    countsTowardsStaffing: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PorterCountAggregateOutputType = {
    id: number
    name: number
    contractType: number
    shiftId: number
    weeklyMinHours: number
    contractedHours: number
    regularDepartmentId: number
    porterType: number
    countsTowardsStaffing: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PorterAvgAggregateInputType = {
    weeklyMinHours?: true
    contractedHours?: true
  }

  export type PorterSumAggregateInputType = {
    weeklyMinHours?: true
    contractedHours?: true
  }

  export type PorterMinAggregateInputType = {
    id?: true
    name?: true
    contractType?: true
    shiftId?: true
    weeklyMinHours?: true
    contractedHours?: true
    regularDepartmentId?: true
    porterType?: true
    countsTowardsStaffing?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PorterMaxAggregateInputType = {
    id?: true
    name?: true
    contractType?: true
    shiftId?: true
    weeklyMinHours?: true
    contractedHours?: true
    regularDepartmentId?: true
    porterType?: true
    countsTowardsStaffing?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PorterCountAggregateInputType = {
    id?: true
    name?: true
    contractType?: true
    shiftId?: true
    weeklyMinHours?: true
    contractedHours?: true
    regularDepartmentId?: true
    porterType?: true
    countsTowardsStaffing?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PorterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Porter to aggregate.
     */
    where?: PorterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Porters to fetch.
     */
    orderBy?: PorterOrderByWithRelationInput | PorterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PorterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Porters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Porters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Porters
    **/
    _count?: true | PorterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PorterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PorterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PorterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PorterMaxAggregateInputType
  }

  export type GetPorterAggregateType<T extends PorterAggregateArgs> = {
        [P in keyof T & keyof AggregatePorter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePorter[P]>
      : GetScalarType<T[P], AggregatePorter[P]>
  }




  export type PorterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PorterWhereInput
    orderBy?: PorterOrderByWithAggregationInput | PorterOrderByWithAggregationInput[]
    by: PorterScalarFieldEnum[] | PorterScalarFieldEnum
    having?: PorterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PorterCountAggregateInputType | true
    _avg?: PorterAvgAggregateInputType
    _sum?: PorterSumAggregateInputType
    _min?: PorterMinAggregateInputType
    _max?: PorterMaxAggregateInputType
  }

  export type PorterGroupByOutputType = {
    id: string
    name: string
    contractType: $Enums.ContractType
    shiftId: string | null
    weeklyMinHours: number | null
    contractedHours: number | null
    regularDepartmentId: string | null
    porterType: $Enums.PorterType
    countsTowardsStaffing: boolean
    createdAt: Date
    updatedAt: Date
    _count: PorterCountAggregateOutputType | null
    _avg: PorterAvgAggregateOutputType | null
    _sum: PorterSumAggregateOutputType | null
    _min: PorterMinAggregateOutputType | null
    _max: PorterMaxAggregateOutputType | null
  }

  type GetPorterGroupByPayload<T extends PorterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PorterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PorterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PorterGroupByOutputType[P]>
            : GetScalarType<T[P], PorterGroupByOutputType[P]>
        }
      >
    >


  export type PorterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    contractType?: boolean
    shiftId?: boolean
    weeklyMinHours?: boolean
    contractedHours?: boolean
    regularDepartmentId?: boolean
    porterType?: boolean
    countsTowardsStaffing?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    shift?: boolean | Porter$shiftArgs<ExtArgs>
    regularDepartment?: boolean | Porter$regularDepartmentArgs<ExtArgs>
    allocations?: boolean | Porter$allocationsArgs<ExtArgs>
    availability?: boolean | Porter$availabilityArgs<ExtArgs>
    porterCapabilities?: boolean | Porter$porterCapabilitiesArgs<ExtArgs>
    _count?: boolean | PorterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["porter"]>


  export type PorterSelectScalar = {
    id?: boolean
    name?: boolean
    contractType?: boolean
    shiftId?: boolean
    weeklyMinHours?: boolean
    contractedHours?: boolean
    regularDepartmentId?: boolean
    porterType?: boolean
    countsTowardsStaffing?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PorterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shift?: boolean | Porter$shiftArgs<ExtArgs>
    regularDepartment?: boolean | Porter$regularDepartmentArgs<ExtArgs>
    allocations?: boolean | Porter$allocationsArgs<ExtArgs>
    availability?: boolean | Porter$availabilityArgs<ExtArgs>
    porterCapabilities?: boolean | Porter$porterCapabilitiesArgs<ExtArgs>
    _count?: boolean | PorterCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $PorterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Porter"
    objects: {
      shift: Prisma.$ShiftPayload<ExtArgs> | null
      regularDepartment: Prisma.$DepartmentPayload<ExtArgs> | null
      allocations: Prisma.$AllocationPayload<ExtArgs>[]
      availability: Prisma.$AvailabilityPayload<ExtArgs>[]
      porterCapabilities: Prisma.$PorterCapabilityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      contractType: $Enums.ContractType
      shiftId: string | null
      weeklyMinHours: number | null
      contractedHours: number | null
      regularDepartmentId: string | null
      porterType: $Enums.PorterType
      countsTowardsStaffing: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["porter"]>
    composites: {}
  }

  type PorterGetPayload<S extends boolean | null | undefined | PorterDefaultArgs> = $Result.GetResult<Prisma.$PorterPayload, S>

  type PorterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PorterFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PorterCountAggregateInputType | true
    }

  export interface PorterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Porter'], meta: { name: 'Porter' } }
    /**
     * Find zero or one Porter that matches the filter.
     * @param {PorterFindUniqueArgs} args - Arguments to find a Porter
     * @example
     * // Get one Porter
     * const porter = await prisma.porter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PorterFindUniqueArgs>(args: SelectSubset<T, PorterFindUniqueArgs<ExtArgs>>): Prisma__PorterClient<$Result.GetResult<Prisma.$PorterPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Porter that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PorterFindUniqueOrThrowArgs} args - Arguments to find a Porter
     * @example
     * // Get one Porter
     * const porter = await prisma.porter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PorterFindUniqueOrThrowArgs>(args: SelectSubset<T, PorterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PorterClient<$Result.GetResult<Prisma.$PorterPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Porter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PorterFindFirstArgs} args - Arguments to find a Porter
     * @example
     * // Get one Porter
     * const porter = await prisma.porter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PorterFindFirstArgs>(args?: SelectSubset<T, PorterFindFirstArgs<ExtArgs>>): Prisma__PorterClient<$Result.GetResult<Prisma.$PorterPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Porter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PorterFindFirstOrThrowArgs} args - Arguments to find a Porter
     * @example
     * // Get one Porter
     * const porter = await prisma.porter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PorterFindFirstOrThrowArgs>(args?: SelectSubset<T, PorterFindFirstOrThrowArgs<ExtArgs>>): Prisma__PorterClient<$Result.GetResult<Prisma.$PorterPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Porters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PorterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Porters
     * const porters = await prisma.porter.findMany()
     * 
     * // Get first 10 Porters
     * const porters = await prisma.porter.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const porterWithIdOnly = await prisma.porter.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PorterFindManyArgs>(args?: SelectSubset<T, PorterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PorterPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Porter.
     * @param {PorterCreateArgs} args - Arguments to create a Porter.
     * @example
     * // Create one Porter
     * const Porter = await prisma.porter.create({
     *   data: {
     *     // ... data to create a Porter
     *   }
     * })
     * 
     */
    create<T extends PorterCreateArgs>(args: SelectSubset<T, PorterCreateArgs<ExtArgs>>): Prisma__PorterClient<$Result.GetResult<Prisma.$PorterPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Porters.
     * @param {PorterCreateManyArgs} args - Arguments to create many Porters.
     * @example
     * // Create many Porters
     * const porter = await prisma.porter.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PorterCreateManyArgs>(args?: SelectSubset<T, PorterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Porter.
     * @param {PorterDeleteArgs} args - Arguments to delete one Porter.
     * @example
     * // Delete one Porter
     * const Porter = await prisma.porter.delete({
     *   where: {
     *     // ... filter to delete one Porter
     *   }
     * })
     * 
     */
    delete<T extends PorterDeleteArgs>(args: SelectSubset<T, PorterDeleteArgs<ExtArgs>>): Prisma__PorterClient<$Result.GetResult<Prisma.$PorterPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Porter.
     * @param {PorterUpdateArgs} args - Arguments to update one Porter.
     * @example
     * // Update one Porter
     * const porter = await prisma.porter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PorterUpdateArgs>(args: SelectSubset<T, PorterUpdateArgs<ExtArgs>>): Prisma__PorterClient<$Result.GetResult<Prisma.$PorterPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Porters.
     * @param {PorterDeleteManyArgs} args - Arguments to filter Porters to delete.
     * @example
     * // Delete a few Porters
     * const { count } = await prisma.porter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PorterDeleteManyArgs>(args?: SelectSubset<T, PorterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Porters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PorterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Porters
     * const porter = await prisma.porter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PorterUpdateManyArgs>(args: SelectSubset<T, PorterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Porter.
     * @param {PorterUpsertArgs} args - Arguments to update or create a Porter.
     * @example
     * // Update or create a Porter
     * const porter = await prisma.porter.upsert({
     *   create: {
     *     // ... data to create a Porter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Porter we want to update
     *   }
     * })
     */
    upsert<T extends PorterUpsertArgs>(args: SelectSubset<T, PorterUpsertArgs<ExtArgs>>): Prisma__PorterClient<$Result.GetResult<Prisma.$PorterPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Porters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PorterCountArgs} args - Arguments to filter Porters to count.
     * @example
     * // Count the number of Porters
     * const count = await prisma.porter.count({
     *   where: {
     *     // ... the filter for the Porters we want to count
     *   }
     * })
    **/
    count<T extends PorterCountArgs>(
      args?: Subset<T, PorterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PorterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Porter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PorterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PorterAggregateArgs>(args: Subset<T, PorterAggregateArgs>): Prisma.PrismaPromise<GetPorterAggregateType<T>>

    /**
     * Group by Porter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PorterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PorterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PorterGroupByArgs['orderBy'] }
        : { orderBy?: PorterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PorterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPorterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Porter model
   */
  readonly fields: PorterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Porter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PorterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    shift<T extends Porter$shiftArgs<ExtArgs> = {}>(args?: Subset<T, Porter$shiftArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    regularDepartment<T extends Porter$regularDepartmentArgs<ExtArgs> = {}>(args?: Subset<T, Porter$regularDepartmentArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    allocations<T extends Porter$allocationsArgs<ExtArgs> = {}>(args?: Subset<T, Porter$allocationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AllocationPayload<ExtArgs>, T, "findMany"> | Null>
    availability<T extends Porter$availabilityArgs<ExtArgs> = {}>(args?: Subset<T, Porter$availabilityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AvailabilityPayload<ExtArgs>, T, "findMany"> | Null>
    porterCapabilities<T extends Porter$porterCapabilitiesArgs<ExtArgs> = {}>(args?: Subset<T, Porter$porterCapabilitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PorterCapabilityPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Porter model
   */ 
  interface PorterFieldRefs {
    readonly id: FieldRef<"Porter", 'String'>
    readonly name: FieldRef<"Porter", 'String'>
    readonly contractType: FieldRef<"Porter", 'ContractType'>
    readonly shiftId: FieldRef<"Porter", 'String'>
    readonly weeklyMinHours: FieldRef<"Porter", 'Int'>
    readonly contractedHours: FieldRef<"Porter", 'Int'>
    readonly regularDepartmentId: FieldRef<"Porter", 'String'>
    readonly porterType: FieldRef<"Porter", 'PorterType'>
    readonly countsTowardsStaffing: FieldRef<"Porter", 'Boolean'>
    readonly createdAt: FieldRef<"Porter", 'DateTime'>
    readonly updatedAt: FieldRef<"Porter", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Porter findUnique
   */
  export type PorterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Porter
     */
    select?: PorterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PorterInclude<ExtArgs> | null
    /**
     * Filter, which Porter to fetch.
     */
    where: PorterWhereUniqueInput
  }

  /**
   * Porter findUniqueOrThrow
   */
  export type PorterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Porter
     */
    select?: PorterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PorterInclude<ExtArgs> | null
    /**
     * Filter, which Porter to fetch.
     */
    where: PorterWhereUniqueInput
  }

  /**
   * Porter findFirst
   */
  export type PorterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Porter
     */
    select?: PorterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PorterInclude<ExtArgs> | null
    /**
     * Filter, which Porter to fetch.
     */
    where?: PorterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Porters to fetch.
     */
    orderBy?: PorterOrderByWithRelationInput | PorterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Porters.
     */
    cursor?: PorterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Porters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Porters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Porters.
     */
    distinct?: PorterScalarFieldEnum | PorterScalarFieldEnum[]
  }

  /**
   * Porter findFirstOrThrow
   */
  export type PorterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Porter
     */
    select?: PorterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PorterInclude<ExtArgs> | null
    /**
     * Filter, which Porter to fetch.
     */
    where?: PorterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Porters to fetch.
     */
    orderBy?: PorterOrderByWithRelationInput | PorterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Porters.
     */
    cursor?: PorterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Porters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Porters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Porters.
     */
    distinct?: PorterScalarFieldEnum | PorterScalarFieldEnum[]
  }

  /**
   * Porter findMany
   */
  export type PorterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Porter
     */
    select?: PorterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PorterInclude<ExtArgs> | null
    /**
     * Filter, which Porters to fetch.
     */
    where?: PorterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Porters to fetch.
     */
    orderBy?: PorterOrderByWithRelationInput | PorterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Porters.
     */
    cursor?: PorterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Porters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Porters.
     */
    skip?: number
    distinct?: PorterScalarFieldEnum | PorterScalarFieldEnum[]
  }

  /**
   * Porter create
   */
  export type PorterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Porter
     */
    select?: PorterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PorterInclude<ExtArgs> | null
    /**
     * The data needed to create a Porter.
     */
    data: XOR<PorterCreateInput, PorterUncheckedCreateInput>
  }

  /**
   * Porter createMany
   */
  export type PorterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Porters.
     */
    data: PorterCreateManyInput | PorterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Porter update
   */
  export type PorterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Porter
     */
    select?: PorterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PorterInclude<ExtArgs> | null
    /**
     * The data needed to update a Porter.
     */
    data: XOR<PorterUpdateInput, PorterUncheckedUpdateInput>
    /**
     * Choose, which Porter to update.
     */
    where: PorterWhereUniqueInput
  }

  /**
   * Porter updateMany
   */
  export type PorterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Porters.
     */
    data: XOR<PorterUpdateManyMutationInput, PorterUncheckedUpdateManyInput>
    /**
     * Filter which Porters to update
     */
    where?: PorterWhereInput
  }

  /**
   * Porter upsert
   */
  export type PorterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Porter
     */
    select?: PorterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PorterInclude<ExtArgs> | null
    /**
     * The filter to search for the Porter to update in case it exists.
     */
    where: PorterWhereUniqueInput
    /**
     * In case the Porter found by the `where` argument doesn't exist, create a new Porter with this data.
     */
    create: XOR<PorterCreateInput, PorterUncheckedCreateInput>
    /**
     * In case the Porter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PorterUpdateInput, PorterUncheckedUpdateInput>
  }

  /**
   * Porter delete
   */
  export type PorterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Porter
     */
    select?: PorterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PorterInclude<ExtArgs> | null
    /**
     * Filter which Porter to delete.
     */
    where: PorterWhereUniqueInput
  }

  /**
   * Porter deleteMany
   */
  export type PorterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Porters to delete
     */
    where?: PorterWhereInput
  }

  /**
   * Porter.shift
   */
  export type Porter$shiftArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    where?: ShiftWhereInput
  }

  /**
   * Porter.regularDepartment
   */
  export type Porter$regularDepartmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    where?: DepartmentWhereInput
  }

  /**
   * Porter.allocations
   */
  export type Porter$allocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allocation
     */
    select?: AllocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllocationInclude<ExtArgs> | null
    where?: AllocationWhereInput
    orderBy?: AllocationOrderByWithRelationInput | AllocationOrderByWithRelationInput[]
    cursor?: AllocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AllocationScalarFieldEnum | AllocationScalarFieldEnum[]
  }

  /**
   * Porter.availability
   */
  export type Porter$availabilityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Availability
     */
    select?: AvailabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityInclude<ExtArgs> | null
    where?: AvailabilityWhereInput
    orderBy?: AvailabilityOrderByWithRelationInput | AvailabilityOrderByWithRelationInput[]
    cursor?: AvailabilityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AvailabilityScalarFieldEnum | AvailabilityScalarFieldEnum[]
  }

  /**
   * Porter.porterCapabilities
   */
  export type Porter$porterCapabilitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PorterCapability
     */
    select?: PorterCapabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PorterCapabilityInclude<ExtArgs> | null
    where?: PorterCapabilityWhereInput
    orderBy?: PorterCapabilityOrderByWithRelationInput | PorterCapabilityOrderByWithRelationInput[]
    cursor?: PorterCapabilityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PorterCapabilityScalarFieldEnum | PorterCapabilityScalarFieldEnum[]
  }

  /**
   * Porter without action
   */
  export type PorterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Porter
     */
    select?: PorterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PorterInclude<ExtArgs> | null
  }


  /**
   * Model Shift
   */

  export type AggregateShift = {
    _count: ShiftCountAggregateOutputType | null
    _avg: ShiftAvgAggregateOutputType | null
    _sum: ShiftSumAggregateOutputType | null
    _min: ShiftMinAggregateOutputType | null
    _max: ShiftMaxAggregateOutputType | null
  }

  export type ShiftAvgAggregateOutputType = {
    daysOn: number | null
    daysOff: number | null
    offsetDays: number | null
  }

  export type ShiftSumAggregateOutputType = {
    daysOn: number | null
    daysOff: number | null
    offsetDays: number | null
  }

  export type ShiftMinAggregateOutputType = {
    id: string | null
    name: string | null
    patternId: string | null
    shiftMode: $Enums.ShiftMode | null
    ident: string | null
    daysOn: number | null
    daysOff: number | null
    offsetDays: number | null
    groundZero: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShiftMaxAggregateOutputType = {
    id: string | null
    name: string | null
    patternId: string | null
    shiftMode: $Enums.ShiftMode | null
    ident: string | null
    daysOn: number | null
    daysOff: number | null
    offsetDays: number | null
    groundZero: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShiftCountAggregateOutputType = {
    id: number
    name: number
    patternId: number
    shiftMode: number
    ident: number
    daysOn: number
    daysOff: number
    offsetDays: number
    groundZero: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ShiftAvgAggregateInputType = {
    daysOn?: true
    daysOff?: true
    offsetDays?: true
  }

  export type ShiftSumAggregateInputType = {
    daysOn?: true
    daysOff?: true
    offsetDays?: true
  }

  export type ShiftMinAggregateInputType = {
    id?: true
    name?: true
    patternId?: true
    shiftMode?: true
    ident?: true
    daysOn?: true
    daysOff?: true
    offsetDays?: true
    groundZero?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShiftMaxAggregateInputType = {
    id?: true
    name?: true
    patternId?: true
    shiftMode?: true
    ident?: true
    daysOn?: true
    daysOff?: true
    offsetDays?: true
    groundZero?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShiftCountAggregateInputType = {
    id?: true
    name?: true
    patternId?: true
    shiftMode?: true
    ident?: true
    daysOn?: true
    daysOff?: true
    offsetDays?: true
    groundZero?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ShiftAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Shift to aggregate.
     */
    where?: ShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shifts to fetch.
     */
    orderBy?: ShiftOrderByWithRelationInput | ShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Shifts
    **/
    _count?: true | ShiftCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ShiftAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ShiftSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShiftMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShiftMaxAggregateInputType
  }

  export type GetShiftAggregateType<T extends ShiftAggregateArgs> = {
        [P in keyof T & keyof AggregateShift]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShift[P]>
      : GetScalarType<T[P], AggregateShift[P]>
  }




  export type ShiftGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShiftWhereInput
    orderBy?: ShiftOrderByWithAggregationInput | ShiftOrderByWithAggregationInput[]
    by: ShiftScalarFieldEnum[] | ShiftScalarFieldEnum
    having?: ShiftScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShiftCountAggregateInputType | true
    _avg?: ShiftAvgAggregateInputType
    _sum?: ShiftSumAggregateInputType
    _min?: ShiftMinAggregateInputType
    _max?: ShiftMaxAggregateInputType
  }

  export type ShiftGroupByOutputType = {
    id: string
    name: string
    patternId: string
    shiftMode: $Enums.ShiftMode
    ident: string
    daysOn: number
    daysOff: number
    offsetDays: number
    groundZero: Date
    createdAt: Date
    updatedAt: Date
    _count: ShiftCountAggregateOutputType | null
    _avg: ShiftAvgAggregateOutputType | null
    _sum: ShiftSumAggregateOutputType | null
    _min: ShiftMinAggregateOutputType | null
    _max: ShiftMaxAggregateOutputType | null
  }

  type GetShiftGroupByPayload<T extends ShiftGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShiftGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShiftGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShiftGroupByOutputType[P]>
            : GetScalarType<T[P], ShiftGroupByOutputType[P]>
        }
      >
    >


  export type ShiftSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    patternId?: boolean
    shiftMode?: boolean
    ident?: boolean
    daysOn?: boolean
    daysOff?: boolean
    offsetDays?: boolean
    groundZero?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pattern?: boolean | ShiftPatternDefaultArgs<ExtArgs>
    porters?: boolean | Shift$portersArgs<ExtArgs>
    _count?: boolean | ShiftCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shift"]>


  export type ShiftSelectScalar = {
    id?: boolean
    name?: boolean
    patternId?: boolean
    shiftMode?: boolean
    ident?: boolean
    daysOn?: boolean
    daysOff?: boolean
    offsetDays?: boolean
    groundZero?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ShiftInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pattern?: boolean | ShiftPatternDefaultArgs<ExtArgs>
    porters?: boolean | Shift$portersArgs<ExtArgs>
    _count?: boolean | ShiftCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ShiftPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Shift"
    objects: {
      pattern: Prisma.$ShiftPatternPayload<ExtArgs>
      porters: Prisma.$PorterPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      patternId: string
      shiftMode: $Enums.ShiftMode
      ident: string
      daysOn: number
      daysOff: number
      offsetDays: number
      groundZero: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["shift"]>
    composites: {}
  }

  type ShiftGetPayload<S extends boolean | null | undefined | ShiftDefaultArgs> = $Result.GetResult<Prisma.$ShiftPayload, S>

  type ShiftCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ShiftFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ShiftCountAggregateInputType | true
    }

  export interface ShiftDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Shift'], meta: { name: 'Shift' } }
    /**
     * Find zero or one Shift that matches the filter.
     * @param {ShiftFindUniqueArgs} args - Arguments to find a Shift
     * @example
     * // Get one Shift
     * const shift = await prisma.shift.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShiftFindUniqueArgs>(args: SelectSubset<T, ShiftFindUniqueArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Shift that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ShiftFindUniqueOrThrowArgs} args - Arguments to find a Shift
     * @example
     * // Get one Shift
     * const shift = await prisma.shift.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShiftFindUniqueOrThrowArgs>(args: SelectSubset<T, ShiftFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Shift that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftFindFirstArgs} args - Arguments to find a Shift
     * @example
     * // Get one Shift
     * const shift = await prisma.shift.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShiftFindFirstArgs>(args?: SelectSubset<T, ShiftFindFirstArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Shift that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftFindFirstOrThrowArgs} args - Arguments to find a Shift
     * @example
     * // Get one Shift
     * const shift = await prisma.shift.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShiftFindFirstOrThrowArgs>(args?: SelectSubset<T, ShiftFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Shifts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Shifts
     * const shifts = await prisma.shift.findMany()
     * 
     * // Get first 10 Shifts
     * const shifts = await prisma.shift.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shiftWithIdOnly = await prisma.shift.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ShiftFindManyArgs>(args?: SelectSubset<T, ShiftFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Shift.
     * @param {ShiftCreateArgs} args - Arguments to create a Shift.
     * @example
     * // Create one Shift
     * const Shift = await prisma.shift.create({
     *   data: {
     *     // ... data to create a Shift
     *   }
     * })
     * 
     */
    create<T extends ShiftCreateArgs>(args: SelectSubset<T, ShiftCreateArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Shifts.
     * @param {ShiftCreateManyArgs} args - Arguments to create many Shifts.
     * @example
     * // Create many Shifts
     * const shift = await prisma.shift.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShiftCreateManyArgs>(args?: SelectSubset<T, ShiftCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Shift.
     * @param {ShiftDeleteArgs} args - Arguments to delete one Shift.
     * @example
     * // Delete one Shift
     * const Shift = await prisma.shift.delete({
     *   where: {
     *     // ... filter to delete one Shift
     *   }
     * })
     * 
     */
    delete<T extends ShiftDeleteArgs>(args: SelectSubset<T, ShiftDeleteArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Shift.
     * @param {ShiftUpdateArgs} args - Arguments to update one Shift.
     * @example
     * // Update one Shift
     * const shift = await prisma.shift.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShiftUpdateArgs>(args: SelectSubset<T, ShiftUpdateArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Shifts.
     * @param {ShiftDeleteManyArgs} args - Arguments to filter Shifts to delete.
     * @example
     * // Delete a few Shifts
     * const { count } = await prisma.shift.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShiftDeleteManyArgs>(args?: SelectSubset<T, ShiftDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Shifts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Shifts
     * const shift = await prisma.shift.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShiftUpdateManyArgs>(args: SelectSubset<T, ShiftUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Shift.
     * @param {ShiftUpsertArgs} args - Arguments to update or create a Shift.
     * @example
     * // Update or create a Shift
     * const shift = await prisma.shift.upsert({
     *   create: {
     *     // ... data to create a Shift
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Shift we want to update
     *   }
     * })
     */
    upsert<T extends ShiftUpsertArgs>(args: SelectSubset<T, ShiftUpsertArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Shifts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftCountArgs} args - Arguments to filter Shifts to count.
     * @example
     * // Count the number of Shifts
     * const count = await prisma.shift.count({
     *   where: {
     *     // ... the filter for the Shifts we want to count
     *   }
     * })
    **/
    count<T extends ShiftCountArgs>(
      args?: Subset<T, ShiftCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShiftCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Shift.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShiftAggregateArgs>(args: Subset<T, ShiftAggregateArgs>): Prisma.PrismaPromise<GetShiftAggregateType<T>>

    /**
     * Group by Shift.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShiftGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShiftGroupByArgs['orderBy'] }
        : { orderBy?: ShiftGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShiftGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShiftGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Shift model
   */
  readonly fields: ShiftFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Shift.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShiftClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pattern<T extends ShiftPatternDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ShiftPatternDefaultArgs<ExtArgs>>): Prisma__ShiftPatternClient<$Result.GetResult<Prisma.$ShiftPatternPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    porters<T extends Shift$portersArgs<ExtArgs> = {}>(args?: Subset<T, Shift$portersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PorterPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Shift model
   */ 
  interface ShiftFieldRefs {
    readonly id: FieldRef<"Shift", 'String'>
    readonly name: FieldRef<"Shift", 'String'>
    readonly patternId: FieldRef<"Shift", 'String'>
    readonly shiftMode: FieldRef<"Shift", 'ShiftMode'>
    readonly ident: FieldRef<"Shift", 'String'>
    readonly daysOn: FieldRef<"Shift", 'Int'>
    readonly daysOff: FieldRef<"Shift", 'Int'>
    readonly offsetDays: FieldRef<"Shift", 'Int'>
    readonly groundZero: FieldRef<"Shift", 'DateTime'>
    readonly createdAt: FieldRef<"Shift", 'DateTime'>
    readonly updatedAt: FieldRef<"Shift", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Shift findUnique
   */
  export type ShiftFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * Filter, which Shift to fetch.
     */
    where: ShiftWhereUniqueInput
  }

  /**
   * Shift findUniqueOrThrow
   */
  export type ShiftFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * Filter, which Shift to fetch.
     */
    where: ShiftWhereUniqueInput
  }

  /**
   * Shift findFirst
   */
  export type ShiftFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * Filter, which Shift to fetch.
     */
    where?: ShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shifts to fetch.
     */
    orderBy?: ShiftOrderByWithRelationInput | ShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shifts.
     */
    cursor?: ShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Shifts.
     */
    distinct?: ShiftScalarFieldEnum | ShiftScalarFieldEnum[]
  }

  /**
   * Shift findFirstOrThrow
   */
  export type ShiftFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * Filter, which Shift to fetch.
     */
    where?: ShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shifts to fetch.
     */
    orderBy?: ShiftOrderByWithRelationInput | ShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shifts.
     */
    cursor?: ShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Shifts.
     */
    distinct?: ShiftScalarFieldEnum | ShiftScalarFieldEnum[]
  }

  /**
   * Shift findMany
   */
  export type ShiftFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * Filter, which Shifts to fetch.
     */
    where?: ShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shifts to fetch.
     */
    orderBy?: ShiftOrderByWithRelationInput | ShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Shifts.
     */
    cursor?: ShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shifts.
     */
    skip?: number
    distinct?: ShiftScalarFieldEnum | ShiftScalarFieldEnum[]
  }

  /**
   * Shift create
   */
  export type ShiftCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * The data needed to create a Shift.
     */
    data: XOR<ShiftCreateInput, ShiftUncheckedCreateInput>
  }

  /**
   * Shift createMany
   */
  export type ShiftCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Shifts.
     */
    data: ShiftCreateManyInput | ShiftCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Shift update
   */
  export type ShiftUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * The data needed to update a Shift.
     */
    data: XOR<ShiftUpdateInput, ShiftUncheckedUpdateInput>
    /**
     * Choose, which Shift to update.
     */
    where: ShiftWhereUniqueInput
  }

  /**
   * Shift updateMany
   */
  export type ShiftUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Shifts.
     */
    data: XOR<ShiftUpdateManyMutationInput, ShiftUncheckedUpdateManyInput>
    /**
     * Filter which Shifts to update
     */
    where?: ShiftWhereInput
  }

  /**
   * Shift upsert
   */
  export type ShiftUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * The filter to search for the Shift to update in case it exists.
     */
    where: ShiftWhereUniqueInput
    /**
     * In case the Shift found by the `where` argument doesn't exist, create a new Shift with this data.
     */
    create: XOR<ShiftCreateInput, ShiftUncheckedCreateInput>
    /**
     * In case the Shift was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShiftUpdateInput, ShiftUncheckedUpdateInput>
  }

  /**
   * Shift delete
   */
  export type ShiftDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * Filter which Shift to delete.
     */
    where: ShiftWhereUniqueInput
  }

  /**
   * Shift deleteMany
   */
  export type ShiftDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Shifts to delete
     */
    where?: ShiftWhereInput
  }

  /**
   * Shift.porters
   */
  export type Shift$portersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Porter
     */
    select?: PorterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PorterInclude<ExtArgs> | null
    where?: PorterWhereInput
    orderBy?: PorterOrderByWithRelationInput | PorterOrderByWithRelationInput[]
    cursor?: PorterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PorterScalarFieldEnum | PorterScalarFieldEnum[]
  }

  /**
   * Shift without action
   */
  export type ShiftDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
  }


  /**
   * Model ShiftPattern
   */

  export type AggregateShiftPattern = {
    _count: ShiftPatternCountAggregateOutputType | null
    _min: ShiftPatternMinAggregateOutputType | null
    _max: ShiftPatternMaxAggregateOutputType | null
  }

  export type ShiftPatternMinAggregateOutputType = {
    id: string | null
    name: string | null
    patternJson: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShiftPatternMaxAggregateOutputType = {
    id: string | null
    name: string | null
    patternJson: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShiftPatternCountAggregateOutputType = {
    id: number
    name: number
    patternJson: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ShiftPatternMinAggregateInputType = {
    id?: true
    name?: true
    patternJson?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShiftPatternMaxAggregateInputType = {
    id?: true
    name?: true
    patternJson?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShiftPatternCountAggregateInputType = {
    id?: true
    name?: true
    patternJson?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ShiftPatternAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShiftPattern to aggregate.
     */
    where?: ShiftPatternWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShiftPatterns to fetch.
     */
    orderBy?: ShiftPatternOrderByWithRelationInput | ShiftPatternOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShiftPatternWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShiftPatterns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShiftPatterns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ShiftPatterns
    **/
    _count?: true | ShiftPatternCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShiftPatternMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShiftPatternMaxAggregateInputType
  }

  export type GetShiftPatternAggregateType<T extends ShiftPatternAggregateArgs> = {
        [P in keyof T & keyof AggregateShiftPattern]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShiftPattern[P]>
      : GetScalarType<T[P], AggregateShiftPattern[P]>
  }




  export type ShiftPatternGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShiftPatternWhereInput
    orderBy?: ShiftPatternOrderByWithAggregationInput | ShiftPatternOrderByWithAggregationInput[]
    by: ShiftPatternScalarFieldEnum[] | ShiftPatternScalarFieldEnum
    having?: ShiftPatternScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShiftPatternCountAggregateInputType | true
    _min?: ShiftPatternMinAggregateInputType
    _max?: ShiftPatternMaxAggregateInputType
  }

  export type ShiftPatternGroupByOutputType = {
    id: string
    name: string
    patternJson: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: ShiftPatternCountAggregateOutputType | null
    _min: ShiftPatternMinAggregateOutputType | null
    _max: ShiftPatternMaxAggregateOutputType | null
  }

  type GetShiftPatternGroupByPayload<T extends ShiftPatternGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShiftPatternGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShiftPatternGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShiftPatternGroupByOutputType[P]>
            : GetScalarType<T[P], ShiftPatternGroupByOutputType[P]>
        }
      >
    >


  export type ShiftPatternSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    patternJson?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    shifts?: boolean | ShiftPattern$shiftsArgs<ExtArgs>
    _count?: boolean | ShiftPatternCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shiftPattern"]>


  export type ShiftPatternSelectScalar = {
    id?: boolean
    name?: boolean
    patternJson?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ShiftPatternInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shifts?: boolean | ShiftPattern$shiftsArgs<ExtArgs>
    _count?: boolean | ShiftPatternCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ShiftPatternPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ShiftPattern"
    objects: {
      shifts: Prisma.$ShiftPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      patternJson: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["shiftPattern"]>
    composites: {}
  }

  type ShiftPatternGetPayload<S extends boolean | null | undefined | ShiftPatternDefaultArgs> = $Result.GetResult<Prisma.$ShiftPatternPayload, S>

  type ShiftPatternCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ShiftPatternFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ShiftPatternCountAggregateInputType | true
    }

  export interface ShiftPatternDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ShiftPattern'], meta: { name: 'ShiftPattern' } }
    /**
     * Find zero or one ShiftPattern that matches the filter.
     * @param {ShiftPatternFindUniqueArgs} args - Arguments to find a ShiftPattern
     * @example
     * // Get one ShiftPattern
     * const shiftPattern = await prisma.shiftPattern.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShiftPatternFindUniqueArgs>(args: SelectSubset<T, ShiftPatternFindUniqueArgs<ExtArgs>>): Prisma__ShiftPatternClient<$Result.GetResult<Prisma.$ShiftPatternPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ShiftPattern that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ShiftPatternFindUniqueOrThrowArgs} args - Arguments to find a ShiftPattern
     * @example
     * // Get one ShiftPattern
     * const shiftPattern = await prisma.shiftPattern.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShiftPatternFindUniqueOrThrowArgs>(args: SelectSubset<T, ShiftPatternFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShiftPatternClient<$Result.GetResult<Prisma.$ShiftPatternPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ShiftPattern that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftPatternFindFirstArgs} args - Arguments to find a ShiftPattern
     * @example
     * // Get one ShiftPattern
     * const shiftPattern = await prisma.shiftPattern.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShiftPatternFindFirstArgs>(args?: SelectSubset<T, ShiftPatternFindFirstArgs<ExtArgs>>): Prisma__ShiftPatternClient<$Result.GetResult<Prisma.$ShiftPatternPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ShiftPattern that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftPatternFindFirstOrThrowArgs} args - Arguments to find a ShiftPattern
     * @example
     * // Get one ShiftPattern
     * const shiftPattern = await prisma.shiftPattern.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShiftPatternFindFirstOrThrowArgs>(args?: SelectSubset<T, ShiftPatternFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShiftPatternClient<$Result.GetResult<Prisma.$ShiftPatternPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ShiftPatterns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftPatternFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ShiftPatterns
     * const shiftPatterns = await prisma.shiftPattern.findMany()
     * 
     * // Get first 10 ShiftPatterns
     * const shiftPatterns = await prisma.shiftPattern.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shiftPatternWithIdOnly = await prisma.shiftPattern.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ShiftPatternFindManyArgs>(args?: SelectSubset<T, ShiftPatternFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftPatternPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ShiftPattern.
     * @param {ShiftPatternCreateArgs} args - Arguments to create a ShiftPattern.
     * @example
     * // Create one ShiftPattern
     * const ShiftPattern = await prisma.shiftPattern.create({
     *   data: {
     *     // ... data to create a ShiftPattern
     *   }
     * })
     * 
     */
    create<T extends ShiftPatternCreateArgs>(args: SelectSubset<T, ShiftPatternCreateArgs<ExtArgs>>): Prisma__ShiftPatternClient<$Result.GetResult<Prisma.$ShiftPatternPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ShiftPatterns.
     * @param {ShiftPatternCreateManyArgs} args - Arguments to create many ShiftPatterns.
     * @example
     * // Create many ShiftPatterns
     * const shiftPattern = await prisma.shiftPattern.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShiftPatternCreateManyArgs>(args?: SelectSubset<T, ShiftPatternCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ShiftPattern.
     * @param {ShiftPatternDeleteArgs} args - Arguments to delete one ShiftPattern.
     * @example
     * // Delete one ShiftPattern
     * const ShiftPattern = await prisma.shiftPattern.delete({
     *   where: {
     *     // ... filter to delete one ShiftPattern
     *   }
     * })
     * 
     */
    delete<T extends ShiftPatternDeleteArgs>(args: SelectSubset<T, ShiftPatternDeleteArgs<ExtArgs>>): Prisma__ShiftPatternClient<$Result.GetResult<Prisma.$ShiftPatternPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ShiftPattern.
     * @param {ShiftPatternUpdateArgs} args - Arguments to update one ShiftPattern.
     * @example
     * // Update one ShiftPattern
     * const shiftPattern = await prisma.shiftPattern.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShiftPatternUpdateArgs>(args: SelectSubset<T, ShiftPatternUpdateArgs<ExtArgs>>): Prisma__ShiftPatternClient<$Result.GetResult<Prisma.$ShiftPatternPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ShiftPatterns.
     * @param {ShiftPatternDeleteManyArgs} args - Arguments to filter ShiftPatterns to delete.
     * @example
     * // Delete a few ShiftPatterns
     * const { count } = await prisma.shiftPattern.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShiftPatternDeleteManyArgs>(args?: SelectSubset<T, ShiftPatternDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShiftPatterns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftPatternUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ShiftPatterns
     * const shiftPattern = await prisma.shiftPattern.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShiftPatternUpdateManyArgs>(args: SelectSubset<T, ShiftPatternUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ShiftPattern.
     * @param {ShiftPatternUpsertArgs} args - Arguments to update or create a ShiftPattern.
     * @example
     * // Update or create a ShiftPattern
     * const shiftPattern = await prisma.shiftPattern.upsert({
     *   create: {
     *     // ... data to create a ShiftPattern
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ShiftPattern we want to update
     *   }
     * })
     */
    upsert<T extends ShiftPatternUpsertArgs>(args: SelectSubset<T, ShiftPatternUpsertArgs<ExtArgs>>): Prisma__ShiftPatternClient<$Result.GetResult<Prisma.$ShiftPatternPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ShiftPatterns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftPatternCountArgs} args - Arguments to filter ShiftPatterns to count.
     * @example
     * // Count the number of ShiftPatterns
     * const count = await prisma.shiftPattern.count({
     *   where: {
     *     // ... the filter for the ShiftPatterns we want to count
     *   }
     * })
    **/
    count<T extends ShiftPatternCountArgs>(
      args?: Subset<T, ShiftPatternCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShiftPatternCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ShiftPattern.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftPatternAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShiftPatternAggregateArgs>(args: Subset<T, ShiftPatternAggregateArgs>): Prisma.PrismaPromise<GetShiftPatternAggregateType<T>>

    /**
     * Group by ShiftPattern.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftPatternGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShiftPatternGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShiftPatternGroupByArgs['orderBy'] }
        : { orderBy?: ShiftPatternGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShiftPatternGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShiftPatternGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ShiftPattern model
   */
  readonly fields: ShiftPatternFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ShiftPattern.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShiftPatternClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    shifts<T extends ShiftPattern$shiftsArgs<ExtArgs> = {}>(args?: Subset<T, ShiftPattern$shiftsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ShiftPattern model
   */ 
  interface ShiftPatternFieldRefs {
    readonly id: FieldRef<"ShiftPattern", 'String'>
    readonly name: FieldRef<"ShiftPattern", 'String'>
    readonly patternJson: FieldRef<"ShiftPattern", 'String'>
    readonly description: FieldRef<"ShiftPattern", 'String'>
    readonly createdAt: FieldRef<"ShiftPattern", 'DateTime'>
    readonly updatedAt: FieldRef<"ShiftPattern", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ShiftPattern findUnique
   */
  export type ShiftPatternFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftPattern
     */
    select?: ShiftPatternSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftPatternInclude<ExtArgs> | null
    /**
     * Filter, which ShiftPattern to fetch.
     */
    where: ShiftPatternWhereUniqueInput
  }

  /**
   * ShiftPattern findUniqueOrThrow
   */
  export type ShiftPatternFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftPattern
     */
    select?: ShiftPatternSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftPatternInclude<ExtArgs> | null
    /**
     * Filter, which ShiftPattern to fetch.
     */
    where: ShiftPatternWhereUniqueInput
  }

  /**
   * ShiftPattern findFirst
   */
  export type ShiftPatternFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftPattern
     */
    select?: ShiftPatternSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftPatternInclude<ExtArgs> | null
    /**
     * Filter, which ShiftPattern to fetch.
     */
    where?: ShiftPatternWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShiftPatterns to fetch.
     */
    orderBy?: ShiftPatternOrderByWithRelationInput | ShiftPatternOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShiftPatterns.
     */
    cursor?: ShiftPatternWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShiftPatterns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShiftPatterns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShiftPatterns.
     */
    distinct?: ShiftPatternScalarFieldEnum | ShiftPatternScalarFieldEnum[]
  }

  /**
   * ShiftPattern findFirstOrThrow
   */
  export type ShiftPatternFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftPattern
     */
    select?: ShiftPatternSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftPatternInclude<ExtArgs> | null
    /**
     * Filter, which ShiftPattern to fetch.
     */
    where?: ShiftPatternWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShiftPatterns to fetch.
     */
    orderBy?: ShiftPatternOrderByWithRelationInput | ShiftPatternOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShiftPatterns.
     */
    cursor?: ShiftPatternWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShiftPatterns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShiftPatterns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShiftPatterns.
     */
    distinct?: ShiftPatternScalarFieldEnum | ShiftPatternScalarFieldEnum[]
  }

  /**
   * ShiftPattern findMany
   */
  export type ShiftPatternFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftPattern
     */
    select?: ShiftPatternSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftPatternInclude<ExtArgs> | null
    /**
     * Filter, which ShiftPatterns to fetch.
     */
    where?: ShiftPatternWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShiftPatterns to fetch.
     */
    orderBy?: ShiftPatternOrderByWithRelationInput | ShiftPatternOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ShiftPatterns.
     */
    cursor?: ShiftPatternWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShiftPatterns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShiftPatterns.
     */
    skip?: number
    distinct?: ShiftPatternScalarFieldEnum | ShiftPatternScalarFieldEnum[]
  }

  /**
   * ShiftPattern create
   */
  export type ShiftPatternCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftPattern
     */
    select?: ShiftPatternSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftPatternInclude<ExtArgs> | null
    /**
     * The data needed to create a ShiftPattern.
     */
    data: XOR<ShiftPatternCreateInput, ShiftPatternUncheckedCreateInput>
  }

  /**
   * ShiftPattern createMany
   */
  export type ShiftPatternCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ShiftPatterns.
     */
    data: ShiftPatternCreateManyInput | ShiftPatternCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ShiftPattern update
   */
  export type ShiftPatternUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftPattern
     */
    select?: ShiftPatternSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftPatternInclude<ExtArgs> | null
    /**
     * The data needed to update a ShiftPattern.
     */
    data: XOR<ShiftPatternUpdateInput, ShiftPatternUncheckedUpdateInput>
    /**
     * Choose, which ShiftPattern to update.
     */
    where: ShiftPatternWhereUniqueInput
  }

  /**
   * ShiftPattern updateMany
   */
  export type ShiftPatternUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ShiftPatterns.
     */
    data: XOR<ShiftPatternUpdateManyMutationInput, ShiftPatternUncheckedUpdateManyInput>
    /**
     * Filter which ShiftPatterns to update
     */
    where?: ShiftPatternWhereInput
  }

  /**
   * ShiftPattern upsert
   */
  export type ShiftPatternUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftPattern
     */
    select?: ShiftPatternSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftPatternInclude<ExtArgs> | null
    /**
     * The filter to search for the ShiftPattern to update in case it exists.
     */
    where: ShiftPatternWhereUniqueInput
    /**
     * In case the ShiftPattern found by the `where` argument doesn't exist, create a new ShiftPattern with this data.
     */
    create: XOR<ShiftPatternCreateInput, ShiftPatternUncheckedCreateInput>
    /**
     * In case the ShiftPattern was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShiftPatternUpdateInput, ShiftPatternUncheckedUpdateInput>
  }

  /**
   * ShiftPattern delete
   */
  export type ShiftPatternDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftPattern
     */
    select?: ShiftPatternSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftPatternInclude<ExtArgs> | null
    /**
     * Filter which ShiftPattern to delete.
     */
    where: ShiftPatternWhereUniqueInput
  }

  /**
   * ShiftPattern deleteMany
   */
  export type ShiftPatternDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShiftPatterns to delete
     */
    where?: ShiftPatternWhereInput
  }

  /**
   * ShiftPattern.shifts
   */
  export type ShiftPattern$shiftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    where?: ShiftWhereInput
    orderBy?: ShiftOrderByWithRelationInput | ShiftOrderByWithRelationInput[]
    cursor?: ShiftWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShiftScalarFieldEnum | ShiftScalarFieldEnum[]
  }

  /**
   * ShiftPattern without action
   */
  export type ShiftPatternDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftPattern
     */
    select?: ShiftPatternSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftPatternInclude<ExtArgs> | null
  }


  /**
   * Model DepartmentSchedule
   */

  export type AggregateDepartmentSchedule = {
    _count: DepartmentScheduleCountAggregateOutputType | null
    _min: DepartmentScheduleMinAggregateOutputType | null
    _max: DepartmentScheduleMaxAggregateOutputType | null
  }

  export type DepartmentScheduleMinAggregateOutputType = {
    id: string | null
    name: string | null
    patternId: string | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepartmentScheduleMaxAggregateOutputType = {
    id: string | null
    name: string | null
    patternId: string | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepartmentScheduleCountAggregateOutputType = {
    id: number
    name: number
    patternId: number
    description: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DepartmentScheduleMinAggregateInputType = {
    id?: true
    name?: true
    patternId?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepartmentScheduleMaxAggregateInputType = {
    id?: true
    name?: true
    patternId?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepartmentScheduleCountAggregateInputType = {
    id?: true
    name?: true
    patternId?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DepartmentScheduleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DepartmentSchedule to aggregate.
     */
    where?: DepartmentScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DepartmentSchedules to fetch.
     */
    orderBy?: DepartmentScheduleOrderByWithRelationInput | DepartmentScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DepartmentScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DepartmentSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DepartmentSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DepartmentSchedules
    **/
    _count?: true | DepartmentScheduleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DepartmentScheduleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DepartmentScheduleMaxAggregateInputType
  }

  export type GetDepartmentScheduleAggregateType<T extends DepartmentScheduleAggregateArgs> = {
        [P in keyof T & keyof AggregateDepartmentSchedule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDepartmentSchedule[P]>
      : GetScalarType<T[P], AggregateDepartmentSchedule[P]>
  }




  export type DepartmentScheduleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentScheduleWhereInput
    orderBy?: DepartmentScheduleOrderByWithAggregationInput | DepartmentScheduleOrderByWithAggregationInput[]
    by: DepartmentScheduleScalarFieldEnum[] | DepartmentScheduleScalarFieldEnum
    having?: DepartmentScheduleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DepartmentScheduleCountAggregateInputType | true
    _min?: DepartmentScheduleMinAggregateInputType
    _max?: DepartmentScheduleMaxAggregateInputType
  }

  export type DepartmentScheduleGroupByOutputType = {
    id: string
    name: string
    patternId: string | null
    description: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: DepartmentScheduleCountAggregateOutputType | null
    _min: DepartmentScheduleMinAggregateOutputType | null
    _max: DepartmentScheduleMaxAggregateOutputType | null
  }

  type GetDepartmentScheduleGroupByPayload<T extends DepartmentScheduleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DepartmentScheduleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DepartmentScheduleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DepartmentScheduleGroupByOutputType[P]>
            : GetScalarType<T[P], DepartmentScheduleGroupByOutputType[P]>
        }
      >
    >


  export type DepartmentScheduleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    patternId?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    departments?: boolean | DepartmentSchedule$departmentsArgs<ExtArgs>
    periods?: boolean | DepartmentSchedule$periodsArgs<ExtArgs>
    _count?: boolean | DepartmentScheduleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["departmentSchedule"]>


  export type DepartmentScheduleSelectScalar = {
    id?: boolean
    name?: boolean
    patternId?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DepartmentScheduleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    departments?: boolean | DepartmentSchedule$departmentsArgs<ExtArgs>
    periods?: boolean | DepartmentSchedule$periodsArgs<ExtArgs>
    _count?: boolean | DepartmentScheduleCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $DepartmentSchedulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DepartmentSchedule"
    objects: {
      departments: Prisma.$DepartmentPayload<ExtArgs>[]
      periods: Prisma.$DepartmentSchedulePeriodPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      patternId: string | null
      description: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["departmentSchedule"]>
    composites: {}
  }

  type DepartmentScheduleGetPayload<S extends boolean | null | undefined | DepartmentScheduleDefaultArgs> = $Result.GetResult<Prisma.$DepartmentSchedulePayload, S>

  type DepartmentScheduleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DepartmentScheduleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DepartmentScheduleCountAggregateInputType | true
    }

  export interface DepartmentScheduleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DepartmentSchedule'], meta: { name: 'DepartmentSchedule' } }
    /**
     * Find zero or one DepartmentSchedule that matches the filter.
     * @param {DepartmentScheduleFindUniqueArgs} args - Arguments to find a DepartmentSchedule
     * @example
     * // Get one DepartmentSchedule
     * const departmentSchedule = await prisma.departmentSchedule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DepartmentScheduleFindUniqueArgs>(args: SelectSubset<T, DepartmentScheduleFindUniqueArgs<ExtArgs>>): Prisma__DepartmentScheduleClient<$Result.GetResult<Prisma.$DepartmentSchedulePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DepartmentSchedule that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DepartmentScheduleFindUniqueOrThrowArgs} args - Arguments to find a DepartmentSchedule
     * @example
     * // Get one DepartmentSchedule
     * const departmentSchedule = await prisma.departmentSchedule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DepartmentScheduleFindUniqueOrThrowArgs>(args: SelectSubset<T, DepartmentScheduleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DepartmentScheduleClient<$Result.GetResult<Prisma.$DepartmentSchedulePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DepartmentSchedule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentScheduleFindFirstArgs} args - Arguments to find a DepartmentSchedule
     * @example
     * // Get one DepartmentSchedule
     * const departmentSchedule = await prisma.departmentSchedule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DepartmentScheduleFindFirstArgs>(args?: SelectSubset<T, DepartmentScheduleFindFirstArgs<ExtArgs>>): Prisma__DepartmentScheduleClient<$Result.GetResult<Prisma.$DepartmentSchedulePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DepartmentSchedule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentScheduleFindFirstOrThrowArgs} args - Arguments to find a DepartmentSchedule
     * @example
     * // Get one DepartmentSchedule
     * const departmentSchedule = await prisma.departmentSchedule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DepartmentScheduleFindFirstOrThrowArgs>(args?: SelectSubset<T, DepartmentScheduleFindFirstOrThrowArgs<ExtArgs>>): Prisma__DepartmentScheduleClient<$Result.GetResult<Prisma.$DepartmentSchedulePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DepartmentSchedules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentScheduleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DepartmentSchedules
     * const departmentSchedules = await prisma.departmentSchedule.findMany()
     * 
     * // Get first 10 DepartmentSchedules
     * const departmentSchedules = await prisma.departmentSchedule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const departmentScheduleWithIdOnly = await prisma.departmentSchedule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DepartmentScheduleFindManyArgs>(args?: SelectSubset<T, DepartmentScheduleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentSchedulePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DepartmentSchedule.
     * @param {DepartmentScheduleCreateArgs} args - Arguments to create a DepartmentSchedule.
     * @example
     * // Create one DepartmentSchedule
     * const DepartmentSchedule = await prisma.departmentSchedule.create({
     *   data: {
     *     // ... data to create a DepartmentSchedule
     *   }
     * })
     * 
     */
    create<T extends DepartmentScheduleCreateArgs>(args: SelectSubset<T, DepartmentScheduleCreateArgs<ExtArgs>>): Prisma__DepartmentScheduleClient<$Result.GetResult<Prisma.$DepartmentSchedulePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DepartmentSchedules.
     * @param {DepartmentScheduleCreateManyArgs} args - Arguments to create many DepartmentSchedules.
     * @example
     * // Create many DepartmentSchedules
     * const departmentSchedule = await prisma.departmentSchedule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DepartmentScheduleCreateManyArgs>(args?: SelectSubset<T, DepartmentScheduleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DepartmentSchedule.
     * @param {DepartmentScheduleDeleteArgs} args - Arguments to delete one DepartmentSchedule.
     * @example
     * // Delete one DepartmentSchedule
     * const DepartmentSchedule = await prisma.departmentSchedule.delete({
     *   where: {
     *     // ... filter to delete one DepartmentSchedule
     *   }
     * })
     * 
     */
    delete<T extends DepartmentScheduleDeleteArgs>(args: SelectSubset<T, DepartmentScheduleDeleteArgs<ExtArgs>>): Prisma__DepartmentScheduleClient<$Result.GetResult<Prisma.$DepartmentSchedulePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DepartmentSchedule.
     * @param {DepartmentScheduleUpdateArgs} args - Arguments to update one DepartmentSchedule.
     * @example
     * // Update one DepartmentSchedule
     * const departmentSchedule = await prisma.departmentSchedule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DepartmentScheduleUpdateArgs>(args: SelectSubset<T, DepartmentScheduleUpdateArgs<ExtArgs>>): Prisma__DepartmentScheduleClient<$Result.GetResult<Prisma.$DepartmentSchedulePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DepartmentSchedules.
     * @param {DepartmentScheduleDeleteManyArgs} args - Arguments to filter DepartmentSchedules to delete.
     * @example
     * // Delete a few DepartmentSchedules
     * const { count } = await prisma.departmentSchedule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DepartmentScheduleDeleteManyArgs>(args?: SelectSubset<T, DepartmentScheduleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DepartmentSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentScheduleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DepartmentSchedules
     * const departmentSchedule = await prisma.departmentSchedule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DepartmentScheduleUpdateManyArgs>(args: SelectSubset<T, DepartmentScheduleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DepartmentSchedule.
     * @param {DepartmentScheduleUpsertArgs} args - Arguments to update or create a DepartmentSchedule.
     * @example
     * // Update or create a DepartmentSchedule
     * const departmentSchedule = await prisma.departmentSchedule.upsert({
     *   create: {
     *     // ... data to create a DepartmentSchedule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DepartmentSchedule we want to update
     *   }
     * })
     */
    upsert<T extends DepartmentScheduleUpsertArgs>(args: SelectSubset<T, DepartmentScheduleUpsertArgs<ExtArgs>>): Prisma__DepartmentScheduleClient<$Result.GetResult<Prisma.$DepartmentSchedulePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DepartmentSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentScheduleCountArgs} args - Arguments to filter DepartmentSchedules to count.
     * @example
     * // Count the number of DepartmentSchedules
     * const count = await prisma.departmentSchedule.count({
     *   where: {
     *     // ... the filter for the DepartmentSchedules we want to count
     *   }
     * })
    **/
    count<T extends DepartmentScheduleCountArgs>(
      args?: Subset<T, DepartmentScheduleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DepartmentScheduleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DepartmentSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentScheduleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DepartmentScheduleAggregateArgs>(args: Subset<T, DepartmentScheduleAggregateArgs>): Prisma.PrismaPromise<GetDepartmentScheduleAggregateType<T>>

    /**
     * Group by DepartmentSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentScheduleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DepartmentScheduleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DepartmentScheduleGroupByArgs['orderBy'] }
        : { orderBy?: DepartmentScheduleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DepartmentScheduleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDepartmentScheduleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DepartmentSchedule model
   */
  readonly fields: DepartmentScheduleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DepartmentSchedule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DepartmentScheduleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    departments<T extends DepartmentSchedule$departmentsArgs<ExtArgs> = {}>(args?: Subset<T, DepartmentSchedule$departmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findMany"> | Null>
    periods<T extends DepartmentSchedule$periodsArgs<ExtArgs> = {}>(args?: Subset<T, DepartmentSchedule$periodsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentSchedulePeriodPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DepartmentSchedule model
   */ 
  interface DepartmentScheduleFieldRefs {
    readonly id: FieldRef<"DepartmentSchedule", 'String'>
    readonly name: FieldRef<"DepartmentSchedule", 'String'>
    readonly patternId: FieldRef<"DepartmentSchedule", 'String'>
    readonly description: FieldRef<"DepartmentSchedule", 'String'>
    readonly isActive: FieldRef<"DepartmentSchedule", 'Boolean'>
    readonly createdAt: FieldRef<"DepartmentSchedule", 'DateTime'>
    readonly updatedAt: FieldRef<"DepartmentSchedule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DepartmentSchedule findUnique
   */
  export type DepartmentScheduleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentSchedule
     */
    select?: DepartmentScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentScheduleInclude<ExtArgs> | null
    /**
     * Filter, which DepartmentSchedule to fetch.
     */
    where: DepartmentScheduleWhereUniqueInput
  }

  /**
   * DepartmentSchedule findUniqueOrThrow
   */
  export type DepartmentScheduleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentSchedule
     */
    select?: DepartmentScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentScheduleInclude<ExtArgs> | null
    /**
     * Filter, which DepartmentSchedule to fetch.
     */
    where: DepartmentScheduleWhereUniqueInput
  }

  /**
   * DepartmentSchedule findFirst
   */
  export type DepartmentScheduleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentSchedule
     */
    select?: DepartmentScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentScheduleInclude<ExtArgs> | null
    /**
     * Filter, which DepartmentSchedule to fetch.
     */
    where?: DepartmentScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DepartmentSchedules to fetch.
     */
    orderBy?: DepartmentScheduleOrderByWithRelationInput | DepartmentScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DepartmentSchedules.
     */
    cursor?: DepartmentScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DepartmentSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DepartmentSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DepartmentSchedules.
     */
    distinct?: DepartmentScheduleScalarFieldEnum | DepartmentScheduleScalarFieldEnum[]
  }

  /**
   * DepartmentSchedule findFirstOrThrow
   */
  export type DepartmentScheduleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentSchedule
     */
    select?: DepartmentScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentScheduleInclude<ExtArgs> | null
    /**
     * Filter, which DepartmentSchedule to fetch.
     */
    where?: DepartmentScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DepartmentSchedules to fetch.
     */
    orderBy?: DepartmentScheduleOrderByWithRelationInput | DepartmentScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DepartmentSchedules.
     */
    cursor?: DepartmentScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DepartmentSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DepartmentSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DepartmentSchedules.
     */
    distinct?: DepartmentScheduleScalarFieldEnum | DepartmentScheduleScalarFieldEnum[]
  }

  /**
   * DepartmentSchedule findMany
   */
  export type DepartmentScheduleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentSchedule
     */
    select?: DepartmentScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentScheduleInclude<ExtArgs> | null
    /**
     * Filter, which DepartmentSchedules to fetch.
     */
    where?: DepartmentScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DepartmentSchedules to fetch.
     */
    orderBy?: DepartmentScheduleOrderByWithRelationInput | DepartmentScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DepartmentSchedules.
     */
    cursor?: DepartmentScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DepartmentSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DepartmentSchedules.
     */
    skip?: number
    distinct?: DepartmentScheduleScalarFieldEnum | DepartmentScheduleScalarFieldEnum[]
  }

  /**
   * DepartmentSchedule create
   */
  export type DepartmentScheduleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentSchedule
     */
    select?: DepartmentScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentScheduleInclude<ExtArgs> | null
    /**
     * The data needed to create a DepartmentSchedule.
     */
    data: XOR<DepartmentScheduleCreateInput, DepartmentScheduleUncheckedCreateInput>
  }

  /**
   * DepartmentSchedule createMany
   */
  export type DepartmentScheduleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DepartmentSchedules.
     */
    data: DepartmentScheduleCreateManyInput | DepartmentScheduleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DepartmentSchedule update
   */
  export type DepartmentScheduleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentSchedule
     */
    select?: DepartmentScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentScheduleInclude<ExtArgs> | null
    /**
     * The data needed to update a DepartmentSchedule.
     */
    data: XOR<DepartmentScheduleUpdateInput, DepartmentScheduleUncheckedUpdateInput>
    /**
     * Choose, which DepartmentSchedule to update.
     */
    where: DepartmentScheduleWhereUniqueInput
  }

  /**
   * DepartmentSchedule updateMany
   */
  export type DepartmentScheduleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DepartmentSchedules.
     */
    data: XOR<DepartmentScheduleUpdateManyMutationInput, DepartmentScheduleUncheckedUpdateManyInput>
    /**
     * Filter which DepartmentSchedules to update
     */
    where?: DepartmentScheduleWhereInput
  }

  /**
   * DepartmentSchedule upsert
   */
  export type DepartmentScheduleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentSchedule
     */
    select?: DepartmentScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentScheduleInclude<ExtArgs> | null
    /**
     * The filter to search for the DepartmentSchedule to update in case it exists.
     */
    where: DepartmentScheduleWhereUniqueInput
    /**
     * In case the DepartmentSchedule found by the `where` argument doesn't exist, create a new DepartmentSchedule with this data.
     */
    create: XOR<DepartmentScheduleCreateInput, DepartmentScheduleUncheckedCreateInput>
    /**
     * In case the DepartmentSchedule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DepartmentScheduleUpdateInput, DepartmentScheduleUncheckedUpdateInput>
  }

  /**
   * DepartmentSchedule delete
   */
  export type DepartmentScheduleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentSchedule
     */
    select?: DepartmentScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentScheduleInclude<ExtArgs> | null
    /**
     * Filter which DepartmentSchedule to delete.
     */
    where: DepartmentScheduleWhereUniqueInput
  }

  /**
   * DepartmentSchedule deleteMany
   */
  export type DepartmentScheduleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DepartmentSchedules to delete
     */
    where?: DepartmentScheduleWhereInput
  }

  /**
   * DepartmentSchedule.departments
   */
  export type DepartmentSchedule$departmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    where?: DepartmentWhereInput
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    cursor?: DepartmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * DepartmentSchedule.periods
   */
  export type DepartmentSchedule$periodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentSchedulePeriod
     */
    select?: DepartmentSchedulePeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentSchedulePeriodInclude<ExtArgs> | null
    where?: DepartmentSchedulePeriodWhereInput
    orderBy?: DepartmentSchedulePeriodOrderByWithRelationInput | DepartmentSchedulePeriodOrderByWithRelationInput[]
    cursor?: DepartmentSchedulePeriodWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DepartmentSchedulePeriodScalarFieldEnum | DepartmentSchedulePeriodScalarFieldEnum[]
  }

  /**
   * DepartmentSchedule without action
   */
  export type DepartmentScheduleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentSchedule
     */
    select?: DepartmentScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentScheduleInclude<ExtArgs> | null
  }


  /**
   * Model DepartmentSchedulePeriod
   */

  export type AggregateDepartmentSchedulePeriod = {
    _count: DepartmentSchedulePeriodCountAggregateOutputType | null
    _avg: DepartmentSchedulePeriodAvgAggregateOutputType | null
    _sum: DepartmentSchedulePeriodSumAggregateOutputType | null
    _min: DepartmentSchedulePeriodMinAggregateOutputType | null
    _max: DepartmentSchedulePeriodMaxAggregateOutputType | null
  }

  export type DepartmentSchedulePeriodAvgAggregateOutputType = {
    requiredPorters: number | null
  }

  export type DepartmentSchedulePeriodSumAggregateOutputType = {
    requiredPorters: number | null
  }

  export type DepartmentSchedulePeriodMinAggregateOutputType = {
    id: string | null
    scheduleId: string | null
    dayOfWeek: $Enums.DayOfWeek | null
    openTime: string | null
    closeTime: string | null
    requiredPorters: number | null
  }

  export type DepartmentSchedulePeriodMaxAggregateOutputType = {
    id: string | null
    scheduleId: string | null
    dayOfWeek: $Enums.DayOfWeek | null
    openTime: string | null
    closeTime: string | null
    requiredPorters: number | null
  }

  export type DepartmentSchedulePeriodCountAggregateOutputType = {
    id: number
    scheduleId: number
    dayOfWeek: number
    openTime: number
    closeTime: number
    requiredPorters: number
    _all: number
  }


  export type DepartmentSchedulePeriodAvgAggregateInputType = {
    requiredPorters?: true
  }

  export type DepartmentSchedulePeriodSumAggregateInputType = {
    requiredPorters?: true
  }

  export type DepartmentSchedulePeriodMinAggregateInputType = {
    id?: true
    scheduleId?: true
    dayOfWeek?: true
    openTime?: true
    closeTime?: true
    requiredPorters?: true
  }

  export type DepartmentSchedulePeriodMaxAggregateInputType = {
    id?: true
    scheduleId?: true
    dayOfWeek?: true
    openTime?: true
    closeTime?: true
    requiredPorters?: true
  }

  export type DepartmentSchedulePeriodCountAggregateInputType = {
    id?: true
    scheduleId?: true
    dayOfWeek?: true
    openTime?: true
    closeTime?: true
    requiredPorters?: true
    _all?: true
  }

  export type DepartmentSchedulePeriodAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DepartmentSchedulePeriod to aggregate.
     */
    where?: DepartmentSchedulePeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DepartmentSchedulePeriods to fetch.
     */
    orderBy?: DepartmentSchedulePeriodOrderByWithRelationInput | DepartmentSchedulePeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DepartmentSchedulePeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DepartmentSchedulePeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DepartmentSchedulePeriods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DepartmentSchedulePeriods
    **/
    _count?: true | DepartmentSchedulePeriodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DepartmentSchedulePeriodAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DepartmentSchedulePeriodSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DepartmentSchedulePeriodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DepartmentSchedulePeriodMaxAggregateInputType
  }

  export type GetDepartmentSchedulePeriodAggregateType<T extends DepartmentSchedulePeriodAggregateArgs> = {
        [P in keyof T & keyof AggregateDepartmentSchedulePeriod]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDepartmentSchedulePeriod[P]>
      : GetScalarType<T[P], AggregateDepartmentSchedulePeriod[P]>
  }




  export type DepartmentSchedulePeriodGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentSchedulePeriodWhereInput
    orderBy?: DepartmentSchedulePeriodOrderByWithAggregationInput | DepartmentSchedulePeriodOrderByWithAggregationInput[]
    by: DepartmentSchedulePeriodScalarFieldEnum[] | DepartmentSchedulePeriodScalarFieldEnum
    having?: DepartmentSchedulePeriodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DepartmentSchedulePeriodCountAggregateInputType | true
    _avg?: DepartmentSchedulePeriodAvgAggregateInputType
    _sum?: DepartmentSchedulePeriodSumAggregateInputType
    _min?: DepartmentSchedulePeriodMinAggregateInputType
    _max?: DepartmentSchedulePeriodMaxAggregateInputType
  }

  export type DepartmentSchedulePeriodGroupByOutputType = {
    id: string
    scheduleId: string
    dayOfWeek: $Enums.DayOfWeek
    openTime: string
    closeTime: string
    requiredPorters: number
    _count: DepartmentSchedulePeriodCountAggregateOutputType | null
    _avg: DepartmentSchedulePeriodAvgAggregateOutputType | null
    _sum: DepartmentSchedulePeriodSumAggregateOutputType | null
    _min: DepartmentSchedulePeriodMinAggregateOutputType | null
    _max: DepartmentSchedulePeriodMaxAggregateOutputType | null
  }

  type GetDepartmentSchedulePeriodGroupByPayload<T extends DepartmentSchedulePeriodGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DepartmentSchedulePeriodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DepartmentSchedulePeriodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DepartmentSchedulePeriodGroupByOutputType[P]>
            : GetScalarType<T[P], DepartmentSchedulePeriodGroupByOutputType[P]>
        }
      >
    >


  export type DepartmentSchedulePeriodSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    scheduleId?: boolean
    dayOfWeek?: boolean
    openTime?: boolean
    closeTime?: boolean
    requiredPorters?: boolean
    schedule?: boolean | DepartmentScheduleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["departmentSchedulePeriod"]>


  export type DepartmentSchedulePeriodSelectScalar = {
    id?: boolean
    scheduleId?: boolean
    dayOfWeek?: boolean
    openTime?: boolean
    closeTime?: boolean
    requiredPorters?: boolean
  }

  export type DepartmentSchedulePeriodInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    schedule?: boolean | DepartmentScheduleDefaultArgs<ExtArgs>
  }

  export type $DepartmentSchedulePeriodPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DepartmentSchedulePeriod"
    objects: {
      schedule: Prisma.$DepartmentSchedulePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      scheduleId: string
      dayOfWeek: $Enums.DayOfWeek
      openTime: string
      closeTime: string
      requiredPorters: number
    }, ExtArgs["result"]["departmentSchedulePeriod"]>
    composites: {}
  }

  type DepartmentSchedulePeriodGetPayload<S extends boolean | null | undefined | DepartmentSchedulePeriodDefaultArgs> = $Result.GetResult<Prisma.$DepartmentSchedulePeriodPayload, S>

  type DepartmentSchedulePeriodCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DepartmentSchedulePeriodFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DepartmentSchedulePeriodCountAggregateInputType | true
    }

  export interface DepartmentSchedulePeriodDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DepartmentSchedulePeriod'], meta: { name: 'DepartmentSchedulePeriod' } }
    /**
     * Find zero or one DepartmentSchedulePeriod that matches the filter.
     * @param {DepartmentSchedulePeriodFindUniqueArgs} args - Arguments to find a DepartmentSchedulePeriod
     * @example
     * // Get one DepartmentSchedulePeriod
     * const departmentSchedulePeriod = await prisma.departmentSchedulePeriod.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DepartmentSchedulePeriodFindUniqueArgs>(args: SelectSubset<T, DepartmentSchedulePeriodFindUniqueArgs<ExtArgs>>): Prisma__DepartmentSchedulePeriodClient<$Result.GetResult<Prisma.$DepartmentSchedulePeriodPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DepartmentSchedulePeriod that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DepartmentSchedulePeriodFindUniqueOrThrowArgs} args - Arguments to find a DepartmentSchedulePeriod
     * @example
     * // Get one DepartmentSchedulePeriod
     * const departmentSchedulePeriod = await prisma.departmentSchedulePeriod.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DepartmentSchedulePeriodFindUniqueOrThrowArgs>(args: SelectSubset<T, DepartmentSchedulePeriodFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DepartmentSchedulePeriodClient<$Result.GetResult<Prisma.$DepartmentSchedulePeriodPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DepartmentSchedulePeriod that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentSchedulePeriodFindFirstArgs} args - Arguments to find a DepartmentSchedulePeriod
     * @example
     * // Get one DepartmentSchedulePeriod
     * const departmentSchedulePeriod = await prisma.departmentSchedulePeriod.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DepartmentSchedulePeriodFindFirstArgs>(args?: SelectSubset<T, DepartmentSchedulePeriodFindFirstArgs<ExtArgs>>): Prisma__DepartmentSchedulePeriodClient<$Result.GetResult<Prisma.$DepartmentSchedulePeriodPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DepartmentSchedulePeriod that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentSchedulePeriodFindFirstOrThrowArgs} args - Arguments to find a DepartmentSchedulePeriod
     * @example
     * // Get one DepartmentSchedulePeriod
     * const departmentSchedulePeriod = await prisma.departmentSchedulePeriod.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DepartmentSchedulePeriodFindFirstOrThrowArgs>(args?: SelectSubset<T, DepartmentSchedulePeriodFindFirstOrThrowArgs<ExtArgs>>): Prisma__DepartmentSchedulePeriodClient<$Result.GetResult<Prisma.$DepartmentSchedulePeriodPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DepartmentSchedulePeriods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentSchedulePeriodFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DepartmentSchedulePeriods
     * const departmentSchedulePeriods = await prisma.departmentSchedulePeriod.findMany()
     * 
     * // Get first 10 DepartmentSchedulePeriods
     * const departmentSchedulePeriods = await prisma.departmentSchedulePeriod.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const departmentSchedulePeriodWithIdOnly = await prisma.departmentSchedulePeriod.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DepartmentSchedulePeriodFindManyArgs>(args?: SelectSubset<T, DepartmentSchedulePeriodFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentSchedulePeriodPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DepartmentSchedulePeriod.
     * @param {DepartmentSchedulePeriodCreateArgs} args - Arguments to create a DepartmentSchedulePeriod.
     * @example
     * // Create one DepartmentSchedulePeriod
     * const DepartmentSchedulePeriod = await prisma.departmentSchedulePeriod.create({
     *   data: {
     *     // ... data to create a DepartmentSchedulePeriod
     *   }
     * })
     * 
     */
    create<T extends DepartmentSchedulePeriodCreateArgs>(args: SelectSubset<T, DepartmentSchedulePeriodCreateArgs<ExtArgs>>): Prisma__DepartmentSchedulePeriodClient<$Result.GetResult<Prisma.$DepartmentSchedulePeriodPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DepartmentSchedulePeriods.
     * @param {DepartmentSchedulePeriodCreateManyArgs} args - Arguments to create many DepartmentSchedulePeriods.
     * @example
     * // Create many DepartmentSchedulePeriods
     * const departmentSchedulePeriod = await prisma.departmentSchedulePeriod.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DepartmentSchedulePeriodCreateManyArgs>(args?: SelectSubset<T, DepartmentSchedulePeriodCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DepartmentSchedulePeriod.
     * @param {DepartmentSchedulePeriodDeleteArgs} args - Arguments to delete one DepartmentSchedulePeriod.
     * @example
     * // Delete one DepartmentSchedulePeriod
     * const DepartmentSchedulePeriod = await prisma.departmentSchedulePeriod.delete({
     *   where: {
     *     // ... filter to delete one DepartmentSchedulePeriod
     *   }
     * })
     * 
     */
    delete<T extends DepartmentSchedulePeriodDeleteArgs>(args: SelectSubset<T, DepartmentSchedulePeriodDeleteArgs<ExtArgs>>): Prisma__DepartmentSchedulePeriodClient<$Result.GetResult<Prisma.$DepartmentSchedulePeriodPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DepartmentSchedulePeriod.
     * @param {DepartmentSchedulePeriodUpdateArgs} args - Arguments to update one DepartmentSchedulePeriod.
     * @example
     * // Update one DepartmentSchedulePeriod
     * const departmentSchedulePeriod = await prisma.departmentSchedulePeriod.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DepartmentSchedulePeriodUpdateArgs>(args: SelectSubset<T, DepartmentSchedulePeriodUpdateArgs<ExtArgs>>): Prisma__DepartmentSchedulePeriodClient<$Result.GetResult<Prisma.$DepartmentSchedulePeriodPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DepartmentSchedulePeriods.
     * @param {DepartmentSchedulePeriodDeleteManyArgs} args - Arguments to filter DepartmentSchedulePeriods to delete.
     * @example
     * // Delete a few DepartmentSchedulePeriods
     * const { count } = await prisma.departmentSchedulePeriod.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DepartmentSchedulePeriodDeleteManyArgs>(args?: SelectSubset<T, DepartmentSchedulePeriodDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DepartmentSchedulePeriods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentSchedulePeriodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DepartmentSchedulePeriods
     * const departmentSchedulePeriod = await prisma.departmentSchedulePeriod.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DepartmentSchedulePeriodUpdateManyArgs>(args: SelectSubset<T, DepartmentSchedulePeriodUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DepartmentSchedulePeriod.
     * @param {DepartmentSchedulePeriodUpsertArgs} args - Arguments to update or create a DepartmentSchedulePeriod.
     * @example
     * // Update or create a DepartmentSchedulePeriod
     * const departmentSchedulePeriod = await prisma.departmentSchedulePeriod.upsert({
     *   create: {
     *     // ... data to create a DepartmentSchedulePeriod
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DepartmentSchedulePeriod we want to update
     *   }
     * })
     */
    upsert<T extends DepartmentSchedulePeriodUpsertArgs>(args: SelectSubset<T, DepartmentSchedulePeriodUpsertArgs<ExtArgs>>): Prisma__DepartmentSchedulePeriodClient<$Result.GetResult<Prisma.$DepartmentSchedulePeriodPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DepartmentSchedulePeriods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentSchedulePeriodCountArgs} args - Arguments to filter DepartmentSchedulePeriods to count.
     * @example
     * // Count the number of DepartmentSchedulePeriods
     * const count = await prisma.departmentSchedulePeriod.count({
     *   where: {
     *     // ... the filter for the DepartmentSchedulePeriods we want to count
     *   }
     * })
    **/
    count<T extends DepartmentSchedulePeriodCountArgs>(
      args?: Subset<T, DepartmentSchedulePeriodCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DepartmentSchedulePeriodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DepartmentSchedulePeriod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentSchedulePeriodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DepartmentSchedulePeriodAggregateArgs>(args: Subset<T, DepartmentSchedulePeriodAggregateArgs>): Prisma.PrismaPromise<GetDepartmentSchedulePeriodAggregateType<T>>

    /**
     * Group by DepartmentSchedulePeriod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentSchedulePeriodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DepartmentSchedulePeriodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DepartmentSchedulePeriodGroupByArgs['orderBy'] }
        : { orderBy?: DepartmentSchedulePeriodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DepartmentSchedulePeriodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDepartmentSchedulePeriodGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DepartmentSchedulePeriod model
   */
  readonly fields: DepartmentSchedulePeriodFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DepartmentSchedulePeriod.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DepartmentSchedulePeriodClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    schedule<T extends DepartmentScheduleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DepartmentScheduleDefaultArgs<ExtArgs>>): Prisma__DepartmentScheduleClient<$Result.GetResult<Prisma.$DepartmentSchedulePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DepartmentSchedulePeriod model
   */ 
  interface DepartmentSchedulePeriodFieldRefs {
    readonly id: FieldRef<"DepartmentSchedulePeriod", 'String'>
    readonly scheduleId: FieldRef<"DepartmentSchedulePeriod", 'String'>
    readonly dayOfWeek: FieldRef<"DepartmentSchedulePeriod", 'DayOfWeek'>
    readonly openTime: FieldRef<"DepartmentSchedulePeriod", 'String'>
    readonly closeTime: FieldRef<"DepartmentSchedulePeriod", 'String'>
    readonly requiredPorters: FieldRef<"DepartmentSchedulePeriod", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * DepartmentSchedulePeriod findUnique
   */
  export type DepartmentSchedulePeriodFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentSchedulePeriod
     */
    select?: DepartmentSchedulePeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentSchedulePeriodInclude<ExtArgs> | null
    /**
     * Filter, which DepartmentSchedulePeriod to fetch.
     */
    where: DepartmentSchedulePeriodWhereUniqueInput
  }

  /**
   * DepartmentSchedulePeriod findUniqueOrThrow
   */
  export type DepartmentSchedulePeriodFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentSchedulePeriod
     */
    select?: DepartmentSchedulePeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentSchedulePeriodInclude<ExtArgs> | null
    /**
     * Filter, which DepartmentSchedulePeriod to fetch.
     */
    where: DepartmentSchedulePeriodWhereUniqueInput
  }

  /**
   * DepartmentSchedulePeriod findFirst
   */
  export type DepartmentSchedulePeriodFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentSchedulePeriod
     */
    select?: DepartmentSchedulePeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentSchedulePeriodInclude<ExtArgs> | null
    /**
     * Filter, which DepartmentSchedulePeriod to fetch.
     */
    where?: DepartmentSchedulePeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DepartmentSchedulePeriods to fetch.
     */
    orderBy?: DepartmentSchedulePeriodOrderByWithRelationInput | DepartmentSchedulePeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DepartmentSchedulePeriods.
     */
    cursor?: DepartmentSchedulePeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DepartmentSchedulePeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DepartmentSchedulePeriods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DepartmentSchedulePeriods.
     */
    distinct?: DepartmentSchedulePeriodScalarFieldEnum | DepartmentSchedulePeriodScalarFieldEnum[]
  }

  /**
   * DepartmentSchedulePeriod findFirstOrThrow
   */
  export type DepartmentSchedulePeriodFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentSchedulePeriod
     */
    select?: DepartmentSchedulePeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentSchedulePeriodInclude<ExtArgs> | null
    /**
     * Filter, which DepartmentSchedulePeriod to fetch.
     */
    where?: DepartmentSchedulePeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DepartmentSchedulePeriods to fetch.
     */
    orderBy?: DepartmentSchedulePeriodOrderByWithRelationInput | DepartmentSchedulePeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DepartmentSchedulePeriods.
     */
    cursor?: DepartmentSchedulePeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DepartmentSchedulePeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DepartmentSchedulePeriods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DepartmentSchedulePeriods.
     */
    distinct?: DepartmentSchedulePeriodScalarFieldEnum | DepartmentSchedulePeriodScalarFieldEnum[]
  }

  /**
   * DepartmentSchedulePeriod findMany
   */
  export type DepartmentSchedulePeriodFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentSchedulePeriod
     */
    select?: DepartmentSchedulePeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentSchedulePeriodInclude<ExtArgs> | null
    /**
     * Filter, which DepartmentSchedulePeriods to fetch.
     */
    where?: DepartmentSchedulePeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DepartmentSchedulePeriods to fetch.
     */
    orderBy?: DepartmentSchedulePeriodOrderByWithRelationInput | DepartmentSchedulePeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DepartmentSchedulePeriods.
     */
    cursor?: DepartmentSchedulePeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DepartmentSchedulePeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DepartmentSchedulePeriods.
     */
    skip?: number
    distinct?: DepartmentSchedulePeriodScalarFieldEnum | DepartmentSchedulePeriodScalarFieldEnum[]
  }

  /**
   * DepartmentSchedulePeriod create
   */
  export type DepartmentSchedulePeriodCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentSchedulePeriod
     */
    select?: DepartmentSchedulePeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentSchedulePeriodInclude<ExtArgs> | null
    /**
     * The data needed to create a DepartmentSchedulePeriod.
     */
    data: XOR<DepartmentSchedulePeriodCreateInput, DepartmentSchedulePeriodUncheckedCreateInput>
  }

  /**
   * DepartmentSchedulePeriod createMany
   */
  export type DepartmentSchedulePeriodCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DepartmentSchedulePeriods.
     */
    data: DepartmentSchedulePeriodCreateManyInput | DepartmentSchedulePeriodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DepartmentSchedulePeriod update
   */
  export type DepartmentSchedulePeriodUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentSchedulePeriod
     */
    select?: DepartmentSchedulePeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentSchedulePeriodInclude<ExtArgs> | null
    /**
     * The data needed to update a DepartmentSchedulePeriod.
     */
    data: XOR<DepartmentSchedulePeriodUpdateInput, DepartmentSchedulePeriodUncheckedUpdateInput>
    /**
     * Choose, which DepartmentSchedulePeriod to update.
     */
    where: DepartmentSchedulePeriodWhereUniqueInput
  }

  /**
   * DepartmentSchedulePeriod updateMany
   */
  export type DepartmentSchedulePeriodUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DepartmentSchedulePeriods.
     */
    data: XOR<DepartmentSchedulePeriodUpdateManyMutationInput, DepartmentSchedulePeriodUncheckedUpdateManyInput>
    /**
     * Filter which DepartmentSchedulePeriods to update
     */
    where?: DepartmentSchedulePeriodWhereInput
  }

  /**
   * DepartmentSchedulePeriod upsert
   */
  export type DepartmentSchedulePeriodUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentSchedulePeriod
     */
    select?: DepartmentSchedulePeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentSchedulePeriodInclude<ExtArgs> | null
    /**
     * The filter to search for the DepartmentSchedulePeriod to update in case it exists.
     */
    where: DepartmentSchedulePeriodWhereUniqueInput
    /**
     * In case the DepartmentSchedulePeriod found by the `where` argument doesn't exist, create a new DepartmentSchedulePeriod with this data.
     */
    create: XOR<DepartmentSchedulePeriodCreateInput, DepartmentSchedulePeriodUncheckedCreateInput>
    /**
     * In case the DepartmentSchedulePeriod was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DepartmentSchedulePeriodUpdateInput, DepartmentSchedulePeriodUncheckedUpdateInput>
  }

  /**
   * DepartmentSchedulePeriod delete
   */
  export type DepartmentSchedulePeriodDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentSchedulePeriod
     */
    select?: DepartmentSchedulePeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentSchedulePeriodInclude<ExtArgs> | null
    /**
     * Filter which DepartmentSchedulePeriod to delete.
     */
    where: DepartmentSchedulePeriodWhereUniqueInput
  }

  /**
   * DepartmentSchedulePeriod deleteMany
   */
  export type DepartmentSchedulePeriodDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DepartmentSchedulePeriods to delete
     */
    where?: DepartmentSchedulePeriodWhereInput
  }

  /**
   * DepartmentSchedulePeriod without action
   */
  export type DepartmentSchedulePeriodDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentSchedulePeriod
     */
    select?: DepartmentSchedulePeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentSchedulePeriodInclude<ExtArgs> | null
  }


  /**
   * Model Capability
   */

  export type AggregateCapability = {
    _count: CapabilityCountAggregateOutputType | null
    _min: CapabilityMinAggregateOutputType | null
    _max: CapabilityMaxAggregateOutputType | null
  }

  export type CapabilityMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CapabilityMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CapabilityCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CapabilityMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CapabilityMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CapabilityCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CapabilityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Capability to aggregate.
     */
    where?: CapabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Capabilities to fetch.
     */
    orderBy?: CapabilityOrderByWithRelationInput | CapabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CapabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Capabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Capabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Capabilities
    **/
    _count?: true | CapabilityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CapabilityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CapabilityMaxAggregateInputType
  }

  export type GetCapabilityAggregateType<T extends CapabilityAggregateArgs> = {
        [P in keyof T & keyof AggregateCapability]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCapability[P]>
      : GetScalarType<T[P], AggregateCapability[P]>
  }




  export type CapabilityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CapabilityWhereInput
    orderBy?: CapabilityOrderByWithAggregationInput | CapabilityOrderByWithAggregationInput[]
    by: CapabilityScalarFieldEnum[] | CapabilityScalarFieldEnum
    having?: CapabilityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CapabilityCountAggregateInputType | true
    _min?: CapabilityMinAggregateInputType
    _max?: CapabilityMaxAggregateInputType
  }

  export type CapabilityGroupByOutputType = {
    id: string
    name: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: CapabilityCountAggregateOutputType | null
    _min: CapabilityMinAggregateOutputType | null
    _max: CapabilityMaxAggregateOutputType | null
  }

  type GetCapabilityGroupByPayload<T extends CapabilityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CapabilityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CapabilityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CapabilityGroupByOutputType[P]>
            : GetScalarType<T[P], CapabilityGroupByOutputType[P]>
        }
      >
    >


  export type CapabilitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    porterCapabilities?: boolean | Capability$porterCapabilitiesArgs<ExtArgs>
    departmentCapabilities?: boolean | Capability$departmentCapabilitiesArgs<ExtArgs>
    serviceCapabilities?: boolean | Capability$serviceCapabilitiesArgs<ExtArgs>
    _count?: boolean | CapabilityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["capability"]>


  export type CapabilitySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CapabilityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    porterCapabilities?: boolean | Capability$porterCapabilitiesArgs<ExtArgs>
    departmentCapabilities?: boolean | Capability$departmentCapabilitiesArgs<ExtArgs>
    serviceCapabilities?: boolean | Capability$serviceCapabilitiesArgs<ExtArgs>
    _count?: boolean | CapabilityCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CapabilityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Capability"
    objects: {
      porterCapabilities: Prisma.$PorterCapabilityPayload<ExtArgs>[]
      departmentCapabilities: Prisma.$DepartmentCapabilityPayload<ExtArgs>[]
      serviceCapabilities: Prisma.$ServiceCapabilityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["capability"]>
    composites: {}
  }

  type CapabilityGetPayload<S extends boolean | null | undefined | CapabilityDefaultArgs> = $Result.GetResult<Prisma.$CapabilityPayload, S>

  type CapabilityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CapabilityFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CapabilityCountAggregateInputType | true
    }

  export interface CapabilityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Capability'], meta: { name: 'Capability' } }
    /**
     * Find zero or one Capability that matches the filter.
     * @param {CapabilityFindUniqueArgs} args - Arguments to find a Capability
     * @example
     * // Get one Capability
     * const capability = await prisma.capability.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CapabilityFindUniqueArgs>(args: SelectSubset<T, CapabilityFindUniqueArgs<ExtArgs>>): Prisma__CapabilityClient<$Result.GetResult<Prisma.$CapabilityPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Capability that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CapabilityFindUniqueOrThrowArgs} args - Arguments to find a Capability
     * @example
     * // Get one Capability
     * const capability = await prisma.capability.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CapabilityFindUniqueOrThrowArgs>(args: SelectSubset<T, CapabilityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CapabilityClient<$Result.GetResult<Prisma.$CapabilityPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Capability that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CapabilityFindFirstArgs} args - Arguments to find a Capability
     * @example
     * // Get one Capability
     * const capability = await prisma.capability.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CapabilityFindFirstArgs>(args?: SelectSubset<T, CapabilityFindFirstArgs<ExtArgs>>): Prisma__CapabilityClient<$Result.GetResult<Prisma.$CapabilityPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Capability that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CapabilityFindFirstOrThrowArgs} args - Arguments to find a Capability
     * @example
     * // Get one Capability
     * const capability = await prisma.capability.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CapabilityFindFirstOrThrowArgs>(args?: SelectSubset<T, CapabilityFindFirstOrThrowArgs<ExtArgs>>): Prisma__CapabilityClient<$Result.GetResult<Prisma.$CapabilityPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Capabilities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CapabilityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Capabilities
     * const capabilities = await prisma.capability.findMany()
     * 
     * // Get first 10 Capabilities
     * const capabilities = await prisma.capability.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const capabilityWithIdOnly = await prisma.capability.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CapabilityFindManyArgs>(args?: SelectSubset<T, CapabilityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CapabilityPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Capability.
     * @param {CapabilityCreateArgs} args - Arguments to create a Capability.
     * @example
     * // Create one Capability
     * const Capability = await prisma.capability.create({
     *   data: {
     *     // ... data to create a Capability
     *   }
     * })
     * 
     */
    create<T extends CapabilityCreateArgs>(args: SelectSubset<T, CapabilityCreateArgs<ExtArgs>>): Prisma__CapabilityClient<$Result.GetResult<Prisma.$CapabilityPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Capabilities.
     * @param {CapabilityCreateManyArgs} args - Arguments to create many Capabilities.
     * @example
     * // Create many Capabilities
     * const capability = await prisma.capability.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CapabilityCreateManyArgs>(args?: SelectSubset<T, CapabilityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Capability.
     * @param {CapabilityDeleteArgs} args - Arguments to delete one Capability.
     * @example
     * // Delete one Capability
     * const Capability = await prisma.capability.delete({
     *   where: {
     *     // ... filter to delete one Capability
     *   }
     * })
     * 
     */
    delete<T extends CapabilityDeleteArgs>(args: SelectSubset<T, CapabilityDeleteArgs<ExtArgs>>): Prisma__CapabilityClient<$Result.GetResult<Prisma.$CapabilityPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Capability.
     * @param {CapabilityUpdateArgs} args - Arguments to update one Capability.
     * @example
     * // Update one Capability
     * const capability = await prisma.capability.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CapabilityUpdateArgs>(args: SelectSubset<T, CapabilityUpdateArgs<ExtArgs>>): Prisma__CapabilityClient<$Result.GetResult<Prisma.$CapabilityPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Capabilities.
     * @param {CapabilityDeleteManyArgs} args - Arguments to filter Capabilities to delete.
     * @example
     * // Delete a few Capabilities
     * const { count } = await prisma.capability.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CapabilityDeleteManyArgs>(args?: SelectSubset<T, CapabilityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Capabilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CapabilityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Capabilities
     * const capability = await prisma.capability.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CapabilityUpdateManyArgs>(args: SelectSubset<T, CapabilityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Capability.
     * @param {CapabilityUpsertArgs} args - Arguments to update or create a Capability.
     * @example
     * // Update or create a Capability
     * const capability = await prisma.capability.upsert({
     *   create: {
     *     // ... data to create a Capability
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Capability we want to update
     *   }
     * })
     */
    upsert<T extends CapabilityUpsertArgs>(args: SelectSubset<T, CapabilityUpsertArgs<ExtArgs>>): Prisma__CapabilityClient<$Result.GetResult<Prisma.$CapabilityPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Capabilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CapabilityCountArgs} args - Arguments to filter Capabilities to count.
     * @example
     * // Count the number of Capabilities
     * const count = await prisma.capability.count({
     *   where: {
     *     // ... the filter for the Capabilities we want to count
     *   }
     * })
    **/
    count<T extends CapabilityCountArgs>(
      args?: Subset<T, CapabilityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CapabilityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Capability.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CapabilityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CapabilityAggregateArgs>(args: Subset<T, CapabilityAggregateArgs>): Prisma.PrismaPromise<GetCapabilityAggregateType<T>>

    /**
     * Group by Capability.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CapabilityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CapabilityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CapabilityGroupByArgs['orderBy'] }
        : { orderBy?: CapabilityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CapabilityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCapabilityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Capability model
   */
  readonly fields: CapabilityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Capability.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CapabilityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    porterCapabilities<T extends Capability$porterCapabilitiesArgs<ExtArgs> = {}>(args?: Subset<T, Capability$porterCapabilitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PorterCapabilityPayload<ExtArgs>, T, "findMany"> | Null>
    departmentCapabilities<T extends Capability$departmentCapabilitiesArgs<ExtArgs> = {}>(args?: Subset<T, Capability$departmentCapabilitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentCapabilityPayload<ExtArgs>, T, "findMany"> | Null>
    serviceCapabilities<T extends Capability$serviceCapabilitiesArgs<ExtArgs> = {}>(args?: Subset<T, Capability$serviceCapabilitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceCapabilityPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Capability model
   */ 
  interface CapabilityFieldRefs {
    readonly id: FieldRef<"Capability", 'String'>
    readonly name: FieldRef<"Capability", 'String'>
    readonly description: FieldRef<"Capability", 'String'>
    readonly createdAt: FieldRef<"Capability", 'DateTime'>
    readonly updatedAt: FieldRef<"Capability", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Capability findUnique
   */
  export type CapabilityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Capability
     */
    select?: CapabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CapabilityInclude<ExtArgs> | null
    /**
     * Filter, which Capability to fetch.
     */
    where: CapabilityWhereUniqueInput
  }

  /**
   * Capability findUniqueOrThrow
   */
  export type CapabilityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Capability
     */
    select?: CapabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CapabilityInclude<ExtArgs> | null
    /**
     * Filter, which Capability to fetch.
     */
    where: CapabilityWhereUniqueInput
  }

  /**
   * Capability findFirst
   */
  export type CapabilityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Capability
     */
    select?: CapabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CapabilityInclude<ExtArgs> | null
    /**
     * Filter, which Capability to fetch.
     */
    where?: CapabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Capabilities to fetch.
     */
    orderBy?: CapabilityOrderByWithRelationInput | CapabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Capabilities.
     */
    cursor?: CapabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Capabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Capabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Capabilities.
     */
    distinct?: CapabilityScalarFieldEnum | CapabilityScalarFieldEnum[]
  }

  /**
   * Capability findFirstOrThrow
   */
  export type CapabilityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Capability
     */
    select?: CapabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CapabilityInclude<ExtArgs> | null
    /**
     * Filter, which Capability to fetch.
     */
    where?: CapabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Capabilities to fetch.
     */
    orderBy?: CapabilityOrderByWithRelationInput | CapabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Capabilities.
     */
    cursor?: CapabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Capabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Capabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Capabilities.
     */
    distinct?: CapabilityScalarFieldEnum | CapabilityScalarFieldEnum[]
  }

  /**
   * Capability findMany
   */
  export type CapabilityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Capability
     */
    select?: CapabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CapabilityInclude<ExtArgs> | null
    /**
     * Filter, which Capabilities to fetch.
     */
    where?: CapabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Capabilities to fetch.
     */
    orderBy?: CapabilityOrderByWithRelationInput | CapabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Capabilities.
     */
    cursor?: CapabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Capabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Capabilities.
     */
    skip?: number
    distinct?: CapabilityScalarFieldEnum | CapabilityScalarFieldEnum[]
  }

  /**
   * Capability create
   */
  export type CapabilityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Capability
     */
    select?: CapabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CapabilityInclude<ExtArgs> | null
    /**
     * The data needed to create a Capability.
     */
    data: XOR<CapabilityCreateInput, CapabilityUncheckedCreateInput>
  }

  /**
   * Capability createMany
   */
  export type CapabilityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Capabilities.
     */
    data: CapabilityCreateManyInput | CapabilityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Capability update
   */
  export type CapabilityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Capability
     */
    select?: CapabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CapabilityInclude<ExtArgs> | null
    /**
     * The data needed to update a Capability.
     */
    data: XOR<CapabilityUpdateInput, CapabilityUncheckedUpdateInput>
    /**
     * Choose, which Capability to update.
     */
    where: CapabilityWhereUniqueInput
  }

  /**
   * Capability updateMany
   */
  export type CapabilityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Capabilities.
     */
    data: XOR<CapabilityUpdateManyMutationInput, CapabilityUncheckedUpdateManyInput>
    /**
     * Filter which Capabilities to update
     */
    where?: CapabilityWhereInput
  }

  /**
   * Capability upsert
   */
  export type CapabilityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Capability
     */
    select?: CapabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CapabilityInclude<ExtArgs> | null
    /**
     * The filter to search for the Capability to update in case it exists.
     */
    where: CapabilityWhereUniqueInput
    /**
     * In case the Capability found by the `where` argument doesn't exist, create a new Capability with this data.
     */
    create: XOR<CapabilityCreateInput, CapabilityUncheckedCreateInput>
    /**
     * In case the Capability was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CapabilityUpdateInput, CapabilityUncheckedUpdateInput>
  }

  /**
   * Capability delete
   */
  export type CapabilityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Capability
     */
    select?: CapabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CapabilityInclude<ExtArgs> | null
    /**
     * Filter which Capability to delete.
     */
    where: CapabilityWhereUniqueInput
  }

  /**
   * Capability deleteMany
   */
  export type CapabilityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Capabilities to delete
     */
    where?: CapabilityWhereInput
  }

  /**
   * Capability.porterCapabilities
   */
  export type Capability$porterCapabilitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PorterCapability
     */
    select?: PorterCapabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PorterCapabilityInclude<ExtArgs> | null
    where?: PorterCapabilityWhereInput
    orderBy?: PorterCapabilityOrderByWithRelationInput | PorterCapabilityOrderByWithRelationInput[]
    cursor?: PorterCapabilityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PorterCapabilityScalarFieldEnum | PorterCapabilityScalarFieldEnum[]
  }

  /**
   * Capability.departmentCapabilities
   */
  export type Capability$departmentCapabilitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentCapability
     */
    select?: DepartmentCapabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentCapabilityInclude<ExtArgs> | null
    where?: DepartmentCapabilityWhereInput
    orderBy?: DepartmentCapabilityOrderByWithRelationInput | DepartmentCapabilityOrderByWithRelationInput[]
    cursor?: DepartmentCapabilityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DepartmentCapabilityScalarFieldEnum | DepartmentCapabilityScalarFieldEnum[]
  }

  /**
   * Capability.serviceCapabilities
   */
  export type Capability$serviceCapabilitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCapability
     */
    select?: ServiceCapabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCapabilityInclude<ExtArgs> | null
    where?: ServiceCapabilityWhereInput
    orderBy?: ServiceCapabilityOrderByWithRelationInput | ServiceCapabilityOrderByWithRelationInput[]
    cursor?: ServiceCapabilityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceCapabilityScalarFieldEnum | ServiceCapabilityScalarFieldEnum[]
  }

  /**
   * Capability without action
   */
  export type CapabilityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Capability
     */
    select?: CapabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CapabilityInclude<ExtArgs> | null
  }


  /**
   * Model PorterCapability
   */

  export type AggregatePorterCapability = {
    _count: PorterCapabilityCountAggregateOutputType | null
    _min: PorterCapabilityMinAggregateOutputType | null
    _max: PorterCapabilityMaxAggregateOutputType | null
  }

  export type PorterCapabilityMinAggregateOutputType = {
    porterId: string | null
    capabilityId: string | null
    expiryDate: Date | null
    createdAt: Date | null
  }

  export type PorterCapabilityMaxAggregateOutputType = {
    porterId: string | null
    capabilityId: string | null
    expiryDate: Date | null
    createdAt: Date | null
  }

  export type PorterCapabilityCountAggregateOutputType = {
    porterId: number
    capabilityId: number
    expiryDate: number
    createdAt: number
    _all: number
  }


  export type PorterCapabilityMinAggregateInputType = {
    porterId?: true
    capabilityId?: true
    expiryDate?: true
    createdAt?: true
  }

  export type PorterCapabilityMaxAggregateInputType = {
    porterId?: true
    capabilityId?: true
    expiryDate?: true
    createdAt?: true
  }

  export type PorterCapabilityCountAggregateInputType = {
    porterId?: true
    capabilityId?: true
    expiryDate?: true
    createdAt?: true
    _all?: true
  }

  export type PorterCapabilityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PorterCapability to aggregate.
     */
    where?: PorterCapabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PorterCapabilities to fetch.
     */
    orderBy?: PorterCapabilityOrderByWithRelationInput | PorterCapabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PorterCapabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PorterCapabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PorterCapabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PorterCapabilities
    **/
    _count?: true | PorterCapabilityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PorterCapabilityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PorterCapabilityMaxAggregateInputType
  }

  export type GetPorterCapabilityAggregateType<T extends PorterCapabilityAggregateArgs> = {
        [P in keyof T & keyof AggregatePorterCapability]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePorterCapability[P]>
      : GetScalarType<T[P], AggregatePorterCapability[P]>
  }




  export type PorterCapabilityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PorterCapabilityWhereInput
    orderBy?: PorterCapabilityOrderByWithAggregationInput | PorterCapabilityOrderByWithAggregationInput[]
    by: PorterCapabilityScalarFieldEnum[] | PorterCapabilityScalarFieldEnum
    having?: PorterCapabilityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PorterCapabilityCountAggregateInputType | true
    _min?: PorterCapabilityMinAggregateInputType
    _max?: PorterCapabilityMaxAggregateInputType
  }

  export type PorterCapabilityGroupByOutputType = {
    porterId: string
    capabilityId: string
    expiryDate: Date | null
    createdAt: Date
    _count: PorterCapabilityCountAggregateOutputType | null
    _min: PorterCapabilityMinAggregateOutputType | null
    _max: PorterCapabilityMaxAggregateOutputType | null
  }

  type GetPorterCapabilityGroupByPayload<T extends PorterCapabilityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PorterCapabilityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PorterCapabilityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PorterCapabilityGroupByOutputType[P]>
            : GetScalarType<T[P], PorterCapabilityGroupByOutputType[P]>
        }
      >
    >


  export type PorterCapabilitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    porterId?: boolean
    capabilityId?: boolean
    expiryDate?: boolean
    createdAt?: boolean
    porter?: boolean | PorterDefaultArgs<ExtArgs>
    capability?: boolean | CapabilityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["porterCapability"]>


  export type PorterCapabilitySelectScalar = {
    porterId?: boolean
    capabilityId?: boolean
    expiryDate?: boolean
    createdAt?: boolean
  }

  export type PorterCapabilityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    porter?: boolean | PorterDefaultArgs<ExtArgs>
    capability?: boolean | CapabilityDefaultArgs<ExtArgs>
  }

  export type $PorterCapabilityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PorterCapability"
    objects: {
      porter: Prisma.$PorterPayload<ExtArgs>
      capability: Prisma.$CapabilityPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      porterId: string
      capabilityId: string
      expiryDate: Date | null
      createdAt: Date
    }, ExtArgs["result"]["porterCapability"]>
    composites: {}
  }

  type PorterCapabilityGetPayload<S extends boolean | null | undefined | PorterCapabilityDefaultArgs> = $Result.GetResult<Prisma.$PorterCapabilityPayload, S>

  type PorterCapabilityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PorterCapabilityFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PorterCapabilityCountAggregateInputType | true
    }

  export interface PorterCapabilityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PorterCapability'], meta: { name: 'PorterCapability' } }
    /**
     * Find zero or one PorterCapability that matches the filter.
     * @param {PorterCapabilityFindUniqueArgs} args - Arguments to find a PorterCapability
     * @example
     * // Get one PorterCapability
     * const porterCapability = await prisma.porterCapability.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PorterCapabilityFindUniqueArgs>(args: SelectSubset<T, PorterCapabilityFindUniqueArgs<ExtArgs>>): Prisma__PorterCapabilityClient<$Result.GetResult<Prisma.$PorterCapabilityPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PorterCapability that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PorterCapabilityFindUniqueOrThrowArgs} args - Arguments to find a PorterCapability
     * @example
     * // Get one PorterCapability
     * const porterCapability = await prisma.porterCapability.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PorterCapabilityFindUniqueOrThrowArgs>(args: SelectSubset<T, PorterCapabilityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PorterCapabilityClient<$Result.GetResult<Prisma.$PorterCapabilityPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PorterCapability that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PorterCapabilityFindFirstArgs} args - Arguments to find a PorterCapability
     * @example
     * // Get one PorterCapability
     * const porterCapability = await prisma.porterCapability.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PorterCapabilityFindFirstArgs>(args?: SelectSubset<T, PorterCapabilityFindFirstArgs<ExtArgs>>): Prisma__PorterCapabilityClient<$Result.GetResult<Prisma.$PorterCapabilityPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PorterCapability that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PorterCapabilityFindFirstOrThrowArgs} args - Arguments to find a PorterCapability
     * @example
     * // Get one PorterCapability
     * const porterCapability = await prisma.porterCapability.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PorterCapabilityFindFirstOrThrowArgs>(args?: SelectSubset<T, PorterCapabilityFindFirstOrThrowArgs<ExtArgs>>): Prisma__PorterCapabilityClient<$Result.GetResult<Prisma.$PorterCapabilityPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PorterCapabilities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PorterCapabilityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PorterCapabilities
     * const porterCapabilities = await prisma.porterCapability.findMany()
     * 
     * // Get first 10 PorterCapabilities
     * const porterCapabilities = await prisma.porterCapability.findMany({ take: 10 })
     * 
     * // Only select the `porterId`
     * const porterCapabilityWithPorterIdOnly = await prisma.porterCapability.findMany({ select: { porterId: true } })
     * 
     */
    findMany<T extends PorterCapabilityFindManyArgs>(args?: SelectSubset<T, PorterCapabilityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PorterCapabilityPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PorterCapability.
     * @param {PorterCapabilityCreateArgs} args - Arguments to create a PorterCapability.
     * @example
     * // Create one PorterCapability
     * const PorterCapability = await prisma.porterCapability.create({
     *   data: {
     *     // ... data to create a PorterCapability
     *   }
     * })
     * 
     */
    create<T extends PorterCapabilityCreateArgs>(args: SelectSubset<T, PorterCapabilityCreateArgs<ExtArgs>>): Prisma__PorterCapabilityClient<$Result.GetResult<Prisma.$PorterCapabilityPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PorterCapabilities.
     * @param {PorterCapabilityCreateManyArgs} args - Arguments to create many PorterCapabilities.
     * @example
     * // Create many PorterCapabilities
     * const porterCapability = await prisma.porterCapability.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PorterCapabilityCreateManyArgs>(args?: SelectSubset<T, PorterCapabilityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PorterCapability.
     * @param {PorterCapabilityDeleteArgs} args - Arguments to delete one PorterCapability.
     * @example
     * // Delete one PorterCapability
     * const PorterCapability = await prisma.porterCapability.delete({
     *   where: {
     *     // ... filter to delete one PorterCapability
     *   }
     * })
     * 
     */
    delete<T extends PorterCapabilityDeleteArgs>(args: SelectSubset<T, PorterCapabilityDeleteArgs<ExtArgs>>): Prisma__PorterCapabilityClient<$Result.GetResult<Prisma.$PorterCapabilityPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PorterCapability.
     * @param {PorterCapabilityUpdateArgs} args - Arguments to update one PorterCapability.
     * @example
     * // Update one PorterCapability
     * const porterCapability = await prisma.porterCapability.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PorterCapabilityUpdateArgs>(args: SelectSubset<T, PorterCapabilityUpdateArgs<ExtArgs>>): Prisma__PorterCapabilityClient<$Result.GetResult<Prisma.$PorterCapabilityPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PorterCapabilities.
     * @param {PorterCapabilityDeleteManyArgs} args - Arguments to filter PorterCapabilities to delete.
     * @example
     * // Delete a few PorterCapabilities
     * const { count } = await prisma.porterCapability.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PorterCapabilityDeleteManyArgs>(args?: SelectSubset<T, PorterCapabilityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PorterCapabilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PorterCapabilityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PorterCapabilities
     * const porterCapability = await prisma.porterCapability.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PorterCapabilityUpdateManyArgs>(args: SelectSubset<T, PorterCapabilityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PorterCapability.
     * @param {PorterCapabilityUpsertArgs} args - Arguments to update or create a PorterCapability.
     * @example
     * // Update or create a PorterCapability
     * const porterCapability = await prisma.porterCapability.upsert({
     *   create: {
     *     // ... data to create a PorterCapability
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PorterCapability we want to update
     *   }
     * })
     */
    upsert<T extends PorterCapabilityUpsertArgs>(args: SelectSubset<T, PorterCapabilityUpsertArgs<ExtArgs>>): Prisma__PorterCapabilityClient<$Result.GetResult<Prisma.$PorterCapabilityPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PorterCapabilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PorterCapabilityCountArgs} args - Arguments to filter PorterCapabilities to count.
     * @example
     * // Count the number of PorterCapabilities
     * const count = await prisma.porterCapability.count({
     *   where: {
     *     // ... the filter for the PorterCapabilities we want to count
     *   }
     * })
    **/
    count<T extends PorterCapabilityCountArgs>(
      args?: Subset<T, PorterCapabilityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PorterCapabilityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PorterCapability.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PorterCapabilityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PorterCapabilityAggregateArgs>(args: Subset<T, PorterCapabilityAggregateArgs>): Prisma.PrismaPromise<GetPorterCapabilityAggregateType<T>>

    /**
     * Group by PorterCapability.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PorterCapabilityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PorterCapabilityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PorterCapabilityGroupByArgs['orderBy'] }
        : { orderBy?: PorterCapabilityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PorterCapabilityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPorterCapabilityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PorterCapability model
   */
  readonly fields: PorterCapabilityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PorterCapability.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PorterCapabilityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    porter<T extends PorterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PorterDefaultArgs<ExtArgs>>): Prisma__PorterClient<$Result.GetResult<Prisma.$PorterPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    capability<T extends CapabilityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CapabilityDefaultArgs<ExtArgs>>): Prisma__CapabilityClient<$Result.GetResult<Prisma.$CapabilityPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PorterCapability model
   */ 
  interface PorterCapabilityFieldRefs {
    readonly porterId: FieldRef<"PorterCapability", 'String'>
    readonly capabilityId: FieldRef<"PorterCapability", 'String'>
    readonly expiryDate: FieldRef<"PorterCapability", 'DateTime'>
    readonly createdAt: FieldRef<"PorterCapability", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PorterCapability findUnique
   */
  export type PorterCapabilityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PorterCapability
     */
    select?: PorterCapabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PorterCapabilityInclude<ExtArgs> | null
    /**
     * Filter, which PorterCapability to fetch.
     */
    where: PorterCapabilityWhereUniqueInput
  }

  /**
   * PorterCapability findUniqueOrThrow
   */
  export type PorterCapabilityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PorterCapability
     */
    select?: PorterCapabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PorterCapabilityInclude<ExtArgs> | null
    /**
     * Filter, which PorterCapability to fetch.
     */
    where: PorterCapabilityWhereUniqueInput
  }

  /**
   * PorterCapability findFirst
   */
  export type PorterCapabilityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PorterCapability
     */
    select?: PorterCapabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PorterCapabilityInclude<ExtArgs> | null
    /**
     * Filter, which PorterCapability to fetch.
     */
    where?: PorterCapabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PorterCapabilities to fetch.
     */
    orderBy?: PorterCapabilityOrderByWithRelationInput | PorterCapabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PorterCapabilities.
     */
    cursor?: PorterCapabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PorterCapabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PorterCapabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PorterCapabilities.
     */
    distinct?: PorterCapabilityScalarFieldEnum | PorterCapabilityScalarFieldEnum[]
  }

  /**
   * PorterCapability findFirstOrThrow
   */
  export type PorterCapabilityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PorterCapability
     */
    select?: PorterCapabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PorterCapabilityInclude<ExtArgs> | null
    /**
     * Filter, which PorterCapability to fetch.
     */
    where?: PorterCapabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PorterCapabilities to fetch.
     */
    orderBy?: PorterCapabilityOrderByWithRelationInput | PorterCapabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PorterCapabilities.
     */
    cursor?: PorterCapabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PorterCapabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PorterCapabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PorterCapabilities.
     */
    distinct?: PorterCapabilityScalarFieldEnum | PorterCapabilityScalarFieldEnum[]
  }

  /**
   * PorterCapability findMany
   */
  export type PorterCapabilityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PorterCapability
     */
    select?: PorterCapabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PorterCapabilityInclude<ExtArgs> | null
    /**
     * Filter, which PorterCapabilities to fetch.
     */
    where?: PorterCapabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PorterCapabilities to fetch.
     */
    orderBy?: PorterCapabilityOrderByWithRelationInput | PorterCapabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PorterCapabilities.
     */
    cursor?: PorterCapabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PorterCapabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PorterCapabilities.
     */
    skip?: number
    distinct?: PorterCapabilityScalarFieldEnum | PorterCapabilityScalarFieldEnum[]
  }

  /**
   * PorterCapability create
   */
  export type PorterCapabilityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PorterCapability
     */
    select?: PorterCapabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PorterCapabilityInclude<ExtArgs> | null
    /**
     * The data needed to create a PorterCapability.
     */
    data: XOR<PorterCapabilityCreateInput, PorterCapabilityUncheckedCreateInput>
  }

  /**
   * PorterCapability createMany
   */
  export type PorterCapabilityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PorterCapabilities.
     */
    data: PorterCapabilityCreateManyInput | PorterCapabilityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PorterCapability update
   */
  export type PorterCapabilityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PorterCapability
     */
    select?: PorterCapabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PorterCapabilityInclude<ExtArgs> | null
    /**
     * The data needed to update a PorterCapability.
     */
    data: XOR<PorterCapabilityUpdateInput, PorterCapabilityUncheckedUpdateInput>
    /**
     * Choose, which PorterCapability to update.
     */
    where: PorterCapabilityWhereUniqueInput
  }

  /**
   * PorterCapability updateMany
   */
  export type PorterCapabilityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PorterCapabilities.
     */
    data: XOR<PorterCapabilityUpdateManyMutationInput, PorterCapabilityUncheckedUpdateManyInput>
    /**
     * Filter which PorterCapabilities to update
     */
    where?: PorterCapabilityWhereInput
  }

  /**
   * PorterCapability upsert
   */
  export type PorterCapabilityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PorterCapability
     */
    select?: PorterCapabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PorterCapabilityInclude<ExtArgs> | null
    /**
     * The filter to search for the PorterCapability to update in case it exists.
     */
    where: PorterCapabilityWhereUniqueInput
    /**
     * In case the PorterCapability found by the `where` argument doesn't exist, create a new PorterCapability with this data.
     */
    create: XOR<PorterCapabilityCreateInput, PorterCapabilityUncheckedCreateInput>
    /**
     * In case the PorterCapability was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PorterCapabilityUpdateInput, PorterCapabilityUncheckedUpdateInput>
  }

  /**
   * PorterCapability delete
   */
  export type PorterCapabilityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PorterCapability
     */
    select?: PorterCapabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PorterCapabilityInclude<ExtArgs> | null
    /**
     * Filter which PorterCapability to delete.
     */
    where: PorterCapabilityWhereUniqueInput
  }

  /**
   * PorterCapability deleteMany
   */
  export type PorterCapabilityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PorterCapabilities to delete
     */
    where?: PorterCapabilityWhereInput
  }

  /**
   * PorterCapability without action
   */
  export type PorterCapabilityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PorterCapability
     */
    select?: PorterCapabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PorterCapabilityInclude<ExtArgs> | null
  }


  /**
   * Model DepartmentCapability
   */

  export type AggregateDepartmentCapability = {
    _count: DepartmentCapabilityCountAggregateOutputType | null
    _min: DepartmentCapabilityMinAggregateOutputType | null
    _max: DepartmentCapabilityMaxAggregateOutputType | null
  }

  export type DepartmentCapabilityMinAggregateOutputType = {
    departmentId: string | null
    capabilityId: string | null
    requiredLevel: $Enums.RequiredLevel | null
  }

  export type DepartmentCapabilityMaxAggregateOutputType = {
    departmentId: string | null
    capabilityId: string | null
    requiredLevel: $Enums.RequiredLevel | null
  }

  export type DepartmentCapabilityCountAggregateOutputType = {
    departmentId: number
    capabilityId: number
    requiredLevel: number
    _all: number
  }


  export type DepartmentCapabilityMinAggregateInputType = {
    departmentId?: true
    capabilityId?: true
    requiredLevel?: true
  }

  export type DepartmentCapabilityMaxAggregateInputType = {
    departmentId?: true
    capabilityId?: true
    requiredLevel?: true
  }

  export type DepartmentCapabilityCountAggregateInputType = {
    departmentId?: true
    capabilityId?: true
    requiredLevel?: true
    _all?: true
  }

  export type DepartmentCapabilityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DepartmentCapability to aggregate.
     */
    where?: DepartmentCapabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DepartmentCapabilities to fetch.
     */
    orderBy?: DepartmentCapabilityOrderByWithRelationInput | DepartmentCapabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DepartmentCapabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DepartmentCapabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DepartmentCapabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DepartmentCapabilities
    **/
    _count?: true | DepartmentCapabilityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DepartmentCapabilityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DepartmentCapabilityMaxAggregateInputType
  }

  export type GetDepartmentCapabilityAggregateType<T extends DepartmentCapabilityAggregateArgs> = {
        [P in keyof T & keyof AggregateDepartmentCapability]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDepartmentCapability[P]>
      : GetScalarType<T[P], AggregateDepartmentCapability[P]>
  }




  export type DepartmentCapabilityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentCapabilityWhereInput
    orderBy?: DepartmentCapabilityOrderByWithAggregationInput | DepartmentCapabilityOrderByWithAggregationInput[]
    by: DepartmentCapabilityScalarFieldEnum[] | DepartmentCapabilityScalarFieldEnum
    having?: DepartmentCapabilityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DepartmentCapabilityCountAggregateInputType | true
    _min?: DepartmentCapabilityMinAggregateInputType
    _max?: DepartmentCapabilityMaxAggregateInputType
  }

  export type DepartmentCapabilityGroupByOutputType = {
    departmentId: string
    capabilityId: string
    requiredLevel: $Enums.RequiredLevel
    _count: DepartmentCapabilityCountAggregateOutputType | null
    _min: DepartmentCapabilityMinAggregateOutputType | null
    _max: DepartmentCapabilityMaxAggregateOutputType | null
  }

  type GetDepartmentCapabilityGroupByPayload<T extends DepartmentCapabilityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DepartmentCapabilityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DepartmentCapabilityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DepartmentCapabilityGroupByOutputType[P]>
            : GetScalarType<T[P], DepartmentCapabilityGroupByOutputType[P]>
        }
      >
    >


  export type DepartmentCapabilitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    departmentId?: boolean
    capabilityId?: boolean
    requiredLevel?: boolean
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
    capability?: boolean | CapabilityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["departmentCapability"]>


  export type DepartmentCapabilitySelectScalar = {
    departmentId?: boolean
    capabilityId?: boolean
    requiredLevel?: boolean
  }

  export type DepartmentCapabilityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
    capability?: boolean | CapabilityDefaultArgs<ExtArgs>
  }

  export type $DepartmentCapabilityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DepartmentCapability"
    objects: {
      department: Prisma.$DepartmentPayload<ExtArgs>
      capability: Prisma.$CapabilityPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      departmentId: string
      capabilityId: string
      requiredLevel: $Enums.RequiredLevel
    }, ExtArgs["result"]["departmentCapability"]>
    composites: {}
  }

  type DepartmentCapabilityGetPayload<S extends boolean | null | undefined | DepartmentCapabilityDefaultArgs> = $Result.GetResult<Prisma.$DepartmentCapabilityPayload, S>

  type DepartmentCapabilityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DepartmentCapabilityFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DepartmentCapabilityCountAggregateInputType | true
    }

  export interface DepartmentCapabilityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DepartmentCapability'], meta: { name: 'DepartmentCapability' } }
    /**
     * Find zero or one DepartmentCapability that matches the filter.
     * @param {DepartmentCapabilityFindUniqueArgs} args - Arguments to find a DepartmentCapability
     * @example
     * // Get one DepartmentCapability
     * const departmentCapability = await prisma.departmentCapability.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DepartmentCapabilityFindUniqueArgs>(args: SelectSubset<T, DepartmentCapabilityFindUniqueArgs<ExtArgs>>): Prisma__DepartmentCapabilityClient<$Result.GetResult<Prisma.$DepartmentCapabilityPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DepartmentCapability that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DepartmentCapabilityFindUniqueOrThrowArgs} args - Arguments to find a DepartmentCapability
     * @example
     * // Get one DepartmentCapability
     * const departmentCapability = await prisma.departmentCapability.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DepartmentCapabilityFindUniqueOrThrowArgs>(args: SelectSubset<T, DepartmentCapabilityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DepartmentCapabilityClient<$Result.GetResult<Prisma.$DepartmentCapabilityPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DepartmentCapability that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentCapabilityFindFirstArgs} args - Arguments to find a DepartmentCapability
     * @example
     * // Get one DepartmentCapability
     * const departmentCapability = await prisma.departmentCapability.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DepartmentCapabilityFindFirstArgs>(args?: SelectSubset<T, DepartmentCapabilityFindFirstArgs<ExtArgs>>): Prisma__DepartmentCapabilityClient<$Result.GetResult<Prisma.$DepartmentCapabilityPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DepartmentCapability that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentCapabilityFindFirstOrThrowArgs} args - Arguments to find a DepartmentCapability
     * @example
     * // Get one DepartmentCapability
     * const departmentCapability = await prisma.departmentCapability.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DepartmentCapabilityFindFirstOrThrowArgs>(args?: SelectSubset<T, DepartmentCapabilityFindFirstOrThrowArgs<ExtArgs>>): Prisma__DepartmentCapabilityClient<$Result.GetResult<Prisma.$DepartmentCapabilityPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DepartmentCapabilities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentCapabilityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DepartmentCapabilities
     * const departmentCapabilities = await prisma.departmentCapability.findMany()
     * 
     * // Get first 10 DepartmentCapabilities
     * const departmentCapabilities = await prisma.departmentCapability.findMany({ take: 10 })
     * 
     * // Only select the `departmentId`
     * const departmentCapabilityWithDepartmentIdOnly = await prisma.departmentCapability.findMany({ select: { departmentId: true } })
     * 
     */
    findMany<T extends DepartmentCapabilityFindManyArgs>(args?: SelectSubset<T, DepartmentCapabilityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentCapabilityPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DepartmentCapability.
     * @param {DepartmentCapabilityCreateArgs} args - Arguments to create a DepartmentCapability.
     * @example
     * // Create one DepartmentCapability
     * const DepartmentCapability = await prisma.departmentCapability.create({
     *   data: {
     *     // ... data to create a DepartmentCapability
     *   }
     * })
     * 
     */
    create<T extends DepartmentCapabilityCreateArgs>(args: SelectSubset<T, DepartmentCapabilityCreateArgs<ExtArgs>>): Prisma__DepartmentCapabilityClient<$Result.GetResult<Prisma.$DepartmentCapabilityPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DepartmentCapabilities.
     * @param {DepartmentCapabilityCreateManyArgs} args - Arguments to create many DepartmentCapabilities.
     * @example
     * // Create many DepartmentCapabilities
     * const departmentCapability = await prisma.departmentCapability.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DepartmentCapabilityCreateManyArgs>(args?: SelectSubset<T, DepartmentCapabilityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DepartmentCapability.
     * @param {DepartmentCapabilityDeleteArgs} args - Arguments to delete one DepartmentCapability.
     * @example
     * // Delete one DepartmentCapability
     * const DepartmentCapability = await prisma.departmentCapability.delete({
     *   where: {
     *     // ... filter to delete one DepartmentCapability
     *   }
     * })
     * 
     */
    delete<T extends DepartmentCapabilityDeleteArgs>(args: SelectSubset<T, DepartmentCapabilityDeleteArgs<ExtArgs>>): Prisma__DepartmentCapabilityClient<$Result.GetResult<Prisma.$DepartmentCapabilityPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DepartmentCapability.
     * @param {DepartmentCapabilityUpdateArgs} args - Arguments to update one DepartmentCapability.
     * @example
     * // Update one DepartmentCapability
     * const departmentCapability = await prisma.departmentCapability.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DepartmentCapabilityUpdateArgs>(args: SelectSubset<T, DepartmentCapabilityUpdateArgs<ExtArgs>>): Prisma__DepartmentCapabilityClient<$Result.GetResult<Prisma.$DepartmentCapabilityPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DepartmentCapabilities.
     * @param {DepartmentCapabilityDeleteManyArgs} args - Arguments to filter DepartmentCapabilities to delete.
     * @example
     * // Delete a few DepartmentCapabilities
     * const { count } = await prisma.departmentCapability.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DepartmentCapabilityDeleteManyArgs>(args?: SelectSubset<T, DepartmentCapabilityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DepartmentCapabilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentCapabilityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DepartmentCapabilities
     * const departmentCapability = await prisma.departmentCapability.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DepartmentCapabilityUpdateManyArgs>(args: SelectSubset<T, DepartmentCapabilityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DepartmentCapability.
     * @param {DepartmentCapabilityUpsertArgs} args - Arguments to update or create a DepartmentCapability.
     * @example
     * // Update or create a DepartmentCapability
     * const departmentCapability = await prisma.departmentCapability.upsert({
     *   create: {
     *     // ... data to create a DepartmentCapability
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DepartmentCapability we want to update
     *   }
     * })
     */
    upsert<T extends DepartmentCapabilityUpsertArgs>(args: SelectSubset<T, DepartmentCapabilityUpsertArgs<ExtArgs>>): Prisma__DepartmentCapabilityClient<$Result.GetResult<Prisma.$DepartmentCapabilityPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DepartmentCapabilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentCapabilityCountArgs} args - Arguments to filter DepartmentCapabilities to count.
     * @example
     * // Count the number of DepartmentCapabilities
     * const count = await prisma.departmentCapability.count({
     *   where: {
     *     // ... the filter for the DepartmentCapabilities we want to count
     *   }
     * })
    **/
    count<T extends DepartmentCapabilityCountArgs>(
      args?: Subset<T, DepartmentCapabilityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DepartmentCapabilityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DepartmentCapability.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentCapabilityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DepartmentCapabilityAggregateArgs>(args: Subset<T, DepartmentCapabilityAggregateArgs>): Prisma.PrismaPromise<GetDepartmentCapabilityAggregateType<T>>

    /**
     * Group by DepartmentCapability.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentCapabilityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DepartmentCapabilityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DepartmentCapabilityGroupByArgs['orderBy'] }
        : { orderBy?: DepartmentCapabilityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DepartmentCapabilityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDepartmentCapabilityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DepartmentCapability model
   */
  readonly fields: DepartmentCapabilityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DepartmentCapability.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DepartmentCapabilityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    department<T extends DepartmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DepartmentDefaultArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    capability<T extends CapabilityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CapabilityDefaultArgs<ExtArgs>>): Prisma__CapabilityClient<$Result.GetResult<Prisma.$CapabilityPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DepartmentCapability model
   */ 
  interface DepartmentCapabilityFieldRefs {
    readonly departmentId: FieldRef<"DepartmentCapability", 'String'>
    readonly capabilityId: FieldRef<"DepartmentCapability", 'String'>
    readonly requiredLevel: FieldRef<"DepartmentCapability", 'RequiredLevel'>
  }
    

  // Custom InputTypes
  /**
   * DepartmentCapability findUnique
   */
  export type DepartmentCapabilityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentCapability
     */
    select?: DepartmentCapabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentCapabilityInclude<ExtArgs> | null
    /**
     * Filter, which DepartmentCapability to fetch.
     */
    where: DepartmentCapabilityWhereUniqueInput
  }

  /**
   * DepartmentCapability findUniqueOrThrow
   */
  export type DepartmentCapabilityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentCapability
     */
    select?: DepartmentCapabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentCapabilityInclude<ExtArgs> | null
    /**
     * Filter, which DepartmentCapability to fetch.
     */
    where: DepartmentCapabilityWhereUniqueInput
  }

  /**
   * DepartmentCapability findFirst
   */
  export type DepartmentCapabilityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentCapability
     */
    select?: DepartmentCapabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentCapabilityInclude<ExtArgs> | null
    /**
     * Filter, which DepartmentCapability to fetch.
     */
    where?: DepartmentCapabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DepartmentCapabilities to fetch.
     */
    orderBy?: DepartmentCapabilityOrderByWithRelationInput | DepartmentCapabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DepartmentCapabilities.
     */
    cursor?: DepartmentCapabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DepartmentCapabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DepartmentCapabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DepartmentCapabilities.
     */
    distinct?: DepartmentCapabilityScalarFieldEnum | DepartmentCapabilityScalarFieldEnum[]
  }

  /**
   * DepartmentCapability findFirstOrThrow
   */
  export type DepartmentCapabilityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentCapability
     */
    select?: DepartmentCapabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentCapabilityInclude<ExtArgs> | null
    /**
     * Filter, which DepartmentCapability to fetch.
     */
    where?: DepartmentCapabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DepartmentCapabilities to fetch.
     */
    orderBy?: DepartmentCapabilityOrderByWithRelationInput | DepartmentCapabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DepartmentCapabilities.
     */
    cursor?: DepartmentCapabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DepartmentCapabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DepartmentCapabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DepartmentCapabilities.
     */
    distinct?: DepartmentCapabilityScalarFieldEnum | DepartmentCapabilityScalarFieldEnum[]
  }

  /**
   * DepartmentCapability findMany
   */
  export type DepartmentCapabilityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentCapability
     */
    select?: DepartmentCapabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentCapabilityInclude<ExtArgs> | null
    /**
     * Filter, which DepartmentCapabilities to fetch.
     */
    where?: DepartmentCapabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DepartmentCapabilities to fetch.
     */
    orderBy?: DepartmentCapabilityOrderByWithRelationInput | DepartmentCapabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DepartmentCapabilities.
     */
    cursor?: DepartmentCapabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DepartmentCapabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DepartmentCapabilities.
     */
    skip?: number
    distinct?: DepartmentCapabilityScalarFieldEnum | DepartmentCapabilityScalarFieldEnum[]
  }

  /**
   * DepartmentCapability create
   */
  export type DepartmentCapabilityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentCapability
     */
    select?: DepartmentCapabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentCapabilityInclude<ExtArgs> | null
    /**
     * The data needed to create a DepartmentCapability.
     */
    data: XOR<DepartmentCapabilityCreateInput, DepartmentCapabilityUncheckedCreateInput>
  }

  /**
   * DepartmentCapability createMany
   */
  export type DepartmentCapabilityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DepartmentCapabilities.
     */
    data: DepartmentCapabilityCreateManyInput | DepartmentCapabilityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DepartmentCapability update
   */
  export type DepartmentCapabilityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentCapability
     */
    select?: DepartmentCapabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentCapabilityInclude<ExtArgs> | null
    /**
     * The data needed to update a DepartmentCapability.
     */
    data: XOR<DepartmentCapabilityUpdateInput, DepartmentCapabilityUncheckedUpdateInput>
    /**
     * Choose, which DepartmentCapability to update.
     */
    where: DepartmentCapabilityWhereUniqueInput
  }

  /**
   * DepartmentCapability updateMany
   */
  export type DepartmentCapabilityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DepartmentCapabilities.
     */
    data: XOR<DepartmentCapabilityUpdateManyMutationInput, DepartmentCapabilityUncheckedUpdateManyInput>
    /**
     * Filter which DepartmentCapabilities to update
     */
    where?: DepartmentCapabilityWhereInput
  }

  /**
   * DepartmentCapability upsert
   */
  export type DepartmentCapabilityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentCapability
     */
    select?: DepartmentCapabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentCapabilityInclude<ExtArgs> | null
    /**
     * The filter to search for the DepartmentCapability to update in case it exists.
     */
    where: DepartmentCapabilityWhereUniqueInput
    /**
     * In case the DepartmentCapability found by the `where` argument doesn't exist, create a new DepartmentCapability with this data.
     */
    create: XOR<DepartmentCapabilityCreateInput, DepartmentCapabilityUncheckedCreateInput>
    /**
     * In case the DepartmentCapability was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DepartmentCapabilityUpdateInput, DepartmentCapabilityUncheckedUpdateInput>
  }

  /**
   * DepartmentCapability delete
   */
  export type DepartmentCapabilityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentCapability
     */
    select?: DepartmentCapabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentCapabilityInclude<ExtArgs> | null
    /**
     * Filter which DepartmentCapability to delete.
     */
    where: DepartmentCapabilityWhereUniqueInput
  }

  /**
   * DepartmentCapability deleteMany
   */
  export type DepartmentCapabilityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DepartmentCapabilities to delete
     */
    where?: DepartmentCapabilityWhereInput
  }

  /**
   * DepartmentCapability without action
   */
  export type DepartmentCapabilityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentCapability
     */
    select?: DepartmentCapabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentCapabilityInclude<ExtArgs> | null
  }


  /**
   * Model ServiceCapability
   */

  export type AggregateServiceCapability = {
    _count: ServiceCapabilityCountAggregateOutputType | null
    _min: ServiceCapabilityMinAggregateOutputType | null
    _max: ServiceCapabilityMaxAggregateOutputType | null
  }

  export type ServiceCapabilityMinAggregateOutputType = {
    serviceId: string | null
    capabilityId: string | null
    requiredLevel: $Enums.RequiredLevel | null
  }

  export type ServiceCapabilityMaxAggregateOutputType = {
    serviceId: string | null
    capabilityId: string | null
    requiredLevel: $Enums.RequiredLevel | null
  }

  export type ServiceCapabilityCountAggregateOutputType = {
    serviceId: number
    capabilityId: number
    requiredLevel: number
    _all: number
  }


  export type ServiceCapabilityMinAggregateInputType = {
    serviceId?: true
    capabilityId?: true
    requiredLevel?: true
  }

  export type ServiceCapabilityMaxAggregateInputType = {
    serviceId?: true
    capabilityId?: true
    requiredLevel?: true
  }

  export type ServiceCapabilityCountAggregateInputType = {
    serviceId?: true
    capabilityId?: true
    requiredLevel?: true
    _all?: true
  }

  export type ServiceCapabilityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceCapability to aggregate.
     */
    where?: ServiceCapabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceCapabilities to fetch.
     */
    orderBy?: ServiceCapabilityOrderByWithRelationInput | ServiceCapabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceCapabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceCapabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceCapabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceCapabilities
    **/
    _count?: true | ServiceCapabilityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceCapabilityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceCapabilityMaxAggregateInputType
  }

  export type GetServiceCapabilityAggregateType<T extends ServiceCapabilityAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceCapability]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceCapability[P]>
      : GetScalarType<T[P], AggregateServiceCapability[P]>
  }




  export type ServiceCapabilityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceCapabilityWhereInput
    orderBy?: ServiceCapabilityOrderByWithAggregationInput | ServiceCapabilityOrderByWithAggregationInput[]
    by: ServiceCapabilityScalarFieldEnum[] | ServiceCapabilityScalarFieldEnum
    having?: ServiceCapabilityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceCapabilityCountAggregateInputType | true
    _min?: ServiceCapabilityMinAggregateInputType
    _max?: ServiceCapabilityMaxAggregateInputType
  }

  export type ServiceCapabilityGroupByOutputType = {
    serviceId: string
    capabilityId: string
    requiredLevel: $Enums.RequiredLevel
    _count: ServiceCapabilityCountAggregateOutputType | null
    _min: ServiceCapabilityMinAggregateOutputType | null
    _max: ServiceCapabilityMaxAggregateOutputType | null
  }

  type GetServiceCapabilityGroupByPayload<T extends ServiceCapabilityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceCapabilityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceCapabilityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceCapabilityGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceCapabilityGroupByOutputType[P]>
        }
      >
    >


  export type ServiceCapabilitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    serviceId?: boolean
    capabilityId?: boolean
    requiredLevel?: boolean
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    capability?: boolean | CapabilityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceCapability"]>


  export type ServiceCapabilitySelectScalar = {
    serviceId?: boolean
    capabilityId?: boolean
    requiredLevel?: boolean
  }

  export type ServiceCapabilityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    capability?: boolean | CapabilityDefaultArgs<ExtArgs>
  }

  export type $ServiceCapabilityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServiceCapability"
    objects: {
      service: Prisma.$ServicePayload<ExtArgs>
      capability: Prisma.$CapabilityPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      serviceId: string
      capabilityId: string
      requiredLevel: $Enums.RequiredLevel
    }, ExtArgs["result"]["serviceCapability"]>
    composites: {}
  }

  type ServiceCapabilityGetPayload<S extends boolean | null | undefined | ServiceCapabilityDefaultArgs> = $Result.GetResult<Prisma.$ServiceCapabilityPayload, S>

  type ServiceCapabilityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ServiceCapabilityFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ServiceCapabilityCountAggregateInputType | true
    }

  export interface ServiceCapabilityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceCapability'], meta: { name: 'ServiceCapability' } }
    /**
     * Find zero or one ServiceCapability that matches the filter.
     * @param {ServiceCapabilityFindUniqueArgs} args - Arguments to find a ServiceCapability
     * @example
     * // Get one ServiceCapability
     * const serviceCapability = await prisma.serviceCapability.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceCapabilityFindUniqueArgs>(args: SelectSubset<T, ServiceCapabilityFindUniqueArgs<ExtArgs>>): Prisma__ServiceCapabilityClient<$Result.GetResult<Prisma.$ServiceCapabilityPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ServiceCapability that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ServiceCapabilityFindUniqueOrThrowArgs} args - Arguments to find a ServiceCapability
     * @example
     * // Get one ServiceCapability
     * const serviceCapability = await prisma.serviceCapability.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceCapabilityFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceCapabilityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceCapabilityClient<$Result.GetResult<Prisma.$ServiceCapabilityPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ServiceCapability that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCapabilityFindFirstArgs} args - Arguments to find a ServiceCapability
     * @example
     * // Get one ServiceCapability
     * const serviceCapability = await prisma.serviceCapability.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceCapabilityFindFirstArgs>(args?: SelectSubset<T, ServiceCapabilityFindFirstArgs<ExtArgs>>): Prisma__ServiceCapabilityClient<$Result.GetResult<Prisma.$ServiceCapabilityPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ServiceCapability that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCapabilityFindFirstOrThrowArgs} args - Arguments to find a ServiceCapability
     * @example
     * // Get one ServiceCapability
     * const serviceCapability = await prisma.serviceCapability.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceCapabilityFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceCapabilityFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceCapabilityClient<$Result.GetResult<Prisma.$ServiceCapabilityPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ServiceCapabilities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCapabilityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceCapabilities
     * const serviceCapabilities = await prisma.serviceCapability.findMany()
     * 
     * // Get first 10 ServiceCapabilities
     * const serviceCapabilities = await prisma.serviceCapability.findMany({ take: 10 })
     * 
     * // Only select the `serviceId`
     * const serviceCapabilityWithServiceIdOnly = await prisma.serviceCapability.findMany({ select: { serviceId: true } })
     * 
     */
    findMany<T extends ServiceCapabilityFindManyArgs>(args?: SelectSubset<T, ServiceCapabilityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceCapabilityPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ServiceCapability.
     * @param {ServiceCapabilityCreateArgs} args - Arguments to create a ServiceCapability.
     * @example
     * // Create one ServiceCapability
     * const ServiceCapability = await prisma.serviceCapability.create({
     *   data: {
     *     // ... data to create a ServiceCapability
     *   }
     * })
     * 
     */
    create<T extends ServiceCapabilityCreateArgs>(args: SelectSubset<T, ServiceCapabilityCreateArgs<ExtArgs>>): Prisma__ServiceCapabilityClient<$Result.GetResult<Prisma.$ServiceCapabilityPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ServiceCapabilities.
     * @param {ServiceCapabilityCreateManyArgs} args - Arguments to create many ServiceCapabilities.
     * @example
     * // Create many ServiceCapabilities
     * const serviceCapability = await prisma.serviceCapability.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceCapabilityCreateManyArgs>(args?: SelectSubset<T, ServiceCapabilityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ServiceCapability.
     * @param {ServiceCapabilityDeleteArgs} args - Arguments to delete one ServiceCapability.
     * @example
     * // Delete one ServiceCapability
     * const ServiceCapability = await prisma.serviceCapability.delete({
     *   where: {
     *     // ... filter to delete one ServiceCapability
     *   }
     * })
     * 
     */
    delete<T extends ServiceCapabilityDeleteArgs>(args: SelectSubset<T, ServiceCapabilityDeleteArgs<ExtArgs>>): Prisma__ServiceCapabilityClient<$Result.GetResult<Prisma.$ServiceCapabilityPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ServiceCapability.
     * @param {ServiceCapabilityUpdateArgs} args - Arguments to update one ServiceCapability.
     * @example
     * // Update one ServiceCapability
     * const serviceCapability = await prisma.serviceCapability.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceCapabilityUpdateArgs>(args: SelectSubset<T, ServiceCapabilityUpdateArgs<ExtArgs>>): Prisma__ServiceCapabilityClient<$Result.GetResult<Prisma.$ServiceCapabilityPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ServiceCapabilities.
     * @param {ServiceCapabilityDeleteManyArgs} args - Arguments to filter ServiceCapabilities to delete.
     * @example
     * // Delete a few ServiceCapabilities
     * const { count } = await prisma.serviceCapability.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceCapabilityDeleteManyArgs>(args?: SelectSubset<T, ServiceCapabilityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceCapabilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCapabilityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceCapabilities
     * const serviceCapability = await prisma.serviceCapability.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceCapabilityUpdateManyArgs>(args: SelectSubset<T, ServiceCapabilityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ServiceCapability.
     * @param {ServiceCapabilityUpsertArgs} args - Arguments to update or create a ServiceCapability.
     * @example
     * // Update or create a ServiceCapability
     * const serviceCapability = await prisma.serviceCapability.upsert({
     *   create: {
     *     // ... data to create a ServiceCapability
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceCapability we want to update
     *   }
     * })
     */
    upsert<T extends ServiceCapabilityUpsertArgs>(args: SelectSubset<T, ServiceCapabilityUpsertArgs<ExtArgs>>): Prisma__ServiceCapabilityClient<$Result.GetResult<Prisma.$ServiceCapabilityPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ServiceCapabilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCapabilityCountArgs} args - Arguments to filter ServiceCapabilities to count.
     * @example
     * // Count the number of ServiceCapabilities
     * const count = await prisma.serviceCapability.count({
     *   where: {
     *     // ... the filter for the ServiceCapabilities we want to count
     *   }
     * })
    **/
    count<T extends ServiceCapabilityCountArgs>(
      args?: Subset<T, ServiceCapabilityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceCapabilityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceCapability.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCapabilityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceCapabilityAggregateArgs>(args: Subset<T, ServiceCapabilityAggregateArgs>): Prisma.PrismaPromise<GetServiceCapabilityAggregateType<T>>

    /**
     * Group by ServiceCapability.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCapabilityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceCapabilityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceCapabilityGroupByArgs['orderBy'] }
        : { orderBy?: ServiceCapabilityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceCapabilityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceCapabilityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiceCapability model
   */
  readonly fields: ServiceCapabilityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceCapability.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceCapabilityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceDefaultArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    capability<T extends CapabilityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CapabilityDefaultArgs<ExtArgs>>): Prisma__CapabilityClient<$Result.GetResult<Prisma.$CapabilityPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServiceCapability model
   */ 
  interface ServiceCapabilityFieldRefs {
    readonly serviceId: FieldRef<"ServiceCapability", 'String'>
    readonly capabilityId: FieldRef<"ServiceCapability", 'String'>
    readonly requiredLevel: FieldRef<"ServiceCapability", 'RequiredLevel'>
  }
    

  // Custom InputTypes
  /**
   * ServiceCapability findUnique
   */
  export type ServiceCapabilityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCapability
     */
    select?: ServiceCapabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCapabilityInclude<ExtArgs> | null
    /**
     * Filter, which ServiceCapability to fetch.
     */
    where: ServiceCapabilityWhereUniqueInput
  }

  /**
   * ServiceCapability findUniqueOrThrow
   */
  export type ServiceCapabilityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCapability
     */
    select?: ServiceCapabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCapabilityInclude<ExtArgs> | null
    /**
     * Filter, which ServiceCapability to fetch.
     */
    where: ServiceCapabilityWhereUniqueInput
  }

  /**
   * ServiceCapability findFirst
   */
  export type ServiceCapabilityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCapability
     */
    select?: ServiceCapabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCapabilityInclude<ExtArgs> | null
    /**
     * Filter, which ServiceCapability to fetch.
     */
    where?: ServiceCapabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceCapabilities to fetch.
     */
    orderBy?: ServiceCapabilityOrderByWithRelationInput | ServiceCapabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceCapabilities.
     */
    cursor?: ServiceCapabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceCapabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceCapabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceCapabilities.
     */
    distinct?: ServiceCapabilityScalarFieldEnum | ServiceCapabilityScalarFieldEnum[]
  }

  /**
   * ServiceCapability findFirstOrThrow
   */
  export type ServiceCapabilityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCapability
     */
    select?: ServiceCapabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCapabilityInclude<ExtArgs> | null
    /**
     * Filter, which ServiceCapability to fetch.
     */
    where?: ServiceCapabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceCapabilities to fetch.
     */
    orderBy?: ServiceCapabilityOrderByWithRelationInput | ServiceCapabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceCapabilities.
     */
    cursor?: ServiceCapabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceCapabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceCapabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceCapabilities.
     */
    distinct?: ServiceCapabilityScalarFieldEnum | ServiceCapabilityScalarFieldEnum[]
  }

  /**
   * ServiceCapability findMany
   */
  export type ServiceCapabilityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCapability
     */
    select?: ServiceCapabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCapabilityInclude<ExtArgs> | null
    /**
     * Filter, which ServiceCapabilities to fetch.
     */
    where?: ServiceCapabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceCapabilities to fetch.
     */
    orderBy?: ServiceCapabilityOrderByWithRelationInput | ServiceCapabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceCapabilities.
     */
    cursor?: ServiceCapabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceCapabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceCapabilities.
     */
    skip?: number
    distinct?: ServiceCapabilityScalarFieldEnum | ServiceCapabilityScalarFieldEnum[]
  }

  /**
   * ServiceCapability create
   */
  export type ServiceCapabilityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCapability
     */
    select?: ServiceCapabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCapabilityInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceCapability.
     */
    data: XOR<ServiceCapabilityCreateInput, ServiceCapabilityUncheckedCreateInput>
  }

  /**
   * ServiceCapability createMany
   */
  export type ServiceCapabilityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceCapabilities.
     */
    data: ServiceCapabilityCreateManyInput | ServiceCapabilityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceCapability update
   */
  export type ServiceCapabilityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCapability
     */
    select?: ServiceCapabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCapabilityInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceCapability.
     */
    data: XOR<ServiceCapabilityUpdateInput, ServiceCapabilityUncheckedUpdateInput>
    /**
     * Choose, which ServiceCapability to update.
     */
    where: ServiceCapabilityWhereUniqueInput
  }

  /**
   * ServiceCapability updateMany
   */
  export type ServiceCapabilityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceCapabilities.
     */
    data: XOR<ServiceCapabilityUpdateManyMutationInput, ServiceCapabilityUncheckedUpdateManyInput>
    /**
     * Filter which ServiceCapabilities to update
     */
    where?: ServiceCapabilityWhereInput
  }

  /**
   * ServiceCapability upsert
   */
  export type ServiceCapabilityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCapability
     */
    select?: ServiceCapabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCapabilityInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceCapability to update in case it exists.
     */
    where: ServiceCapabilityWhereUniqueInput
    /**
     * In case the ServiceCapability found by the `where` argument doesn't exist, create a new ServiceCapability with this data.
     */
    create: XOR<ServiceCapabilityCreateInput, ServiceCapabilityUncheckedCreateInput>
    /**
     * In case the ServiceCapability was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceCapabilityUpdateInput, ServiceCapabilityUncheckedUpdateInput>
  }

  /**
   * ServiceCapability delete
   */
  export type ServiceCapabilityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCapability
     */
    select?: ServiceCapabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCapabilityInclude<ExtArgs> | null
    /**
     * Filter which ServiceCapability to delete.
     */
    where: ServiceCapabilityWhereUniqueInput
  }

  /**
   * ServiceCapability deleteMany
   */
  export type ServiceCapabilityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceCapabilities to delete
     */
    where?: ServiceCapabilityWhereInput
  }

  /**
   * ServiceCapability without action
   */
  export type ServiceCapabilityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCapability
     */
    select?: ServiceCapabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCapabilityInclude<ExtArgs> | null
  }


  /**
   * Model Allocation
   */

  export type AggregateAllocation = {
    _count: AllocationCountAggregateOutputType | null
    _min: AllocationMinAggregateOutputType | null
    _max: AllocationMaxAggregateOutputType | null
  }

  export type AllocationMinAggregateOutputType = {
    id: string | null
    porterId: string | null
    departmentId: string | null
    serviceId: string | null
    startDatetime: Date | null
    endDatetime: Date | null
    type: $Enums.AllocationType | null
    reason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AllocationMaxAggregateOutputType = {
    id: string | null
    porterId: string | null
    departmentId: string | null
    serviceId: string | null
    startDatetime: Date | null
    endDatetime: Date | null
    type: $Enums.AllocationType | null
    reason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AllocationCountAggregateOutputType = {
    id: number
    porterId: number
    departmentId: number
    serviceId: number
    startDatetime: number
    endDatetime: number
    type: number
    reason: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AllocationMinAggregateInputType = {
    id?: true
    porterId?: true
    departmentId?: true
    serviceId?: true
    startDatetime?: true
    endDatetime?: true
    type?: true
    reason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AllocationMaxAggregateInputType = {
    id?: true
    porterId?: true
    departmentId?: true
    serviceId?: true
    startDatetime?: true
    endDatetime?: true
    type?: true
    reason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AllocationCountAggregateInputType = {
    id?: true
    porterId?: true
    departmentId?: true
    serviceId?: true
    startDatetime?: true
    endDatetime?: true
    type?: true
    reason?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AllocationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Allocation to aggregate.
     */
    where?: AllocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Allocations to fetch.
     */
    orderBy?: AllocationOrderByWithRelationInput | AllocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AllocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Allocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Allocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Allocations
    **/
    _count?: true | AllocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AllocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AllocationMaxAggregateInputType
  }

  export type GetAllocationAggregateType<T extends AllocationAggregateArgs> = {
        [P in keyof T & keyof AggregateAllocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAllocation[P]>
      : GetScalarType<T[P], AggregateAllocation[P]>
  }




  export type AllocationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AllocationWhereInput
    orderBy?: AllocationOrderByWithAggregationInput | AllocationOrderByWithAggregationInput[]
    by: AllocationScalarFieldEnum[] | AllocationScalarFieldEnum
    having?: AllocationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AllocationCountAggregateInputType | true
    _min?: AllocationMinAggregateInputType
    _max?: AllocationMaxAggregateInputType
  }

  export type AllocationGroupByOutputType = {
    id: string
    porterId: string
    departmentId: string
    serviceId: string | null
    startDatetime: Date
    endDatetime: Date | null
    type: $Enums.AllocationType
    reason: string | null
    createdAt: Date
    updatedAt: Date
    _count: AllocationCountAggregateOutputType | null
    _min: AllocationMinAggregateOutputType | null
    _max: AllocationMaxAggregateOutputType | null
  }

  type GetAllocationGroupByPayload<T extends AllocationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AllocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AllocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AllocationGroupByOutputType[P]>
            : GetScalarType<T[P], AllocationGroupByOutputType[P]>
        }
      >
    >


  export type AllocationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    porterId?: boolean
    departmentId?: boolean
    serviceId?: boolean
    startDatetime?: boolean
    endDatetime?: boolean
    type?: boolean
    reason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    porter?: boolean | PorterDefaultArgs<ExtArgs>
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
    service?: boolean | Allocation$serviceArgs<ExtArgs>
  }, ExtArgs["result"]["allocation"]>


  export type AllocationSelectScalar = {
    id?: boolean
    porterId?: boolean
    departmentId?: boolean
    serviceId?: boolean
    startDatetime?: boolean
    endDatetime?: boolean
    type?: boolean
    reason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AllocationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    porter?: boolean | PorterDefaultArgs<ExtArgs>
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
    service?: boolean | Allocation$serviceArgs<ExtArgs>
  }

  export type $AllocationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Allocation"
    objects: {
      porter: Prisma.$PorterPayload<ExtArgs>
      department: Prisma.$DepartmentPayload<ExtArgs>
      service: Prisma.$ServicePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      porterId: string
      departmentId: string
      serviceId: string | null
      startDatetime: Date
      endDatetime: Date | null
      type: $Enums.AllocationType
      reason: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["allocation"]>
    composites: {}
  }

  type AllocationGetPayload<S extends boolean | null | undefined | AllocationDefaultArgs> = $Result.GetResult<Prisma.$AllocationPayload, S>

  type AllocationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AllocationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AllocationCountAggregateInputType | true
    }

  export interface AllocationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Allocation'], meta: { name: 'Allocation' } }
    /**
     * Find zero or one Allocation that matches the filter.
     * @param {AllocationFindUniqueArgs} args - Arguments to find a Allocation
     * @example
     * // Get one Allocation
     * const allocation = await prisma.allocation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AllocationFindUniqueArgs>(args: SelectSubset<T, AllocationFindUniqueArgs<ExtArgs>>): Prisma__AllocationClient<$Result.GetResult<Prisma.$AllocationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Allocation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AllocationFindUniqueOrThrowArgs} args - Arguments to find a Allocation
     * @example
     * // Get one Allocation
     * const allocation = await prisma.allocation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AllocationFindUniqueOrThrowArgs>(args: SelectSubset<T, AllocationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AllocationClient<$Result.GetResult<Prisma.$AllocationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Allocation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllocationFindFirstArgs} args - Arguments to find a Allocation
     * @example
     * // Get one Allocation
     * const allocation = await prisma.allocation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AllocationFindFirstArgs>(args?: SelectSubset<T, AllocationFindFirstArgs<ExtArgs>>): Prisma__AllocationClient<$Result.GetResult<Prisma.$AllocationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Allocation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllocationFindFirstOrThrowArgs} args - Arguments to find a Allocation
     * @example
     * // Get one Allocation
     * const allocation = await prisma.allocation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AllocationFindFirstOrThrowArgs>(args?: SelectSubset<T, AllocationFindFirstOrThrowArgs<ExtArgs>>): Prisma__AllocationClient<$Result.GetResult<Prisma.$AllocationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Allocations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllocationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Allocations
     * const allocations = await prisma.allocation.findMany()
     * 
     * // Get first 10 Allocations
     * const allocations = await prisma.allocation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const allocationWithIdOnly = await prisma.allocation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AllocationFindManyArgs>(args?: SelectSubset<T, AllocationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AllocationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Allocation.
     * @param {AllocationCreateArgs} args - Arguments to create a Allocation.
     * @example
     * // Create one Allocation
     * const Allocation = await prisma.allocation.create({
     *   data: {
     *     // ... data to create a Allocation
     *   }
     * })
     * 
     */
    create<T extends AllocationCreateArgs>(args: SelectSubset<T, AllocationCreateArgs<ExtArgs>>): Prisma__AllocationClient<$Result.GetResult<Prisma.$AllocationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Allocations.
     * @param {AllocationCreateManyArgs} args - Arguments to create many Allocations.
     * @example
     * // Create many Allocations
     * const allocation = await prisma.allocation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AllocationCreateManyArgs>(args?: SelectSubset<T, AllocationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Allocation.
     * @param {AllocationDeleteArgs} args - Arguments to delete one Allocation.
     * @example
     * // Delete one Allocation
     * const Allocation = await prisma.allocation.delete({
     *   where: {
     *     // ... filter to delete one Allocation
     *   }
     * })
     * 
     */
    delete<T extends AllocationDeleteArgs>(args: SelectSubset<T, AllocationDeleteArgs<ExtArgs>>): Prisma__AllocationClient<$Result.GetResult<Prisma.$AllocationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Allocation.
     * @param {AllocationUpdateArgs} args - Arguments to update one Allocation.
     * @example
     * // Update one Allocation
     * const allocation = await prisma.allocation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AllocationUpdateArgs>(args: SelectSubset<T, AllocationUpdateArgs<ExtArgs>>): Prisma__AllocationClient<$Result.GetResult<Prisma.$AllocationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Allocations.
     * @param {AllocationDeleteManyArgs} args - Arguments to filter Allocations to delete.
     * @example
     * // Delete a few Allocations
     * const { count } = await prisma.allocation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AllocationDeleteManyArgs>(args?: SelectSubset<T, AllocationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Allocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllocationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Allocations
     * const allocation = await prisma.allocation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AllocationUpdateManyArgs>(args: SelectSubset<T, AllocationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Allocation.
     * @param {AllocationUpsertArgs} args - Arguments to update or create a Allocation.
     * @example
     * // Update or create a Allocation
     * const allocation = await prisma.allocation.upsert({
     *   create: {
     *     // ... data to create a Allocation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Allocation we want to update
     *   }
     * })
     */
    upsert<T extends AllocationUpsertArgs>(args: SelectSubset<T, AllocationUpsertArgs<ExtArgs>>): Prisma__AllocationClient<$Result.GetResult<Prisma.$AllocationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Allocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllocationCountArgs} args - Arguments to filter Allocations to count.
     * @example
     * // Count the number of Allocations
     * const count = await prisma.allocation.count({
     *   where: {
     *     // ... the filter for the Allocations we want to count
     *   }
     * })
    **/
    count<T extends AllocationCountArgs>(
      args?: Subset<T, AllocationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AllocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Allocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AllocationAggregateArgs>(args: Subset<T, AllocationAggregateArgs>): Prisma.PrismaPromise<GetAllocationAggregateType<T>>

    /**
     * Group by Allocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AllocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AllocationGroupByArgs['orderBy'] }
        : { orderBy?: AllocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AllocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAllocationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Allocation model
   */
  readonly fields: AllocationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Allocation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AllocationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    porter<T extends PorterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PorterDefaultArgs<ExtArgs>>): Prisma__PorterClient<$Result.GetResult<Prisma.$PorterPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    department<T extends DepartmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DepartmentDefaultArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    service<T extends Allocation$serviceArgs<ExtArgs> = {}>(args?: Subset<T, Allocation$serviceArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Allocation model
   */ 
  interface AllocationFieldRefs {
    readonly id: FieldRef<"Allocation", 'String'>
    readonly porterId: FieldRef<"Allocation", 'String'>
    readonly departmentId: FieldRef<"Allocation", 'String'>
    readonly serviceId: FieldRef<"Allocation", 'String'>
    readonly startDatetime: FieldRef<"Allocation", 'DateTime'>
    readonly endDatetime: FieldRef<"Allocation", 'DateTime'>
    readonly type: FieldRef<"Allocation", 'AllocationType'>
    readonly reason: FieldRef<"Allocation", 'String'>
    readonly createdAt: FieldRef<"Allocation", 'DateTime'>
    readonly updatedAt: FieldRef<"Allocation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Allocation findUnique
   */
  export type AllocationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allocation
     */
    select?: AllocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllocationInclude<ExtArgs> | null
    /**
     * Filter, which Allocation to fetch.
     */
    where: AllocationWhereUniqueInput
  }

  /**
   * Allocation findUniqueOrThrow
   */
  export type AllocationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allocation
     */
    select?: AllocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllocationInclude<ExtArgs> | null
    /**
     * Filter, which Allocation to fetch.
     */
    where: AllocationWhereUniqueInput
  }

  /**
   * Allocation findFirst
   */
  export type AllocationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allocation
     */
    select?: AllocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllocationInclude<ExtArgs> | null
    /**
     * Filter, which Allocation to fetch.
     */
    where?: AllocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Allocations to fetch.
     */
    orderBy?: AllocationOrderByWithRelationInput | AllocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Allocations.
     */
    cursor?: AllocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Allocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Allocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Allocations.
     */
    distinct?: AllocationScalarFieldEnum | AllocationScalarFieldEnum[]
  }

  /**
   * Allocation findFirstOrThrow
   */
  export type AllocationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allocation
     */
    select?: AllocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllocationInclude<ExtArgs> | null
    /**
     * Filter, which Allocation to fetch.
     */
    where?: AllocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Allocations to fetch.
     */
    orderBy?: AllocationOrderByWithRelationInput | AllocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Allocations.
     */
    cursor?: AllocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Allocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Allocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Allocations.
     */
    distinct?: AllocationScalarFieldEnum | AllocationScalarFieldEnum[]
  }

  /**
   * Allocation findMany
   */
  export type AllocationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allocation
     */
    select?: AllocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllocationInclude<ExtArgs> | null
    /**
     * Filter, which Allocations to fetch.
     */
    where?: AllocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Allocations to fetch.
     */
    orderBy?: AllocationOrderByWithRelationInput | AllocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Allocations.
     */
    cursor?: AllocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Allocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Allocations.
     */
    skip?: number
    distinct?: AllocationScalarFieldEnum | AllocationScalarFieldEnum[]
  }

  /**
   * Allocation create
   */
  export type AllocationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allocation
     */
    select?: AllocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllocationInclude<ExtArgs> | null
    /**
     * The data needed to create a Allocation.
     */
    data: XOR<AllocationCreateInput, AllocationUncheckedCreateInput>
  }

  /**
   * Allocation createMany
   */
  export type AllocationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Allocations.
     */
    data: AllocationCreateManyInput | AllocationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Allocation update
   */
  export type AllocationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allocation
     */
    select?: AllocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllocationInclude<ExtArgs> | null
    /**
     * The data needed to update a Allocation.
     */
    data: XOR<AllocationUpdateInput, AllocationUncheckedUpdateInput>
    /**
     * Choose, which Allocation to update.
     */
    where: AllocationWhereUniqueInput
  }

  /**
   * Allocation updateMany
   */
  export type AllocationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Allocations.
     */
    data: XOR<AllocationUpdateManyMutationInput, AllocationUncheckedUpdateManyInput>
    /**
     * Filter which Allocations to update
     */
    where?: AllocationWhereInput
  }

  /**
   * Allocation upsert
   */
  export type AllocationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allocation
     */
    select?: AllocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllocationInclude<ExtArgs> | null
    /**
     * The filter to search for the Allocation to update in case it exists.
     */
    where: AllocationWhereUniqueInput
    /**
     * In case the Allocation found by the `where` argument doesn't exist, create a new Allocation with this data.
     */
    create: XOR<AllocationCreateInput, AllocationUncheckedCreateInput>
    /**
     * In case the Allocation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AllocationUpdateInput, AllocationUncheckedUpdateInput>
  }

  /**
   * Allocation delete
   */
  export type AllocationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allocation
     */
    select?: AllocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllocationInclude<ExtArgs> | null
    /**
     * Filter which Allocation to delete.
     */
    where: AllocationWhereUniqueInput
  }

  /**
   * Allocation deleteMany
   */
  export type AllocationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Allocations to delete
     */
    where?: AllocationWhereInput
  }

  /**
   * Allocation.service
   */
  export type Allocation$serviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    where?: ServiceWhereInput
  }

  /**
   * Allocation without action
   */
  export type AllocationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allocation
     */
    select?: AllocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllocationInclude<ExtArgs> | null
  }


  /**
   * Model Availability
   */

  export type AggregateAvailability = {
    _count: AvailabilityCountAggregateOutputType | null
    _min: AvailabilityMinAggregateOutputType | null
    _max: AvailabilityMaxAggregateOutputType | null
  }

  export type AvailabilityMinAggregateOutputType = {
    id: string | null
    porterId: string | null
    startDatetime: Date | null
    endDatetime: Date | null
    status: $Enums.AvailabilityStatus | null
    reason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AvailabilityMaxAggregateOutputType = {
    id: string | null
    porterId: string | null
    startDatetime: Date | null
    endDatetime: Date | null
    status: $Enums.AvailabilityStatus | null
    reason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AvailabilityCountAggregateOutputType = {
    id: number
    porterId: number
    startDatetime: number
    endDatetime: number
    status: number
    reason: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AvailabilityMinAggregateInputType = {
    id?: true
    porterId?: true
    startDatetime?: true
    endDatetime?: true
    status?: true
    reason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AvailabilityMaxAggregateInputType = {
    id?: true
    porterId?: true
    startDatetime?: true
    endDatetime?: true
    status?: true
    reason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AvailabilityCountAggregateInputType = {
    id?: true
    porterId?: true
    startDatetime?: true
    endDatetime?: true
    status?: true
    reason?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AvailabilityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Availability to aggregate.
     */
    where?: AvailabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Availabilities to fetch.
     */
    orderBy?: AvailabilityOrderByWithRelationInput | AvailabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AvailabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Availabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Availabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Availabilities
    **/
    _count?: true | AvailabilityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AvailabilityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AvailabilityMaxAggregateInputType
  }

  export type GetAvailabilityAggregateType<T extends AvailabilityAggregateArgs> = {
        [P in keyof T & keyof AggregateAvailability]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAvailability[P]>
      : GetScalarType<T[P], AggregateAvailability[P]>
  }




  export type AvailabilityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AvailabilityWhereInput
    orderBy?: AvailabilityOrderByWithAggregationInput | AvailabilityOrderByWithAggregationInput[]
    by: AvailabilityScalarFieldEnum[] | AvailabilityScalarFieldEnum
    having?: AvailabilityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AvailabilityCountAggregateInputType | true
    _min?: AvailabilityMinAggregateInputType
    _max?: AvailabilityMaxAggregateInputType
  }

  export type AvailabilityGroupByOutputType = {
    id: string
    porterId: string
    startDatetime: Date
    endDatetime: Date
    status: $Enums.AvailabilityStatus
    reason: string | null
    createdAt: Date
    updatedAt: Date
    _count: AvailabilityCountAggregateOutputType | null
    _min: AvailabilityMinAggregateOutputType | null
    _max: AvailabilityMaxAggregateOutputType | null
  }

  type GetAvailabilityGroupByPayload<T extends AvailabilityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AvailabilityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AvailabilityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AvailabilityGroupByOutputType[P]>
            : GetScalarType<T[P], AvailabilityGroupByOutputType[P]>
        }
      >
    >


  export type AvailabilitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    porterId?: boolean
    startDatetime?: boolean
    endDatetime?: boolean
    status?: boolean
    reason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    porter?: boolean | PorterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["availability"]>


  export type AvailabilitySelectScalar = {
    id?: boolean
    porterId?: boolean
    startDatetime?: boolean
    endDatetime?: boolean
    status?: boolean
    reason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AvailabilityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    porter?: boolean | PorterDefaultArgs<ExtArgs>
  }

  export type $AvailabilityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Availability"
    objects: {
      porter: Prisma.$PorterPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      porterId: string
      startDatetime: Date
      endDatetime: Date
      status: $Enums.AvailabilityStatus
      reason: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["availability"]>
    composites: {}
  }

  type AvailabilityGetPayload<S extends boolean | null | undefined | AvailabilityDefaultArgs> = $Result.GetResult<Prisma.$AvailabilityPayload, S>

  type AvailabilityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AvailabilityFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AvailabilityCountAggregateInputType | true
    }

  export interface AvailabilityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Availability'], meta: { name: 'Availability' } }
    /**
     * Find zero or one Availability that matches the filter.
     * @param {AvailabilityFindUniqueArgs} args - Arguments to find a Availability
     * @example
     * // Get one Availability
     * const availability = await prisma.availability.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AvailabilityFindUniqueArgs>(args: SelectSubset<T, AvailabilityFindUniqueArgs<ExtArgs>>): Prisma__AvailabilityClient<$Result.GetResult<Prisma.$AvailabilityPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Availability that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AvailabilityFindUniqueOrThrowArgs} args - Arguments to find a Availability
     * @example
     * // Get one Availability
     * const availability = await prisma.availability.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AvailabilityFindUniqueOrThrowArgs>(args: SelectSubset<T, AvailabilityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AvailabilityClient<$Result.GetResult<Prisma.$AvailabilityPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Availability that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvailabilityFindFirstArgs} args - Arguments to find a Availability
     * @example
     * // Get one Availability
     * const availability = await prisma.availability.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AvailabilityFindFirstArgs>(args?: SelectSubset<T, AvailabilityFindFirstArgs<ExtArgs>>): Prisma__AvailabilityClient<$Result.GetResult<Prisma.$AvailabilityPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Availability that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvailabilityFindFirstOrThrowArgs} args - Arguments to find a Availability
     * @example
     * // Get one Availability
     * const availability = await prisma.availability.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AvailabilityFindFirstOrThrowArgs>(args?: SelectSubset<T, AvailabilityFindFirstOrThrowArgs<ExtArgs>>): Prisma__AvailabilityClient<$Result.GetResult<Prisma.$AvailabilityPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Availabilities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvailabilityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Availabilities
     * const availabilities = await prisma.availability.findMany()
     * 
     * // Get first 10 Availabilities
     * const availabilities = await prisma.availability.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const availabilityWithIdOnly = await prisma.availability.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AvailabilityFindManyArgs>(args?: SelectSubset<T, AvailabilityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AvailabilityPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Availability.
     * @param {AvailabilityCreateArgs} args - Arguments to create a Availability.
     * @example
     * // Create one Availability
     * const Availability = await prisma.availability.create({
     *   data: {
     *     // ... data to create a Availability
     *   }
     * })
     * 
     */
    create<T extends AvailabilityCreateArgs>(args: SelectSubset<T, AvailabilityCreateArgs<ExtArgs>>): Prisma__AvailabilityClient<$Result.GetResult<Prisma.$AvailabilityPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Availabilities.
     * @param {AvailabilityCreateManyArgs} args - Arguments to create many Availabilities.
     * @example
     * // Create many Availabilities
     * const availability = await prisma.availability.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AvailabilityCreateManyArgs>(args?: SelectSubset<T, AvailabilityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Availability.
     * @param {AvailabilityDeleteArgs} args - Arguments to delete one Availability.
     * @example
     * // Delete one Availability
     * const Availability = await prisma.availability.delete({
     *   where: {
     *     // ... filter to delete one Availability
     *   }
     * })
     * 
     */
    delete<T extends AvailabilityDeleteArgs>(args: SelectSubset<T, AvailabilityDeleteArgs<ExtArgs>>): Prisma__AvailabilityClient<$Result.GetResult<Prisma.$AvailabilityPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Availability.
     * @param {AvailabilityUpdateArgs} args - Arguments to update one Availability.
     * @example
     * // Update one Availability
     * const availability = await prisma.availability.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AvailabilityUpdateArgs>(args: SelectSubset<T, AvailabilityUpdateArgs<ExtArgs>>): Prisma__AvailabilityClient<$Result.GetResult<Prisma.$AvailabilityPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Availabilities.
     * @param {AvailabilityDeleteManyArgs} args - Arguments to filter Availabilities to delete.
     * @example
     * // Delete a few Availabilities
     * const { count } = await prisma.availability.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AvailabilityDeleteManyArgs>(args?: SelectSubset<T, AvailabilityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Availabilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvailabilityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Availabilities
     * const availability = await prisma.availability.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AvailabilityUpdateManyArgs>(args: SelectSubset<T, AvailabilityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Availability.
     * @param {AvailabilityUpsertArgs} args - Arguments to update or create a Availability.
     * @example
     * // Update or create a Availability
     * const availability = await prisma.availability.upsert({
     *   create: {
     *     // ... data to create a Availability
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Availability we want to update
     *   }
     * })
     */
    upsert<T extends AvailabilityUpsertArgs>(args: SelectSubset<T, AvailabilityUpsertArgs<ExtArgs>>): Prisma__AvailabilityClient<$Result.GetResult<Prisma.$AvailabilityPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Availabilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvailabilityCountArgs} args - Arguments to filter Availabilities to count.
     * @example
     * // Count the number of Availabilities
     * const count = await prisma.availability.count({
     *   where: {
     *     // ... the filter for the Availabilities we want to count
     *   }
     * })
    **/
    count<T extends AvailabilityCountArgs>(
      args?: Subset<T, AvailabilityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AvailabilityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Availability.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvailabilityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AvailabilityAggregateArgs>(args: Subset<T, AvailabilityAggregateArgs>): Prisma.PrismaPromise<GetAvailabilityAggregateType<T>>

    /**
     * Group by Availability.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvailabilityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AvailabilityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AvailabilityGroupByArgs['orderBy'] }
        : { orderBy?: AvailabilityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AvailabilityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAvailabilityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Availability model
   */
  readonly fields: AvailabilityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Availability.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AvailabilityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    porter<T extends PorterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PorterDefaultArgs<ExtArgs>>): Prisma__PorterClient<$Result.GetResult<Prisma.$PorterPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Availability model
   */ 
  interface AvailabilityFieldRefs {
    readonly id: FieldRef<"Availability", 'String'>
    readonly porterId: FieldRef<"Availability", 'String'>
    readonly startDatetime: FieldRef<"Availability", 'DateTime'>
    readonly endDatetime: FieldRef<"Availability", 'DateTime'>
    readonly status: FieldRef<"Availability", 'AvailabilityStatus'>
    readonly reason: FieldRef<"Availability", 'String'>
    readonly createdAt: FieldRef<"Availability", 'DateTime'>
    readonly updatedAt: FieldRef<"Availability", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Availability findUnique
   */
  export type AvailabilityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Availability
     */
    select?: AvailabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityInclude<ExtArgs> | null
    /**
     * Filter, which Availability to fetch.
     */
    where: AvailabilityWhereUniqueInput
  }

  /**
   * Availability findUniqueOrThrow
   */
  export type AvailabilityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Availability
     */
    select?: AvailabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityInclude<ExtArgs> | null
    /**
     * Filter, which Availability to fetch.
     */
    where: AvailabilityWhereUniqueInput
  }

  /**
   * Availability findFirst
   */
  export type AvailabilityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Availability
     */
    select?: AvailabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityInclude<ExtArgs> | null
    /**
     * Filter, which Availability to fetch.
     */
    where?: AvailabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Availabilities to fetch.
     */
    orderBy?: AvailabilityOrderByWithRelationInput | AvailabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Availabilities.
     */
    cursor?: AvailabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Availabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Availabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Availabilities.
     */
    distinct?: AvailabilityScalarFieldEnum | AvailabilityScalarFieldEnum[]
  }

  /**
   * Availability findFirstOrThrow
   */
  export type AvailabilityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Availability
     */
    select?: AvailabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityInclude<ExtArgs> | null
    /**
     * Filter, which Availability to fetch.
     */
    where?: AvailabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Availabilities to fetch.
     */
    orderBy?: AvailabilityOrderByWithRelationInput | AvailabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Availabilities.
     */
    cursor?: AvailabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Availabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Availabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Availabilities.
     */
    distinct?: AvailabilityScalarFieldEnum | AvailabilityScalarFieldEnum[]
  }

  /**
   * Availability findMany
   */
  export type AvailabilityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Availability
     */
    select?: AvailabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityInclude<ExtArgs> | null
    /**
     * Filter, which Availabilities to fetch.
     */
    where?: AvailabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Availabilities to fetch.
     */
    orderBy?: AvailabilityOrderByWithRelationInput | AvailabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Availabilities.
     */
    cursor?: AvailabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Availabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Availabilities.
     */
    skip?: number
    distinct?: AvailabilityScalarFieldEnum | AvailabilityScalarFieldEnum[]
  }

  /**
   * Availability create
   */
  export type AvailabilityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Availability
     */
    select?: AvailabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityInclude<ExtArgs> | null
    /**
     * The data needed to create a Availability.
     */
    data: XOR<AvailabilityCreateInput, AvailabilityUncheckedCreateInput>
  }

  /**
   * Availability createMany
   */
  export type AvailabilityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Availabilities.
     */
    data: AvailabilityCreateManyInput | AvailabilityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Availability update
   */
  export type AvailabilityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Availability
     */
    select?: AvailabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityInclude<ExtArgs> | null
    /**
     * The data needed to update a Availability.
     */
    data: XOR<AvailabilityUpdateInput, AvailabilityUncheckedUpdateInput>
    /**
     * Choose, which Availability to update.
     */
    where: AvailabilityWhereUniqueInput
  }

  /**
   * Availability updateMany
   */
  export type AvailabilityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Availabilities.
     */
    data: XOR<AvailabilityUpdateManyMutationInput, AvailabilityUncheckedUpdateManyInput>
    /**
     * Filter which Availabilities to update
     */
    where?: AvailabilityWhereInput
  }

  /**
   * Availability upsert
   */
  export type AvailabilityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Availability
     */
    select?: AvailabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityInclude<ExtArgs> | null
    /**
     * The filter to search for the Availability to update in case it exists.
     */
    where: AvailabilityWhereUniqueInput
    /**
     * In case the Availability found by the `where` argument doesn't exist, create a new Availability with this data.
     */
    create: XOR<AvailabilityCreateInput, AvailabilityUncheckedCreateInput>
    /**
     * In case the Availability was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AvailabilityUpdateInput, AvailabilityUncheckedUpdateInput>
  }

  /**
   * Availability delete
   */
  export type AvailabilityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Availability
     */
    select?: AvailabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityInclude<ExtArgs> | null
    /**
     * Filter which Availability to delete.
     */
    where: AvailabilityWhereUniqueInput
  }

  /**
   * Availability deleteMany
   */
  export type AvailabilityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Availabilities to delete
     */
    where?: AvailabilityWhereInput
  }

  /**
   * Availability without action
   */
  export type AvailabilityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Availability
     */
    select?: AvailabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityInclude<ExtArgs> | null
  }


  /**
   * Model SystemSetting
   */

  export type AggregateSystemSetting = {
    _count: SystemSettingCountAggregateOutputType | null
    _min: SystemSettingMinAggregateOutputType | null
    _max: SystemSettingMaxAggregateOutputType | null
  }

  export type SystemSettingMinAggregateOutputType = {
    settingKey: string | null
    settingValue: string | null
    description: string | null
    updatedAt: Date | null
  }

  export type SystemSettingMaxAggregateOutputType = {
    settingKey: string | null
    settingValue: string | null
    description: string | null
    updatedAt: Date | null
  }

  export type SystemSettingCountAggregateOutputType = {
    settingKey: number
    settingValue: number
    description: number
    updatedAt: number
    _all: number
  }


  export type SystemSettingMinAggregateInputType = {
    settingKey?: true
    settingValue?: true
    description?: true
    updatedAt?: true
  }

  export type SystemSettingMaxAggregateInputType = {
    settingKey?: true
    settingValue?: true
    description?: true
    updatedAt?: true
  }

  export type SystemSettingCountAggregateInputType = {
    settingKey?: true
    settingValue?: true
    description?: true
    updatedAt?: true
    _all?: true
  }

  export type SystemSettingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemSetting to aggregate.
     */
    where?: SystemSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingOrderByWithRelationInput | SystemSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemSettings
    **/
    _count?: true | SystemSettingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemSettingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemSettingMaxAggregateInputType
  }

  export type GetSystemSettingAggregateType<T extends SystemSettingAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemSetting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemSetting[P]>
      : GetScalarType<T[P], AggregateSystemSetting[P]>
  }




  export type SystemSettingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemSettingWhereInput
    orderBy?: SystemSettingOrderByWithAggregationInput | SystemSettingOrderByWithAggregationInput[]
    by: SystemSettingScalarFieldEnum[] | SystemSettingScalarFieldEnum
    having?: SystemSettingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemSettingCountAggregateInputType | true
    _min?: SystemSettingMinAggregateInputType
    _max?: SystemSettingMaxAggregateInputType
  }

  export type SystemSettingGroupByOutputType = {
    settingKey: string
    settingValue: string
    description: string | null
    updatedAt: Date
    _count: SystemSettingCountAggregateOutputType | null
    _min: SystemSettingMinAggregateOutputType | null
    _max: SystemSettingMaxAggregateOutputType | null
  }

  type GetSystemSettingGroupByPayload<T extends SystemSettingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemSettingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemSettingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemSettingGroupByOutputType[P]>
            : GetScalarType<T[P], SystemSettingGroupByOutputType[P]>
        }
      >
    >


  export type SystemSettingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    settingKey?: boolean
    settingValue?: boolean
    description?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemSetting"]>


  export type SystemSettingSelectScalar = {
    settingKey?: boolean
    settingValue?: boolean
    description?: boolean
    updatedAt?: boolean
  }


  export type $SystemSettingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemSetting"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      settingKey: string
      settingValue: string
      description: string | null
      updatedAt: Date
    }, ExtArgs["result"]["systemSetting"]>
    composites: {}
  }

  type SystemSettingGetPayload<S extends boolean | null | undefined | SystemSettingDefaultArgs> = $Result.GetResult<Prisma.$SystemSettingPayload, S>

  type SystemSettingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SystemSettingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SystemSettingCountAggregateInputType | true
    }

  export interface SystemSettingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemSetting'], meta: { name: 'SystemSetting' } }
    /**
     * Find zero or one SystemSetting that matches the filter.
     * @param {SystemSettingFindUniqueArgs} args - Arguments to find a SystemSetting
     * @example
     * // Get one SystemSetting
     * const systemSetting = await prisma.systemSetting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemSettingFindUniqueArgs>(args: SelectSubset<T, SystemSettingFindUniqueArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SystemSetting that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SystemSettingFindUniqueOrThrowArgs} args - Arguments to find a SystemSetting
     * @example
     * // Get one SystemSetting
     * const systemSetting = await prisma.systemSetting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemSettingFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemSettingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SystemSetting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingFindFirstArgs} args - Arguments to find a SystemSetting
     * @example
     * // Get one SystemSetting
     * const systemSetting = await prisma.systemSetting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemSettingFindFirstArgs>(args?: SelectSubset<T, SystemSettingFindFirstArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SystemSetting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingFindFirstOrThrowArgs} args - Arguments to find a SystemSetting
     * @example
     * // Get one SystemSetting
     * const systemSetting = await prisma.systemSetting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemSettingFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemSettingFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SystemSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemSettings
     * const systemSettings = await prisma.systemSetting.findMany()
     * 
     * // Get first 10 SystemSettings
     * const systemSettings = await prisma.systemSetting.findMany({ take: 10 })
     * 
     * // Only select the `settingKey`
     * const systemSettingWithSettingKeyOnly = await prisma.systemSetting.findMany({ select: { settingKey: true } })
     * 
     */
    findMany<T extends SystemSettingFindManyArgs>(args?: SelectSubset<T, SystemSettingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SystemSetting.
     * @param {SystemSettingCreateArgs} args - Arguments to create a SystemSetting.
     * @example
     * // Create one SystemSetting
     * const SystemSetting = await prisma.systemSetting.create({
     *   data: {
     *     // ... data to create a SystemSetting
     *   }
     * })
     * 
     */
    create<T extends SystemSettingCreateArgs>(args: SelectSubset<T, SystemSettingCreateArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SystemSettings.
     * @param {SystemSettingCreateManyArgs} args - Arguments to create many SystemSettings.
     * @example
     * // Create many SystemSettings
     * const systemSetting = await prisma.systemSetting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemSettingCreateManyArgs>(args?: SelectSubset<T, SystemSettingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SystemSetting.
     * @param {SystemSettingDeleteArgs} args - Arguments to delete one SystemSetting.
     * @example
     * // Delete one SystemSetting
     * const SystemSetting = await prisma.systemSetting.delete({
     *   where: {
     *     // ... filter to delete one SystemSetting
     *   }
     * })
     * 
     */
    delete<T extends SystemSettingDeleteArgs>(args: SelectSubset<T, SystemSettingDeleteArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SystemSetting.
     * @param {SystemSettingUpdateArgs} args - Arguments to update one SystemSetting.
     * @example
     * // Update one SystemSetting
     * const systemSetting = await prisma.systemSetting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemSettingUpdateArgs>(args: SelectSubset<T, SystemSettingUpdateArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SystemSettings.
     * @param {SystemSettingDeleteManyArgs} args - Arguments to filter SystemSettings to delete.
     * @example
     * // Delete a few SystemSettings
     * const { count } = await prisma.systemSetting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemSettingDeleteManyArgs>(args?: SelectSubset<T, SystemSettingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemSettings
     * const systemSetting = await prisma.systemSetting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemSettingUpdateManyArgs>(args: SelectSubset<T, SystemSettingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SystemSetting.
     * @param {SystemSettingUpsertArgs} args - Arguments to update or create a SystemSetting.
     * @example
     * // Update or create a SystemSetting
     * const systemSetting = await prisma.systemSetting.upsert({
     *   create: {
     *     // ... data to create a SystemSetting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemSetting we want to update
     *   }
     * })
     */
    upsert<T extends SystemSettingUpsertArgs>(args: SelectSubset<T, SystemSettingUpsertArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingCountArgs} args - Arguments to filter SystemSettings to count.
     * @example
     * // Count the number of SystemSettings
     * const count = await prisma.systemSetting.count({
     *   where: {
     *     // ... the filter for the SystemSettings we want to count
     *   }
     * })
    **/
    count<T extends SystemSettingCountArgs>(
      args?: Subset<T, SystemSettingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemSettingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemSettingAggregateArgs>(args: Subset<T, SystemSettingAggregateArgs>): Prisma.PrismaPromise<GetSystemSettingAggregateType<T>>

    /**
     * Group by SystemSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemSettingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemSettingGroupByArgs['orderBy'] }
        : { orderBy?: SystemSettingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemSettingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemSettingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemSetting model
   */
  readonly fields: SystemSettingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemSetting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemSettingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemSetting model
   */ 
  interface SystemSettingFieldRefs {
    readonly settingKey: FieldRef<"SystemSetting", 'String'>
    readonly settingValue: FieldRef<"SystemSetting", 'String'>
    readonly description: FieldRef<"SystemSetting", 'String'>
    readonly updatedAt: FieldRef<"SystemSetting", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SystemSetting findUnique
   */
  export type SystemSettingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Filter, which SystemSetting to fetch.
     */
    where: SystemSettingWhereUniqueInput
  }

  /**
   * SystemSetting findUniqueOrThrow
   */
  export type SystemSettingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Filter, which SystemSetting to fetch.
     */
    where: SystemSettingWhereUniqueInput
  }

  /**
   * SystemSetting findFirst
   */
  export type SystemSettingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Filter, which SystemSetting to fetch.
     */
    where?: SystemSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingOrderByWithRelationInput | SystemSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemSettings.
     */
    cursor?: SystemSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemSettings.
     */
    distinct?: SystemSettingScalarFieldEnum | SystemSettingScalarFieldEnum[]
  }

  /**
   * SystemSetting findFirstOrThrow
   */
  export type SystemSettingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Filter, which SystemSetting to fetch.
     */
    where?: SystemSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingOrderByWithRelationInput | SystemSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemSettings.
     */
    cursor?: SystemSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemSettings.
     */
    distinct?: SystemSettingScalarFieldEnum | SystemSettingScalarFieldEnum[]
  }

  /**
   * SystemSetting findMany
   */
  export type SystemSettingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Filter, which SystemSettings to fetch.
     */
    where?: SystemSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingOrderByWithRelationInput | SystemSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemSettings.
     */
    cursor?: SystemSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    distinct?: SystemSettingScalarFieldEnum | SystemSettingScalarFieldEnum[]
  }

  /**
   * SystemSetting create
   */
  export type SystemSettingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * The data needed to create a SystemSetting.
     */
    data: XOR<SystemSettingCreateInput, SystemSettingUncheckedCreateInput>
  }

  /**
   * SystemSetting createMany
   */
  export type SystemSettingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemSettings.
     */
    data: SystemSettingCreateManyInput | SystemSettingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemSetting update
   */
  export type SystemSettingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * The data needed to update a SystemSetting.
     */
    data: XOR<SystemSettingUpdateInput, SystemSettingUncheckedUpdateInput>
    /**
     * Choose, which SystemSetting to update.
     */
    where: SystemSettingWhereUniqueInput
  }

  /**
   * SystemSetting updateMany
   */
  export type SystemSettingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemSettings.
     */
    data: XOR<SystemSettingUpdateManyMutationInput, SystemSettingUncheckedUpdateManyInput>
    /**
     * Filter which SystemSettings to update
     */
    where?: SystemSettingWhereInput
  }

  /**
   * SystemSetting upsert
   */
  export type SystemSettingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * The filter to search for the SystemSetting to update in case it exists.
     */
    where: SystemSettingWhereUniqueInput
    /**
     * In case the SystemSetting found by the `where` argument doesn't exist, create a new SystemSetting with this data.
     */
    create: XOR<SystemSettingCreateInput, SystemSettingUncheckedCreateInput>
    /**
     * In case the SystemSetting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemSettingUpdateInput, SystemSettingUncheckedUpdateInput>
  }

  /**
   * SystemSetting delete
   */
  export type SystemSettingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Filter which SystemSetting to delete.
     */
    where: SystemSettingWhereUniqueInput
  }

  /**
   * SystemSetting deleteMany
   */
  export type SystemSettingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemSettings to delete
     */
    where?: SystemSettingWhereInput
  }

  /**
   * SystemSetting without action
   */
  export type SystemSettingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const BuildingScalarFieldEnum: {
    id: 'id',
    name: 'name',
    location: 'location',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BuildingScalarFieldEnum = (typeof BuildingScalarFieldEnum)[keyof typeof BuildingScalarFieldEnum]


  export const DepartmentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    buildingId: 'buildingId',
    scheduleId: 'scheduleId',
    description: 'description',
    is247: 'is247',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DepartmentScalarFieldEnum = (typeof DepartmentScalarFieldEnum)[keyof typeof DepartmentScalarFieldEnum]


  export const ServiceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    departmentId: 'departmentId',
    description: 'description',
    isActive: 'isActive',
    inheritsSchedule: 'inheritsSchedule',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ServiceScalarFieldEnum = (typeof ServiceScalarFieldEnum)[keyof typeof ServiceScalarFieldEnum]


  export const PorterScalarFieldEnum: {
    id: 'id',
    name: 'name',
    contractType: 'contractType',
    shiftId: 'shiftId',
    weeklyMinHours: 'weeklyMinHours',
    contractedHours: 'contractedHours',
    regularDepartmentId: 'regularDepartmentId',
    porterType: 'porterType',
    countsTowardsStaffing: 'countsTowardsStaffing',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PorterScalarFieldEnum = (typeof PorterScalarFieldEnum)[keyof typeof PorterScalarFieldEnum]


  export const ShiftScalarFieldEnum: {
    id: 'id',
    name: 'name',
    patternId: 'patternId',
    shiftMode: 'shiftMode',
    ident: 'ident',
    daysOn: 'daysOn',
    daysOff: 'daysOff',
    offsetDays: 'offsetDays',
    groundZero: 'groundZero',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ShiftScalarFieldEnum = (typeof ShiftScalarFieldEnum)[keyof typeof ShiftScalarFieldEnum]


  export const ShiftPatternScalarFieldEnum: {
    id: 'id',
    name: 'name',
    patternJson: 'patternJson',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ShiftPatternScalarFieldEnum = (typeof ShiftPatternScalarFieldEnum)[keyof typeof ShiftPatternScalarFieldEnum]


  export const DepartmentScheduleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    patternId: 'patternId',
    description: 'description',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DepartmentScheduleScalarFieldEnum = (typeof DepartmentScheduleScalarFieldEnum)[keyof typeof DepartmentScheduleScalarFieldEnum]


  export const DepartmentSchedulePeriodScalarFieldEnum: {
    id: 'id',
    scheduleId: 'scheduleId',
    dayOfWeek: 'dayOfWeek',
    openTime: 'openTime',
    closeTime: 'closeTime',
    requiredPorters: 'requiredPorters'
  };

  export type DepartmentSchedulePeriodScalarFieldEnum = (typeof DepartmentSchedulePeriodScalarFieldEnum)[keyof typeof DepartmentSchedulePeriodScalarFieldEnum]


  export const CapabilityScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CapabilityScalarFieldEnum = (typeof CapabilityScalarFieldEnum)[keyof typeof CapabilityScalarFieldEnum]


  export const PorterCapabilityScalarFieldEnum: {
    porterId: 'porterId',
    capabilityId: 'capabilityId',
    expiryDate: 'expiryDate',
    createdAt: 'createdAt'
  };

  export type PorterCapabilityScalarFieldEnum = (typeof PorterCapabilityScalarFieldEnum)[keyof typeof PorterCapabilityScalarFieldEnum]


  export const DepartmentCapabilityScalarFieldEnum: {
    departmentId: 'departmentId',
    capabilityId: 'capabilityId',
    requiredLevel: 'requiredLevel'
  };

  export type DepartmentCapabilityScalarFieldEnum = (typeof DepartmentCapabilityScalarFieldEnum)[keyof typeof DepartmentCapabilityScalarFieldEnum]


  export const ServiceCapabilityScalarFieldEnum: {
    serviceId: 'serviceId',
    capabilityId: 'capabilityId',
    requiredLevel: 'requiredLevel'
  };

  export type ServiceCapabilityScalarFieldEnum = (typeof ServiceCapabilityScalarFieldEnum)[keyof typeof ServiceCapabilityScalarFieldEnum]


  export const AllocationScalarFieldEnum: {
    id: 'id',
    porterId: 'porterId',
    departmentId: 'departmentId',
    serviceId: 'serviceId',
    startDatetime: 'startDatetime',
    endDatetime: 'endDatetime',
    type: 'type',
    reason: 'reason',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AllocationScalarFieldEnum = (typeof AllocationScalarFieldEnum)[keyof typeof AllocationScalarFieldEnum]


  export const AvailabilityScalarFieldEnum: {
    id: 'id',
    porterId: 'porterId',
    startDatetime: 'startDatetime',
    endDatetime: 'endDatetime',
    status: 'status',
    reason: 'reason',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AvailabilityScalarFieldEnum = (typeof AvailabilityScalarFieldEnum)[keyof typeof AvailabilityScalarFieldEnum]


  export const SystemSettingScalarFieldEnum: {
    settingKey: 'settingKey',
    settingValue: 'settingValue',
    description: 'description',
    updatedAt: 'updatedAt'
  };

  export type SystemSettingScalarFieldEnum = (typeof SystemSettingScalarFieldEnum)[keyof typeof SystemSettingScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'ContractType'
   */
  export type EnumContractTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContractType'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'PorterType'
   */
  export type EnumPorterTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PorterType'>
    


  /**
   * Reference to a field of type 'ShiftMode'
   */
  export type EnumShiftModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ShiftMode'>
    


  /**
   * Reference to a field of type 'DayOfWeek'
   */
  export type EnumDayOfWeekFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DayOfWeek'>
    


  /**
   * Reference to a field of type 'RequiredLevel'
   */
  export type EnumRequiredLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RequiredLevel'>
    


  /**
   * Reference to a field of type 'AllocationType'
   */
  export type EnumAllocationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AllocationType'>
    


  /**
   * Reference to a field of type 'AvailabilityStatus'
   */
  export type EnumAvailabilityStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AvailabilityStatus'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type BuildingWhereInput = {
    AND?: BuildingWhereInput | BuildingWhereInput[]
    OR?: BuildingWhereInput[]
    NOT?: BuildingWhereInput | BuildingWhereInput[]
    id?: StringFilter<"Building"> | string
    name?: StringFilter<"Building"> | string
    location?: StringNullableFilter<"Building"> | string | null
    description?: StringNullableFilter<"Building"> | string | null
    createdAt?: DateTimeFilter<"Building"> | Date | string
    updatedAt?: DateTimeFilter<"Building"> | Date | string
    departments?: DepartmentListRelationFilter
  }

  export type BuildingOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    departments?: DepartmentOrderByRelationAggregateInput
  }

  export type BuildingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BuildingWhereInput | BuildingWhereInput[]
    OR?: BuildingWhereInput[]
    NOT?: BuildingWhereInput | BuildingWhereInput[]
    name?: StringFilter<"Building"> | string
    location?: StringNullableFilter<"Building"> | string | null
    description?: StringNullableFilter<"Building"> | string | null
    createdAt?: DateTimeFilter<"Building"> | Date | string
    updatedAt?: DateTimeFilter<"Building"> | Date | string
    departments?: DepartmentListRelationFilter
  }, "id">

  export type BuildingOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BuildingCountOrderByAggregateInput
    _max?: BuildingMaxOrderByAggregateInput
    _min?: BuildingMinOrderByAggregateInput
  }

  export type BuildingScalarWhereWithAggregatesInput = {
    AND?: BuildingScalarWhereWithAggregatesInput | BuildingScalarWhereWithAggregatesInput[]
    OR?: BuildingScalarWhereWithAggregatesInput[]
    NOT?: BuildingScalarWhereWithAggregatesInput | BuildingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Building"> | string
    name?: StringWithAggregatesFilter<"Building"> | string
    location?: StringNullableWithAggregatesFilter<"Building"> | string | null
    description?: StringNullableWithAggregatesFilter<"Building"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Building"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Building"> | Date | string
  }

  export type DepartmentWhereInput = {
    AND?: DepartmentWhereInput | DepartmentWhereInput[]
    OR?: DepartmentWhereInput[]
    NOT?: DepartmentWhereInput | DepartmentWhereInput[]
    id?: StringFilter<"Department"> | string
    name?: StringFilter<"Department"> | string
    buildingId?: StringFilter<"Department"> | string
    scheduleId?: StringNullableFilter<"Department"> | string | null
    description?: StringNullableFilter<"Department"> | string | null
    is247?: BoolFilter<"Department"> | boolean
    createdAt?: DateTimeFilter<"Department"> | Date | string
    updatedAt?: DateTimeFilter<"Department"> | Date | string
    building?: XOR<BuildingRelationFilter, BuildingWhereInput>
    schedule?: XOR<DepartmentScheduleNullableRelationFilter, DepartmentScheduleWhereInput> | null
    services?: ServiceListRelationFilter
    porters?: PorterListRelationFilter
    allocations?: AllocationListRelationFilter
    departmentCapabilities?: DepartmentCapabilityListRelationFilter
  }

  export type DepartmentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    buildingId?: SortOrder
    scheduleId?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    is247?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    building?: BuildingOrderByWithRelationInput
    schedule?: DepartmentScheduleOrderByWithRelationInput
    services?: ServiceOrderByRelationAggregateInput
    porters?: PorterOrderByRelationAggregateInput
    allocations?: AllocationOrderByRelationAggregateInput
    departmentCapabilities?: DepartmentCapabilityOrderByRelationAggregateInput
  }

  export type DepartmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DepartmentWhereInput | DepartmentWhereInput[]
    OR?: DepartmentWhereInput[]
    NOT?: DepartmentWhereInput | DepartmentWhereInput[]
    name?: StringFilter<"Department"> | string
    buildingId?: StringFilter<"Department"> | string
    scheduleId?: StringNullableFilter<"Department"> | string | null
    description?: StringNullableFilter<"Department"> | string | null
    is247?: BoolFilter<"Department"> | boolean
    createdAt?: DateTimeFilter<"Department"> | Date | string
    updatedAt?: DateTimeFilter<"Department"> | Date | string
    building?: XOR<BuildingRelationFilter, BuildingWhereInput>
    schedule?: XOR<DepartmentScheduleNullableRelationFilter, DepartmentScheduleWhereInput> | null
    services?: ServiceListRelationFilter
    porters?: PorterListRelationFilter
    allocations?: AllocationListRelationFilter
    departmentCapabilities?: DepartmentCapabilityListRelationFilter
  }, "id">

  export type DepartmentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    buildingId?: SortOrder
    scheduleId?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    is247?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DepartmentCountOrderByAggregateInput
    _max?: DepartmentMaxOrderByAggregateInput
    _min?: DepartmentMinOrderByAggregateInput
  }

  export type DepartmentScalarWhereWithAggregatesInput = {
    AND?: DepartmentScalarWhereWithAggregatesInput | DepartmentScalarWhereWithAggregatesInput[]
    OR?: DepartmentScalarWhereWithAggregatesInput[]
    NOT?: DepartmentScalarWhereWithAggregatesInput | DepartmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Department"> | string
    name?: StringWithAggregatesFilter<"Department"> | string
    buildingId?: StringWithAggregatesFilter<"Department"> | string
    scheduleId?: StringNullableWithAggregatesFilter<"Department"> | string | null
    description?: StringNullableWithAggregatesFilter<"Department"> | string | null
    is247?: BoolWithAggregatesFilter<"Department"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Department"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Department"> | Date | string
  }

  export type ServiceWhereInput = {
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    id?: StringFilter<"Service"> | string
    name?: StringFilter<"Service"> | string
    departmentId?: StringFilter<"Service"> | string
    description?: StringNullableFilter<"Service"> | string | null
    isActive?: BoolFilter<"Service"> | boolean
    inheritsSchedule?: BoolFilter<"Service"> | boolean
    createdAt?: DateTimeFilter<"Service"> | Date | string
    updatedAt?: DateTimeFilter<"Service"> | Date | string
    department?: XOR<DepartmentRelationFilter, DepartmentWhereInput>
    allocations?: AllocationListRelationFilter
    serviceCapabilities?: ServiceCapabilityListRelationFilter
  }

  export type ServiceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    departmentId?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    inheritsSchedule?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    department?: DepartmentOrderByWithRelationInput
    allocations?: AllocationOrderByRelationAggregateInput
    serviceCapabilities?: ServiceCapabilityOrderByRelationAggregateInput
  }

  export type ServiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    name?: StringFilter<"Service"> | string
    departmentId?: StringFilter<"Service"> | string
    description?: StringNullableFilter<"Service"> | string | null
    isActive?: BoolFilter<"Service"> | boolean
    inheritsSchedule?: BoolFilter<"Service"> | boolean
    createdAt?: DateTimeFilter<"Service"> | Date | string
    updatedAt?: DateTimeFilter<"Service"> | Date | string
    department?: XOR<DepartmentRelationFilter, DepartmentWhereInput>
    allocations?: AllocationListRelationFilter
    serviceCapabilities?: ServiceCapabilityListRelationFilter
  }, "id">

  export type ServiceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    departmentId?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    inheritsSchedule?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ServiceCountOrderByAggregateInput
    _max?: ServiceMaxOrderByAggregateInput
    _min?: ServiceMinOrderByAggregateInput
  }

  export type ServiceScalarWhereWithAggregatesInput = {
    AND?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    OR?: ServiceScalarWhereWithAggregatesInput[]
    NOT?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Service"> | string
    name?: StringWithAggregatesFilter<"Service"> | string
    departmentId?: StringWithAggregatesFilter<"Service"> | string
    description?: StringNullableWithAggregatesFilter<"Service"> | string | null
    isActive?: BoolWithAggregatesFilter<"Service"> | boolean
    inheritsSchedule?: BoolWithAggregatesFilter<"Service"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Service"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Service"> | Date | string
  }

  export type PorterWhereInput = {
    AND?: PorterWhereInput | PorterWhereInput[]
    OR?: PorterWhereInput[]
    NOT?: PorterWhereInput | PorterWhereInput[]
    id?: StringFilter<"Porter"> | string
    name?: StringFilter<"Porter"> | string
    contractType?: EnumContractTypeFilter<"Porter"> | $Enums.ContractType
    shiftId?: StringNullableFilter<"Porter"> | string | null
    weeklyMinHours?: IntNullableFilter<"Porter"> | number | null
    contractedHours?: IntNullableFilter<"Porter"> | number | null
    regularDepartmentId?: StringNullableFilter<"Porter"> | string | null
    porterType?: EnumPorterTypeFilter<"Porter"> | $Enums.PorterType
    countsTowardsStaffing?: BoolFilter<"Porter"> | boolean
    createdAt?: DateTimeFilter<"Porter"> | Date | string
    updatedAt?: DateTimeFilter<"Porter"> | Date | string
    shift?: XOR<ShiftNullableRelationFilter, ShiftWhereInput> | null
    regularDepartment?: XOR<DepartmentNullableRelationFilter, DepartmentWhereInput> | null
    allocations?: AllocationListRelationFilter
    availability?: AvailabilityListRelationFilter
    porterCapabilities?: PorterCapabilityListRelationFilter
  }

  export type PorterOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    contractType?: SortOrder
    shiftId?: SortOrderInput | SortOrder
    weeklyMinHours?: SortOrderInput | SortOrder
    contractedHours?: SortOrderInput | SortOrder
    regularDepartmentId?: SortOrderInput | SortOrder
    porterType?: SortOrder
    countsTowardsStaffing?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    shift?: ShiftOrderByWithRelationInput
    regularDepartment?: DepartmentOrderByWithRelationInput
    allocations?: AllocationOrderByRelationAggregateInput
    availability?: AvailabilityOrderByRelationAggregateInput
    porterCapabilities?: PorterCapabilityOrderByRelationAggregateInput
  }

  export type PorterWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PorterWhereInput | PorterWhereInput[]
    OR?: PorterWhereInput[]
    NOT?: PorterWhereInput | PorterWhereInput[]
    name?: StringFilter<"Porter"> | string
    contractType?: EnumContractTypeFilter<"Porter"> | $Enums.ContractType
    shiftId?: StringNullableFilter<"Porter"> | string | null
    weeklyMinHours?: IntNullableFilter<"Porter"> | number | null
    contractedHours?: IntNullableFilter<"Porter"> | number | null
    regularDepartmentId?: StringNullableFilter<"Porter"> | string | null
    porterType?: EnumPorterTypeFilter<"Porter"> | $Enums.PorterType
    countsTowardsStaffing?: BoolFilter<"Porter"> | boolean
    createdAt?: DateTimeFilter<"Porter"> | Date | string
    updatedAt?: DateTimeFilter<"Porter"> | Date | string
    shift?: XOR<ShiftNullableRelationFilter, ShiftWhereInput> | null
    regularDepartment?: XOR<DepartmentNullableRelationFilter, DepartmentWhereInput> | null
    allocations?: AllocationListRelationFilter
    availability?: AvailabilityListRelationFilter
    porterCapabilities?: PorterCapabilityListRelationFilter
  }, "id">

  export type PorterOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    contractType?: SortOrder
    shiftId?: SortOrderInput | SortOrder
    weeklyMinHours?: SortOrderInput | SortOrder
    contractedHours?: SortOrderInput | SortOrder
    regularDepartmentId?: SortOrderInput | SortOrder
    porterType?: SortOrder
    countsTowardsStaffing?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PorterCountOrderByAggregateInput
    _avg?: PorterAvgOrderByAggregateInput
    _max?: PorterMaxOrderByAggregateInput
    _min?: PorterMinOrderByAggregateInput
    _sum?: PorterSumOrderByAggregateInput
  }

  export type PorterScalarWhereWithAggregatesInput = {
    AND?: PorterScalarWhereWithAggregatesInput | PorterScalarWhereWithAggregatesInput[]
    OR?: PorterScalarWhereWithAggregatesInput[]
    NOT?: PorterScalarWhereWithAggregatesInput | PorterScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Porter"> | string
    name?: StringWithAggregatesFilter<"Porter"> | string
    contractType?: EnumContractTypeWithAggregatesFilter<"Porter"> | $Enums.ContractType
    shiftId?: StringNullableWithAggregatesFilter<"Porter"> | string | null
    weeklyMinHours?: IntNullableWithAggregatesFilter<"Porter"> | number | null
    contractedHours?: IntNullableWithAggregatesFilter<"Porter"> | number | null
    regularDepartmentId?: StringNullableWithAggregatesFilter<"Porter"> | string | null
    porterType?: EnumPorterTypeWithAggregatesFilter<"Porter"> | $Enums.PorterType
    countsTowardsStaffing?: BoolWithAggregatesFilter<"Porter"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Porter"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Porter"> | Date | string
  }

  export type ShiftWhereInput = {
    AND?: ShiftWhereInput | ShiftWhereInput[]
    OR?: ShiftWhereInput[]
    NOT?: ShiftWhereInput | ShiftWhereInput[]
    id?: StringFilter<"Shift"> | string
    name?: StringFilter<"Shift"> | string
    patternId?: StringFilter<"Shift"> | string
    shiftMode?: EnumShiftModeFilter<"Shift"> | $Enums.ShiftMode
    ident?: StringFilter<"Shift"> | string
    daysOn?: IntFilter<"Shift"> | number
    daysOff?: IntFilter<"Shift"> | number
    offsetDays?: IntFilter<"Shift"> | number
    groundZero?: DateTimeFilter<"Shift"> | Date | string
    createdAt?: DateTimeFilter<"Shift"> | Date | string
    updatedAt?: DateTimeFilter<"Shift"> | Date | string
    pattern?: XOR<ShiftPatternRelationFilter, ShiftPatternWhereInput>
    porters?: PorterListRelationFilter
  }

  export type ShiftOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    patternId?: SortOrder
    shiftMode?: SortOrder
    ident?: SortOrder
    daysOn?: SortOrder
    daysOff?: SortOrder
    offsetDays?: SortOrder
    groundZero?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    pattern?: ShiftPatternOrderByWithRelationInput
    porters?: PorterOrderByRelationAggregateInput
  }

  export type ShiftWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ShiftWhereInput | ShiftWhereInput[]
    OR?: ShiftWhereInput[]
    NOT?: ShiftWhereInput | ShiftWhereInput[]
    name?: StringFilter<"Shift"> | string
    patternId?: StringFilter<"Shift"> | string
    shiftMode?: EnumShiftModeFilter<"Shift"> | $Enums.ShiftMode
    ident?: StringFilter<"Shift"> | string
    daysOn?: IntFilter<"Shift"> | number
    daysOff?: IntFilter<"Shift"> | number
    offsetDays?: IntFilter<"Shift"> | number
    groundZero?: DateTimeFilter<"Shift"> | Date | string
    createdAt?: DateTimeFilter<"Shift"> | Date | string
    updatedAt?: DateTimeFilter<"Shift"> | Date | string
    pattern?: XOR<ShiftPatternRelationFilter, ShiftPatternWhereInput>
    porters?: PorterListRelationFilter
  }, "id">

  export type ShiftOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    patternId?: SortOrder
    shiftMode?: SortOrder
    ident?: SortOrder
    daysOn?: SortOrder
    daysOff?: SortOrder
    offsetDays?: SortOrder
    groundZero?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ShiftCountOrderByAggregateInput
    _avg?: ShiftAvgOrderByAggregateInput
    _max?: ShiftMaxOrderByAggregateInput
    _min?: ShiftMinOrderByAggregateInput
    _sum?: ShiftSumOrderByAggregateInput
  }

  export type ShiftScalarWhereWithAggregatesInput = {
    AND?: ShiftScalarWhereWithAggregatesInput | ShiftScalarWhereWithAggregatesInput[]
    OR?: ShiftScalarWhereWithAggregatesInput[]
    NOT?: ShiftScalarWhereWithAggregatesInput | ShiftScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Shift"> | string
    name?: StringWithAggregatesFilter<"Shift"> | string
    patternId?: StringWithAggregatesFilter<"Shift"> | string
    shiftMode?: EnumShiftModeWithAggregatesFilter<"Shift"> | $Enums.ShiftMode
    ident?: StringWithAggregatesFilter<"Shift"> | string
    daysOn?: IntWithAggregatesFilter<"Shift"> | number
    daysOff?: IntWithAggregatesFilter<"Shift"> | number
    offsetDays?: IntWithAggregatesFilter<"Shift"> | number
    groundZero?: DateTimeWithAggregatesFilter<"Shift"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Shift"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Shift"> | Date | string
  }

  export type ShiftPatternWhereInput = {
    AND?: ShiftPatternWhereInput | ShiftPatternWhereInput[]
    OR?: ShiftPatternWhereInput[]
    NOT?: ShiftPatternWhereInput | ShiftPatternWhereInput[]
    id?: StringFilter<"ShiftPattern"> | string
    name?: StringFilter<"ShiftPattern"> | string
    patternJson?: StringFilter<"ShiftPattern"> | string
    description?: StringNullableFilter<"ShiftPattern"> | string | null
    createdAt?: DateTimeFilter<"ShiftPattern"> | Date | string
    updatedAt?: DateTimeFilter<"ShiftPattern"> | Date | string
    shifts?: ShiftListRelationFilter
  }

  export type ShiftPatternOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    patternJson?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    shifts?: ShiftOrderByRelationAggregateInput
  }

  export type ShiftPatternWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ShiftPatternWhereInput | ShiftPatternWhereInput[]
    OR?: ShiftPatternWhereInput[]
    NOT?: ShiftPatternWhereInput | ShiftPatternWhereInput[]
    name?: StringFilter<"ShiftPattern"> | string
    patternJson?: StringFilter<"ShiftPattern"> | string
    description?: StringNullableFilter<"ShiftPattern"> | string | null
    createdAt?: DateTimeFilter<"ShiftPattern"> | Date | string
    updatedAt?: DateTimeFilter<"ShiftPattern"> | Date | string
    shifts?: ShiftListRelationFilter
  }, "id">

  export type ShiftPatternOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    patternJson?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ShiftPatternCountOrderByAggregateInput
    _max?: ShiftPatternMaxOrderByAggregateInput
    _min?: ShiftPatternMinOrderByAggregateInput
  }

  export type ShiftPatternScalarWhereWithAggregatesInput = {
    AND?: ShiftPatternScalarWhereWithAggregatesInput | ShiftPatternScalarWhereWithAggregatesInput[]
    OR?: ShiftPatternScalarWhereWithAggregatesInput[]
    NOT?: ShiftPatternScalarWhereWithAggregatesInput | ShiftPatternScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ShiftPattern"> | string
    name?: StringWithAggregatesFilter<"ShiftPattern"> | string
    patternJson?: StringWithAggregatesFilter<"ShiftPattern"> | string
    description?: StringNullableWithAggregatesFilter<"ShiftPattern"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ShiftPattern"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ShiftPattern"> | Date | string
  }

  export type DepartmentScheduleWhereInput = {
    AND?: DepartmentScheduleWhereInput | DepartmentScheduleWhereInput[]
    OR?: DepartmentScheduleWhereInput[]
    NOT?: DepartmentScheduleWhereInput | DepartmentScheduleWhereInput[]
    id?: StringFilter<"DepartmentSchedule"> | string
    name?: StringFilter<"DepartmentSchedule"> | string
    patternId?: StringNullableFilter<"DepartmentSchedule"> | string | null
    description?: StringNullableFilter<"DepartmentSchedule"> | string | null
    isActive?: BoolFilter<"DepartmentSchedule"> | boolean
    createdAt?: DateTimeFilter<"DepartmentSchedule"> | Date | string
    updatedAt?: DateTimeFilter<"DepartmentSchedule"> | Date | string
    departments?: DepartmentListRelationFilter
    periods?: DepartmentSchedulePeriodListRelationFilter
  }

  export type DepartmentScheduleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    patternId?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    departments?: DepartmentOrderByRelationAggregateInput
    periods?: DepartmentSchedulePeriodOrderByRelationAggregateInput
  }

  export type DepartmentScheduleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DepartmentScheduleWhereInput | DepartmentScheduleWhereInput[]
    OR?: DepartmentScheduleWhereInput[]
    NOT?: DepartmentScheduleWhereInput | DepartmentScheduleWhereInput[]
    name?: StringFilter<"DepartmentSchedule"> | string
    patternId?: StringNullableFilter<"DepartmentSchedule"> | string | null
    description?: StringNullableFilter<"DepartmentSchedule"> | string | null
    isActive?: BoolFilter<"DepartmentSchedule"> | boolean
    createdAt?: DateTimeFilter<"DepartmentSchedule"> | Date | string
    updatedAt?: DateTimeFilter<"DepartmentSchedule"> | Date | string
    departments?: DepartmentListRelationFilter
    periods?: DepartmentSchedulePeriodListRelationFilter
  }, "id">

  export type DepartmentScheduleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    patternId?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DepartmentScheduleCountOrderByAggregateInput
    _max?: DepartmentScheduleMaxOrderByAggregateInput
    _min?: DepartmentScheduleMinOrderByAggregateInput
  }

  export type DepartmentScheduleScalarWhereWithAggregatesInput = {
    AND?: DepartmentScheduleScalarWhereWithAggregatesInput | DepartmentScheduleScalarWhereWithAggregatesInput[]
    OR?: DepartmentScheduleScalarWhereWithAggregatesInput[]
    NOT?: DepartmentScheduleScalarWhereWithAggregatesInput | DepartmentScheduleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DepartmentSchedule"> | string
    name?: StringWithAggregatesFilter<"DepartmentSchedule"> | string
    patternId?: StringNullableWithAggregatesFilter<"DepartmentSchedule"> | string | null
    description?: StringNullableWithAggregatesFilter<"DepartmentSchedule"> | string | null
    isActive?: BoolWithAggregatesFilter<"DepartmentSchedule"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"DepartmentSchedule"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DepartmentSchedule"> | Date | string
  }

  export type DepartmentSchedulePeriodWhereInput = {
    AND?: DepartmentSchedulePeriodWhereInput | DepartmentSchedulePeriodWhereInput[]
    OR?: DepartmentSchedulePeriodWhereInput[]
    NOT?: DepartmentSchedulePeriodWhereInput | DepartmentSchedulePeriodWhereInput[]
    id?: StringFilter<"DepartmentSchedulePeriod"> | string
    scheduleId?: StringFilter<"DepartmentSchedulePeriod"> | string
    dayOfWeek?: EnumDayOfWeekFilter<"DepartmentSchedulePeriod"> | $Enums.DayOfWeek
    openTime?: StringFilter<"DepartmentSchedulePeriod"> | string
    closeTime?: StringFilter<"DepartmentSchedulePeriod"> | string
    requiredPorters?: IntFilter<"DepartmentSchedulePeriod"> | number
    schedule?: XOR<DepartmentScheduleRelationFilter, DepartmentScheduleWhereInput>
  }

  export type DepartmentSchedulePeriodOrderByWithRelationInput = {
    id?: SortOrder
    scheduleId?: SortOrder
    dayOfWeek?: SortOrder
    openTime?: SortOrder
    closeTime?: SortOrder
    requiredPorters?: SortOrder
    schedule?: DepartmentScheduleOrderByWithRelationInput
  }

  export type DepartmentSchedulePeriodWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DepartmentSchedulePeriodWhereInput | DepartmentSchedulePeriodWhereInput[]
    OR?: DepartmentSchedulePeriodWhereInput[]
    NOT?: DepartmentSchedulePeriodWhereInput | DepartmentSchedulePeriodWhereInput[]
    scheduleId?: StringFilter<"DepartmentSchedulePeriod"> | string
    dayOfWeek?: EnumDayOfWeekFilter<"DepartmentSchedulePeriod"> | $Enums.DayOfWeek
    openTime?: StringFilter<"DepartmentSchedulePeriod"> | string
    closeTime?: StringFilter<"DepartmentSchedulePeriod"> | string
    requiredPorters?: IntFilter<"DepartmentSchedulePeriod"> | number
    schedule?: XOR<DepartmentScheduleRelationFilter, DepartmentScheduleWhereInput>
  }, "id">

  export type DepartmentSchedulePeriodOrderByWithAggregationInput = {
    id?: SortOrder
    scheduleId?: SortOrder
    dayOfWeek?: SortOrder
    openTime?: SortOrder
    closeTime?: SortOrder
    requiredPorters?: SortOrder
    _count?: DepartmentSchedulePeriodCountOrderByAggregateInput
    _avg?: DepartmentSchedulePeriodAvgOrderByAggregateInput
    _max?: DepartmentSchedulePeriodMaxOrderByAggregateInput
    _min?: DepartmentSchedulePeriodMinOrderByAggregateInput
    _sum?: DepartmentSchedulePeriodSumOrderByAggregateInput
  }

  export type DepartmentSchedulePeriodScalarWhereWithAggregatesInput = {
    AND?: DepartmentSchedulePeriodScalarWhereWithAggregatesInput | DepartmentSchedulePeriodScalarWhereWithAggregatesInput[]
    OR?: DepartmentSchedulePeriodScalarWhereWithAggregatesInput[]
    NOT?: DepartmentSchedulePeriodScalarWhereWithAggregatesInput | DepartmentSchedulePeriodScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DepartmentSchedulePeriod"> | string
    scheduleId?: StringWithAggregatesFilter<"DepartmentSchedulePeriod"> | string
    dayOfWeek?: EnumDayOfWeekWithAggregatesFilter<"DepartmentSchedulePeriod"> | $Enums.DayOfWeek
    openTime?: StringWithAggregatesFilter<"DepartmentSchedulePeriod"> | string
    closeTime?: StringWithAggregatesFilter<"DepartmentSchedulePeriod"> | string
    requiredPorters?: IntWithAggregatesFilter<"DepartmentSchedulePeriod"> | number
  }

  export type CapabilityWhereInput = {
    AND?: CapabilityWhereInput | CapabilityWhereInput[]
    OR?: CapabilityWhereInput[]
    NOT?: CapabilityWhereInput | CapabilityWhereInput[]
    id?: StringFilter<"Capability"> | string
    name?: StringFilter<"Capability"> | string
    description?: StringNullableFilter<"Capability"> | string | null
    createdAt?: DateTimeFilter<"Capability"> | Date | string
    updatedAt?: DateTimeFilter<"Capability"> | Date | string
    porterCapabilities?: PorterCapabilityListRelationFilter
    departmentCapabilities?: DepartmentCapabilityListRelationFilter
    serviceCapabilities?: ServiceCapabilityListRelationFilter
  }

  export type CapabilityOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    porterCapabilities?: PorterCapabilityOrderByRelationAggregateInput
    departmentCapabilities?: DepartmentCapabilityOrderByRelationAggregateInput
    serviceCapabilities?: ServiceCapabilityOrderByRelationAggregateInput
  }

  export type CapabilityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: CapabilityWhereInput | CapabilityWhereInput[]
    OR?: CapabilityWhereInput[]
    NOT?: CapabilityWhereInput | CapabilityWhereInput[]
    description?: StringNullableFilter<"Capability"> | string | null
    createdAt?: DateTimeFilter<"Capability"> | Date | string
    updatedAt?: DateTimeFilter<"Capability"> | Date | string
    porterCapabilities?: PorterCapabilityListRelationFilter
    departmentCapabilities?: DepartmentCapabilityListRelationFilter
    serviceCapabilities?: ServiceCapabilityListRelationFilter
  }, "id" | "name">

  export type CapabilityOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CapabilityCountOrderByAggregateInput
    _max?: CapabilityMaxOrderByAggregateInput
    _min?: CapabilityMinOrderByAggregateInput
  }

  export type CapabilityScalarWhereWithAggregatesInput = {
    AND?: CapabilityScalarWhereWithAggregatesInput | CapabilityScalarWhereWithAggregatesInput[]
    OR?: CapabilityScalarWhereWithAggregatesInput[]
    NOT?: CapabilityScalarWhereWithAggregatesInput | CapabilityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Capability"> | string
    name?: StringWithAggregatesFilter<"Capability"> | string
    description?: StringNullableWithAggregatesFilter<"Capability"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Capability"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Capability"> | Date | string
  }

  export type PorterCapabilityWhereInput = {
    AND?: PorterCapabilityWhereInput | PorterCapabilityWhereInput[]
    OR?: PorterCapabilityWhereInput[]
    NOT?: PorterCapabilityWhereInput | PorterCapabilityWhereInput[]
    porterId?: StringFilter<"PorterCapability"> | string
    capabilityId?: StringFilter<"PorterCapability"> | string
    expiryDate?: DateTimeNullableFilter<"PorterCapability"> | Date | string | null
    createdAt?: DateTimeFilter<"PorterCapability"> | Date | string
    porter?: XOR<PorterRelationFilter, PorterWhereInput>
    capability?: XOR<CapabilityRelationFilter, CapabilityWhereInput>
  }

  export type PorterCapabilityOrderByWithRelationInput = {
    porterId?: SortOrder
    capabilityId?: SortOrder
    expiryDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    porter?: PorterOrderByWithRelationInput
    capability?: CapabilityOrderByWithRelationInput
  }

  export type PorterCapabilityWhereUniqueInput = Prisma.AtLeast<{
    porterId_capabilityId?: PorterCapabilityPorterIdCapabilityIdCompoundUniqueInput
    AND?: PorterCapabilityWhereInput | PorterCapabilityWhereInput[]
    OR?: PorterCapabilityWhereInput[]
    NOT?: PorterCapabilityWhereInput | PorterCapabilityWhereInput[]
    porterId?: StringFilter<"PorterCapability"> | string
    capabilityId?: StringFilter<"PorterCapability"> | string
    expiryDate?: DateTimeNullableFilter<"PorterCapability"> | Date | string | null
    createdAt?: DateTimeFilter<"PorterCapability"> | Date | string
    porter?: XOR<PorterRelationFilter, PorterWhereInput>
    capability?: XOR<CapabilityRelationFilter, CapabilityWhereInput>
  }, "porterId_capabilityId">

  export type PorterCapabilityOrderByWithAggregationInput = {
    porterId?: SortOrder
    capabilityId?: SortOrder
    expiryDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PorterCapabilityCountOrderByAggregateInput
    _max?: PorterCapabilityMaxOrderByAggregateInput
    _min?: PorterCapabilityMinOrderByAggregateInput
  }

  export type PorterCapabilityScalarWhereWithAggregatesInput = {
    AND?: PorterCapabilityScalarWhereWithAggregatesInput | PorterCapabilityScalarWhereWithAggregatesInput[]
    OR?: PorterCapabilityScalarWhereWithAggregatesInput[]
    NOT?: PorterCapabilityScalarWhereWithAggregatesInput | PorterCapabilityScalarWhereWithAggregatesInput[]
    porterId?: StringWithAggregatesFilter<"PorterCapability"> | string
    capabilityId?: StringWithAggregatesFilter<"PorterCapability"> | string
    expiryDate?: DateTimeNullableWithAggregatesFilter<"PorterCapability"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PorterCapability"> | Date | string
  }

  export type DepartmentCapabilityWhereInput = {
    AND?: DepartmentCapabilityWhereInput | DepartmentCapabilityWhereInput[]
    OR?: DepartmentCapabilityWhereInput[]
    NOT?: DepartmentCapabilityWhereInput | DepartmentCapabilityWhereInput[]
    departmentId?: StringFilter<"DepartmentCapability"> | string
    capabilityId?: StringFilter<"DepartmentCapability"> | string
    requiredLevel?: EnumRequiredLevelFilter<"DepartmentCapability"> | $Enums.RequiredLevel
    department?: XOR<DepartmentRelationFilter, DepartmentWhereInput>
    capability?: XOR<CapabilityRelationFilter, CapabilityWhereInput>
  }

  export type DepartmentCapabilityOrderByWithRelationInput = {
    departmentId?: SortOrder
    capabilityId?: SortOrder
    requiredLevel?: SortOrder
    department?: DepartmentOrderByWithRelationInput
    capability?: CapabilityOrderByWithRelationInput
  }

  export type DepartmentCapabilityWhereUniqueInput = Prisma.AtLeast<{
    departmentId_capabilityId?: DepartmentCapabilityDepartmentIdCapabilityIdCompoundUniqueInput
    AND?: DepartmentCapabilityWhereInput | DepartmentCapabilityWhereInput[]
    OR?: DepartmentCapabilityWhereInput[]
    NOT?: DepartmentCapabilityWhereInput | DepartmentCapabilityWhereInput[]
    departmentId?: StringFilter<"DepartmentCapability"> | string
    capabilityId?: StringFilter<"DepartmentCapability"> | string
    requiredLevel?: EnumRequiredLevelFilter<"DepartmentCapability"> | $Enums.RequiredLevel
    department?: XOR<DepartmentRelationFilter, DepartmentWhereInput>
    capability?: XOR<CapabilityRelationFilter, CapabilityWhereInput>
  }, "departmentId_capabilityId">

  export type DepartmentCapabilityOrderByWithAggregationInput = {
    departmentId?: SortOrder
    capabilityId?: SortOrder
    requiredLevel?: SortOrder
    _count?: DepartmentCapabilityCountOrderByAggregateInput
    _max?: DepartmentCapabilityMaxOrderByAggregateInput
    _min?: DepartmentCapabilityMinOrderByAggregateInput
  }

  export type DepartmentCapabilityScalarWhereWithAggregatesInput = {
    AND?: DepartmentCapabilityScalarWhereWithAggregatesInput | DepartmentCapabilityScalarWhereWithAggregatesInput[]
    OR?: DepartmentCapabilityScalarWhereWithAggregatesInput[]
    NOT?: DepartmentCapabilityScalarWhereWithAggregatesInput | DepartmentCapabilityScalarWhereWithAggregatesInput[]
    departmentId?: StringWithAggregatesFilter<"DepartmentCapability"> | string
    capabilityId?: StringWithAggregatesFilter<"DepartmentCapability"> | string
    requiredLevel?: EnumRequiredLevelWithAggregatesFilter<"DepartmentCapability"> | $Enums.RequiredLevel
  }

  export type ServiceCapabilityWhereInput = {
    AND?: ServiceCapabilityWhereInput | ServiceCapabilityWhereInput[]
    OR?: ServiceCapabilityWhereInput[]
    NOT?: ServiceCapabilityWhereInput | ServiceCapabilityWhereInput[]
    serviceId?: StringFilter<"ServiceCapability"> | string
    capabilityId?: StringFilter<"ServiceCapability"> | string
    requiredLevel?: EnumRequiredLevelFilter<"ServiceCapability"> | $Enums.RequiredLevel
    service?: XOR<ServiceRelationFilter, ServiceWhereInput>
    capability?: XOR<CapabilityRelationFilter, CapabilityWhereInput>
  }

  export type ServiceCapabilityOrderByWithRelationInput = {
    serviceId?: SortOrder
    capabilityId?: SortOrder
    requiredLevel?: SortOrder
    service?: ServiceOrderByWithRelationInput
    capability?: CapabilityOrderByWithRelationInput
  }

  export type ServiceCapabilityWhereUniqueInput = Prisma.AtLeast<{
    serviceId_capabilityId?: ServiceCapabilityServiceIdCapabilityIdCompoundUniqueInput
    AND?: ServiceCapabilityWhereInput | ServiceCapabilityWhereInput[]
    OR?: ServiceCapabilityWhereInput[]
    NOT?: ServiceCapabilityWhereInput | ServiceCapabilityWhereInput[]
    serviceId?: StringFilter<"ServiceCapability"> | string
    capabilityId?: StringFilter<"ServiceCapability"> | string
    requiredLevel?: EnumRequiredLevelFilter<"ServiceCapability"> | $Enums.RequiredLevel
    service?: XOR<ServiceRelationFilter, ServiceWhereInput>
    capability?: XOR<CapabilityRelationFilter, CapabilityWhereInput>
  }, "serviceId_capabilityId">

  export type ServiceCapabilityOrderByWithAggregationInput = {
    serviceId?: SortOrder
    capabilityId?: SortOrder
    requiredLevel?: SortOrder
    _count?: ServiceCapabilityCountOrderByAggregateInput
    _max?: ServiceCapabilityMaxOrderByAggregateInput
    _min?: ServiceCapabilityMinOrderByAggregateInput
  }

  export type ServiceCapabilityScalarWhereWithAggregatesInput = {
    AND?: ServiceCapabilityScalarWhereWithAggregatesInput | ServiceCapabilityScalarWhereWithAggregatesInput[]
    OR?: ServiceCapabilityScalarWhereWithAggregatesInput[]
    NOT?: ServiceCapabilityScalarWhereWithAggregatesInput | ServiceCapabilityScalarWhereWithAggregatesInput[]
    serviceId?: StringWithAggregatesFilter<"ServiceCapability"> | string
    capabilityId?: StringWithAggregatesFilter<"ServiceCapability"> | string
    requiredLevel?: EnumRequiredLevelWithAggregatesFilter<"ServiceCapability"> | $Enums.RequiredLevel
  }

  export type AllocationWhereInput = {
    AND?: AllocationWhereInput | AllocationWhereInput[]
    OR?: AllocationWhereInput[]
    NOT?: AllocationWhereInput | AllocationWhereInput[]
    id?: StringFilter<"Allocation"> | string
    porterId?: StringFilter<"Allocation"> | string
    departmentId?: StringFilter<"Allocation"> | string
    serviceId?: StringNullableFilter<"Allocation"> | string | null
    startDatetime?: DateTimeFilter<"Allocation"> | Date | string
    endDatetime?: DateTimeNullableFilter<"Allocation"> | Date | string | null
    type?: EnumAllocationTypeFilter<"Allocation"> | $Enums.AllocationType
    reason?: StringNullableFilter<"Allocation"> | string | null
    createdAt?: DateTimeFilter<"Allocation"> | Date | string
    updatedAt?: DateTimeFilter<"Allocation"> | Date | string
    porter?: XOR<PorterRelationFilter, PorterWhereInput>
    department?: XOR<DepartmentRelationFilter, DepartmentWhereInput>
    service?: XOR<ServiceNullableRelationFilter, ServiceWhereInput> | null
  }

  export type AllocationOrderByWithRelationInput = {
    id?: SortOrder
    porterId?: SortOrder
    departmentId?: SortOrder
    serviceId?: SortOrderInput | SortOrder
    startDatetime?: SortOrder
    endDatetime?: SortOrderInput | SortOrder
    type?: SortOrder
    reason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    porter?: PorterOrderByWithRelationInput
    department?: DepartmentOrderByWithRelationInput
    service?: ServiceOrderByWithRelationInput
  }

  export type AllocationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AllocationWhereInput | AllocationWhereInput[]
    OR?: AllocationWhereInput[]
    NOT?: AllocationWhereInput | AllocationWhereInput[]
    porterId?: StringFilter<"Allocation"> | string
    departmentId?: StringFilter<"Allocation"> | string
    serviceId?: StringNullableFilter<"Allocation"> | string | null
    startDatetime?: DateTimeFilter<"Allocation"> | Date | string
    endDatetime?: DateTimeNullableFilter<"Allocation"> | Date | string | null
    type?: EnumAllocationTypeFilter<"Allocation"> | $Enums.AllocationType
    reason?: StringNullableFilter<"Allocation"> | string | null
    createdAt?: DateTimeFilter<"Allocation"> | Date | string
    updatedAt?: DateTimeFilter<"Allocation"> | Date | string
    porter?: XOR<PorterRelationFilter, PorterWhereInput>
    department?: XOR<DepartmentRelationFilter, DepartmentWhereInput>
    service?: XOR<ServiceNullableRelationFilter, ServiceWhereInput> | null
  }, "id">

  export type AllocationOrderByWithAggregationInput = {
    id?: SortOrder
    porterId?: SortOrder
    departmentId?: SortOrder
    serviceId?: SortOrderInput | SortOrder
    startDatetime?: SortOrder
    endDatetime?: SortOrderInput | SortOrder
    type?: SortOrder
    reason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AllocationCountOrderByAggregateInput
    _max?: AllocationMaxOrderByAggregateInput
    _min?: AllocationMinOrderByAggregateInput
  }

  export type AllocationScalarWhereWithAggregatesInput = {
    AND?: AllocationScalarWhereWithAggregatesInput | AllocationScalarWhereWithAggregatesInput[]
    OR?: AllocationScalarWhereWithAggregatesInput[]
    NOT?: AllocationScalarWhereWithAggregatesInput | AllocationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Allocation"> | string
    porterId?: StringWithAggregatesFilter<"Allocation"> | string
    departmentId?: StringWithAggregatesFilter<"Allocation"> | string
    serviceId?: StringNullableWithAggregatesFilter<"Allocation"> | string | null
    startDatetime?: DateTimeWithAggregatesFilter<"Allocation"> | Date | string
    endDatetime?: DateTimeNullableWithAggregatesFilter<"Allocation"> | Date | string | null
    type?: EnumAllocationTypeWithAggregatesFilter<"Allocation"> | $Enums.AllocationType
    reason?: StringNullableWithAggregatesFilter<"Allocation"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Allocation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Allocation"> | Date | string
  }

  export type AvailabilityWhereInput = {
    AND?: AvailabilityWhereInput | AvailabilityWhereInput[]
    OR?: AvailabilityWhereInput[]
    NOT?: AvailabilityWhereInput | AvailabilityWhereInput[]
    id?: StringFilter<"Availability"> | string
    porterId?: StringFilter<"Availability"> | string
    startDatetime?: DateTimeFilter<"Availability"> | Date | string
    endDatetime?: DateTimeFilter<"Availability"> | Date | string
    status?: EnumAvailabilityStatusFilter<"Availability"> | $Enums.AvailabilityStatus
    reason?: StringNullableFilter<"Availability"> | string | null
    createdAt?: DateTimeFilter<"Availability"> | Date | string
    updatedAt?: DateTimeFilter<"Availability"> | Date | string
    porter?: XOR<PorterRelationFilter, PorterWhereInput>
  }

  export type AvailabilityOrderByWithRelationInput = {
    id?: SortOrder
    porterId?: SortOrder
    startDatetime?: SortOrder
    endDatetime?: SortOrder
    status?: SortOrder
    reason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    porter?: PorterOrderByWithRelationInput
  }

  export type AvailabilityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AvailabilityWhereInput | AvailabilityWhereInput[]
    OR?: AvailabilityWhereInput[]
    NOT?: AvailabilityWhereInput | AvailabilityWhereInput[]
    porterId?: StringFilter<"Availability"> | string
    startDatetime?: DateTimeFilter<"Availability"> | Date | string
    endDatetime?: DateTimeFilter<"Availability"> | Date | string
    status?: EnumAvailabilityStatusFilter<"Availability"> | $Enums.AvailabilityStatus
    reason?: StringNullableFilter<"Availability"> | string | null
    createdAt?: DateTimeFilter<"Availability"> | Date | string
    updatedAt?: DateTimeFilter<"Availability"> | Date | string
    porter?: XOR<PorterRelationFilter, PorterWhereInput>
  }, "id">

  export type AvailabilityOrderByWithAggregationInput = {
    id?: SortOrder
    porterId?: SortOrder
    startDatetime?: SortOrder
    endDatetime?: SortOrder
    status?: SortOrder
    reason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AvailabilityCountOrderByAggregateInput
    _max?: AvailabilityMaxOrderByAggregateInput
    _min?: AvailabilityMinOrderByAggregateInput
  }

  export type AvailabilityScalarWhereWithAggregatesInput = {
    AND?: AvailabilityScalarWhereWithAggregatesInput | AvailabilityScalarWhereWithAggregatesInput[]
    OR?: AvailabilityScalarWhereWithAggregatesInput[]
    NOT?: AvailabilityScalarWhereWithAggregatesInput | AvailabilityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Availability"> | string
    porterId?: StringWithAggregatesFilter<"Availability"> | string
    startDatetime?: DateTimeWithAggregatesFilter<"Availability"> | Date | string
    endDatetime?: DateTimeWithAggregatesFilter<"Availability"> | Date | string
    status?: EnumAvailabilityStatusWithAggregatesFilter<"Availability"> | $Enums.AvailabilityStatus
    reason?: StringNullableWithAggregatesFilter<"Availability"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Availability"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Availability"> | Date | string
  }

  export type SystemSettingWhereInput = {
    AND?: SystemSettingWhereInput | SystemSettingWhereInput[]
    OR?: SystemSettingWhereInput[]
    NOT?: SystemSettingWhereInput | SystemSettingWhereInput[]
    settingKey?: StringFilter<"SystemSetting"> | string
    settingValue?: StringFilter<"SystemSetting"> | string
    description?: StringNullableFilter<"SystemSetting"> | string | null
    updatedAt?: DateTimeFilter<"SystemSetting"> | Date | string
  }

  export type SystemSettingOrderByWithRelationInput = {
    settingKey?: SortOrder
    settingValue?: SortOrder
    description?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
  }

  export type SystemSettingWhereUniqueInput = Prisma.AtLeast<{
    settingKey?: string
    AND?: SystemSettingWhereInput | SystemSettingWhereInput[]
    OR?: SystemSettingWhereInput[]
    NOT?: SystemSettingWhereInput | SystemSettingWhereInput[]
    settingValue?: StringFilter<"SystemSetting"> | string
    description?: StringNullableFilter<"SystemSetting"> | string | null
    updatedAt?: DateTimeFilter<"SystemSetting"> | Date | string
  }, "settingKey">

  export type SystemSettingOrderByWithAggregationInput = {
    settingKey?: SortOrder
    settingValue?: SortOrder
    description?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    _count?: SystemSettingCountOrderByAggregateInput
    _max?: SystemSettingMaxOrderByAggregateInput
    _min?: SystemSettingMinOrderByAggregateInput
  }

  export type SystemSettingScalarWhereWithAggregatesInput = {
    AND?: SystemSettingScalarWhereWithAggregatesInput | SystemSettingScalarWhereWithAggregatesInput[]
    OR?: SystemSettingScalarWhereWithAggregatesInput[]
    NOT?: SystemSettingScalarWhereWithAggregatesInput | SystemSettingScalarWhereWithAggregatesInput[]
    settingKey?: StringWithAggregatesFilter<"SystemSetting"> | string
    settingValue?: StringWithAggregatesFilter<"SystemSetting"> | string
    description?: StringNullableWithAggregatesFilter<"SystemSetting"> | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"SystemSetting"> | Date | string
  }

  export type BuildingCreateInput = {
    id?: string
    name: string
    location?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentCreateNestedManyWithoutBuildingInput
  }

  export type BuildingUncheckedCreateInput = {
    id?: string
    name: string
    location?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentUncheckedCreateNestedManyWithoutBuildingInput
  }

  export type BuildingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUpdateManyWithoutBuildingNestedInput
  }

  export type BuildingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUncheckedUpdateManyWithoutBuildingNestedInput
  }

  export type BuildingCreateManyInput = {
    id?: string
    name: string
    location?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BuildingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BuildingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentCreateInput = {
    id?: string
    name: string
    description?: string | null
    is247?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    building: BuildingCreateNestedOneWithoutDepartmentsInput
    schedule?: DepartmentScheduleCreateNestedOneWithoutDepartmentsInput
    services?: ServiceCreateNestedManyWithoutDepartmentInput
    porters?: PorterCreateNestedManyWithoutRegularDepartmentInput
    allocations?: AllocationCreateNestedManyWithoutDepartmentInput
    departmentCapabilities?: DepartmentCapabilityCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateInput = {
    id?: string
    name: string
    buildingId: string
    scheduleId?: string | null
    description?: string | null
    is247?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ServiceUncheckedCreateNestedManyWithoutDepartmentInput
    porters?: PorterUncheckedCreateNestedManyWithoutRegularDepartmentInput
    allocations?: AllocationUncheckedCreateNestedManyWithoutDepartmentInput
    departmentCapabilities?: DepartmentCapabilityUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is247?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    building?: BuildingUpdateOneRequiredWithoutDepartmentsNestedInput
    schedule?: DepartmentScheduleUpdateOneWithoutDepartmentsNestedInput
    services?: ServiceUpdateManyWithoutDepartmentNestedInput
    porters?: PorterUpdateManyWithoutRegularDepartmentNestedInput
    allocations?: AllocationUpdateManyWithoutDepartmentNestedInput
    departmentCapabilities?: DepartmentCapabilityUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    buildingId?: StringFieldUpdateOperationsInput | string
    scheduleId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is247?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceUncheckedUpdateManyWithoutDepartmentNestedInput
    porters?: PorterUncheckedUpdateManyWithoutRegularDepartmentNestedInput
    allocations?: AllocationUncheckedUpdateManyWithoutDepartmentNestedInput
    departmentCapabilities?: DepartmentCapabilityUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentCreateManyInput = {
    id?: string
    name: string
    buildingId: string
    scheduleId?: string | null
    description?: string | null
    is247?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is247?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    buildingId?: StringFieldUpdateOperationsInput | string
    scheduleId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is247?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceCreateInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    inheritsSchedule?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    department: DepartmentCreateNestedOneWithoutServicesInput
    allocations?: AllocationCreateNestedManyWithoutServiceInput
    serviceCapabilities?: ServiceCapabilityCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateInput = {
    id?: string
    name: string
    departmentId: string
    description?: string | null
    isActive?: boolean
    inheritsSchedule?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    allocations?: AllocationUncheckedCreateNestedManyWithoutServiceInput
    serviceCapabilities?: ServiceCapabilityUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    inheritsSchedule?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneRequiredWithoutServicesNestedInput
    allocations?: AllocationUpdateManyWithoutServiceNestedInput
    serviceCapabilities?: ServiceCapabilityUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    inheritsSchedule?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    allocations?: AllocationUncheckedUpdateManyWithoutServiceNestedInput
    serviceCapabilities?: ServiceCapabilityUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceCreateManyInput = {
    id?: string
    name: string
    departmentId: string
    description?: string | null
    isActive?: boolean
    inheritsSchedule?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    inheritsSchedule?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    inheritsSchedule?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PorterCreateInput = {
    id?: string
    name: string
    contractType: $Enums.ContractType
    weeklyMinHours?: number | null
    contractedHours?: number | null
    porterType?: $Enums.PorterType
    countsTowardsStaffing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    shift?: ShiftCreateNestedOneWithoutPortersInput
    regularDepartment?: DepartmentCreateNestedOneWithoutPortersInput
    allocations?: AllocationCreateNestedManyWithoutPorterInput
    availability?: AvailabilityCreateNestedManyWithoutPorterInput
    porterCapabilities?: PorterCapabilityCreateNestedManyWithoutPorterInput
  }

  export type PorterUncheckedCreateInput = {
    id?: string
    name: string
    contractType: $Enums.ContractType
    shiftId?: string | null
    weeklyMinHours?: number | null
    contractedHours?: number | null
    regularDepartmentId?: string | null
    porterType?: $Enums.PorterType
    countsTowardsStaffing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    allocations?: AllocationUncheckedCreateNestedManyWithoutPorterInput
    availability?: AvailabilityUncheckedCreateNestedManyWithoutPorterInput
    porterCapabilities?: PorterCapabilityUncheckedCreateNestedManyWithoutPorterInput
  }

  export type PorterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contractType?: EnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType
    weeklyMinHours?: NullableIntFieldUpdateOperationsInput | number | null
    contractedHours?: NullableIntFieldUpdateOperationsInput | number | null
    porterType?: EnumPorterTypeFieldUpdateOperationsInput | $Enums.PorterType
    countsTowardsStaffing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shift?: ShiftUpdateOneWithoutPortersNestedInput
    regularDepartment?: DepartmentUpdateOneWithoutPortersNestedInput
    allocations?: AllocationUpdateManyWithoutPorterNestedInput
    availability?: AvailabilityUpdateManyWithoutPorterNestedInput
    porterCapabilities?: PorterCapabilityUpdateManyWithoutPorterNestedInput
  }

  export type PorterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contractType?: EnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType
    shiftId?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyMinHours?: NullableIntFieldUpdateOperationsInput | number | null
    contractedHours?: NullableIntFieldUpdateOperationsInput | number | null
    regularDepartmentId?: NullableStringFieldUpdateOperationsInput | string | null
    porterType?: EnumPorterTypeFieldUpdateOperationsInput | $Enums.PorterType
    countsTowardsStaffing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    allocations?: AllocationUncheckedUpdateManyWithoutPorterNestedInput
    availability?: AvailabilityUncheckedUpdateManyWithoutPorterNestedInput
    porterCapabilities?: PorterCapabilityUncheckedUpdateManyWithoutPorterNestedInput
  }

  export type PorterCreateManyInput = {
    id?: string
    name: string
    contractType: $Enums.ContractType
    shiftId?: string | null
    weeklyMinHours?: number | null
    contractedHours?: number | null
    regularDepartmentId?: string | null
    porterType?: $Enums.PorterType
    countsTowardsStaffing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PorterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contractType?: EnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType
    weeklyMinHours?: NullableIntFieldUpdateOperationsInput | number | null
    contractedHours?: NullableIntFieldUpdateOperationsInput | number | null
    porterType?: EnumPorterTypeFieldUpdateOperationsInput | $Enums.PorterType
    countsTowardsStaffing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PorterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contractType?: EnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType
    shiftId?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyMinHours?: NullableIntFieldUpdateOperationsInput | number | null
    contractedHours?: NullableIntFieldUpdateOperationsInput | number | null
    regularDepartmentId?: NullableStringFieldUpdateOperationsInput | string | null
    porterType?: EnumPorterTypeFieldUpdateOperationsInput | $Enums.PorterType
    countsTowardsStaffing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftCreateInput = {
    id?: string
    name: string
    shiftMode: $Enums.ShiftMode
    ident: string
    daysOn: number
    daysOff: number
    offsetDays?: number
    groundZero: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    pattern: ShiftPatternCreateNestedOneWithoutShiftsInput
    porters?: PorterCreateNestedManyWithoutShiftInput
  }

  export type ShiftUncheckedCreateInput = {
    id?: string
    name: string
    patternId: string
    shiftMode: $Enums.ShiftMode
    ident: string
    daysOn: number
    daysOff: number
    offsetDays?: number
    groundZero: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    porters?: PorterUncheckedCreateNestedManyWithoutShiftInput
  }

  export type ShiftUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shiftMode?: EnumShiftModeFieldUpdateOperationsInput | $Enums.ShiftMode
    ident?: StringFieldUpdateOperationsInput | string
    daysOn?: IntFieldUpdateOperationsInput | number
    daysOff?: IntFieldUpdateOperationsInput | number
    offsetDays?: IntFieldUpdateOperationsInput | number
    groundZero?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pattern?: ShiftPatternUpdateOneRequiredWithoutShiftsNestedInput
    porters?: PorterUpdateManyWithoutShiftNestedInput
  }

  export type ShiftUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    patternId?: StringFieldUpdateOperationsInput | string
    shiftMode?: EnumShiftModeFieldUpdateOperationsInput | $Enums.ShiftMode
    ident?: StringFieldUpdateOperationsInput | string
    daysOn?: IntFieldUpdateOperationsInput | number
    daysOff?: IntFieldUpdateOperationsInput | number
    offsetDays?: IntFieldUpdateOperationsInput | number
    groundZero?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    porters?: PorterUncheckedUpdateManyWithoutShiftNestedInput
  }

  export type ShiftCreateManyInput = {
    id?: string
    name: string
    patternId: string
    shiftMode: $Enums.ShiftMode
    ident: string
    daysOn: number
    daysOff: number
    offsetDays?: number
    groundZero: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShiftUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shiftMode?: EnumShiftModeFieldUpdateOperationsInput | $Enums.ShiftMode
    ident?: StringFieldUpdateOperationsInput | string
    daysOn?: IntFieldUpdateOperationsInput | number
    daysOff?: IntFieldUpdateOperationsInput | number
    offsetDays?: IntFieldUpdateOperationsInput | number
    groundZero?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    patternId?: StringFieldUpdateOperationsInput | string
    shiftMode?: EnumShiftModeFieldUpdateOperationsInput | $Enums.ShiftMode
    ident?: StringFieldUpdateOperationsInput | string
    daysOn?: IntFieldUpdateOperationsInput | number
    daysOff?: IntFieldUpdateOperationsInput | number
    offsetDays?: IntFieldUpdateOperationsInput | number
    groundZero?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftPatternCreateInput = {
    id?: string
    name: string
    patternJson: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    shifts?: ShiftCreateNestedManyWithoutPatternInput
  }

  export type ShiftPatternUncheckedCreateInput = {
    id?: string
    name: string
    patternJson: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    shifts?: ShiftUncheckedCreateNestedManyWithoutPatternInput
  }

  export type ShiftPatternUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    patternJson?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shifts?: ShiftUpdateManyWithoutPatternNestedInput
  }

  export type ShiftPatternUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    patternJson?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shifts?: ShiftUncheckedUpdateManyWithoutPatternNestedInput
  }

  export type ShiftPatternCreateManyInput = {
    id?: string
    name: string
    patternJson: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShiftPatternUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    patternJson?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftPatternUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    patternJson?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentScheduleCreateInput = {
    id?: string
    name: string
    patternId?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentCreateNestedManyWithoutScheduleInput
    periods?: DepartmentSchedulePeriodCreateNestedManyWithoutScheduleInput
  }

  export type DepartmentScheduleUncheckedCreateInput = {
    id?: string
    name: string
    patternId?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentUncheckedCreateNestedManyWithoutScheduleInput
    periods?: DepartmentSchedulePeriodUncheckedCreateNestedManyWithoutScheduleInput
  }

  export type DepartmentScheduleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    patternId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUpdateManyWithoutScheduleNestedInput
    periods?: DepartmentSchedulePeriodUpdateManyWithoutScheduleNestedInput
  }

  export type DepartmentScheduleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    patternId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUncheckedUpdateManyWithoutScheduleNestedInput
    periods?: DepartmentSchedulePeriodUncheckedUpdateManyWithoutScheduleNestedInput
  }

  export type DepartmentScheduleCreateManyInput = {
    id?: string
    name: string
    patternId?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentScheduleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    patternId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentScheduleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    patternId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentSchedulePeriodCreateInput = {
    id?: string
    dayOfWeek: $Enums.DayOfWeek
    openTime: string
    closeTime: string
    requiredPorters: number
    schedule: DepartmentScheduleCreateNestedOneWithoutPeriodsInput
  }

  export type DepartmentSchedulePeriodUncheckedCreateInput = {
    id?: string
    scheduleId: string
    dayOfWeek: $Enums.DayOfWeek
    openTime: string
    closeTime: string
    requiredPorters: number
  }

  export type DepartmentSchedulePeriodUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumDayOfWeekFieldUpdateOperationsInput | $Enums.DayOfWeek
    openTime?: StringFieldUpdateOperationsInput | string
    closeTime?: StringFieldUpdateOperationsInput | string
    requiredPorters?: IntFieldUpdateOperationsInput | number
    schedule?: DepartmentScheduleUpdateOneRequiredWithoutPeriodsNestedInput
  }

  export type DepartmentSchedulePeriodUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduleId?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumDayOfWeekFieldUpdateOperationsInput | $Enums.DayOfWeek
    openTime?: StringFieldUpdateOperationsInput | string
    closeTime?: StringFieldUpdateOperationsInput | string
    requiredPorters?: IntFieldUpdateOperationsInput | number
  }

  export type DepartmentSchedulePeriodCreateManyInput = {
    id?: string
    scheduleId: string
    dayOfWeek: $Enums.DayOfWeek
    openTime: string
    closeTime: string
    requiredPorters: number
  }

  export type DepartmentSchedulePeriodUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumDayOfWeekFieldUpdateOperationsInput | $Enums.DayOfWeek
    openTime?: StringFieldUpdateOperationsInput | string
    closeTime?: StringFieldUpdateOperationsInput | string
    requiredPorters?: IntFieldUpdateOperationsInput | number
  }

  export type DepartmentSchedulePeriodUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduleId?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumDayOfWeekFieldUpdateOperationsInput | $Enums.DayOfWeek
    openTime?: StringFieldUpdateOperationsInput | string
    closeTime?: StringFieldUpdateOperationsInput | string
    requiredPorters?: IntFieldUpdateOperationsInput | number
  }

  export type CapabilityCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    porterCapabilities?: PorterCapabilityCreateNestedManyWithoutCapabilityInput
    departmentCapabilities?: DepartmentCapabilityCreateNestedManyWithoutCapabilityInput
    serviceCapabilities?: ServiceCapabilityCreateNestedManyWithoutCapabilityInput
  }

  export type CapabilityUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    porterCapabilities?: PorterCapabilityUncheckedCreateNestedManyWithoutCapabilityInput
    departmentCapabilities?: DepartmentCapabilityUncheckedCreateNestedManyWithoutCapabilityInput
    serviceCapabilities?: ServiceCapabilityUncheckedCreateNestedManyWithoutCapabilityInput
  }

  export type CapabilityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    porterCapabilities?: PorterCapabilityUpdateManyWithoutCapabilityNestedInput
    departmentCapabilities?: DepartmentCapabilityUpdateManyWithoutCapabilityNestedInput
    serviceCapabilities?: ServiceCapabilityUpdateManyWithoutCapabilityNestedInput
  }

  export type CapabilityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    porterCapabilities?: PorterCapabilityUncheckedUpdateManyWithoutCapabilityNestedInput
    departmentCapabilities?: DepartmentCapabilityUncheckedUpdateManyWithoutCapabilityNestedInput
    serviceCapabilities?: ServiceCapabilityUncheckedUpdateManyWithoutCapabilityNestedInput
  }

  export type CapabilityCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CapabilityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CapabilityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PorterCapabilityCreateInput = {
    expiryDate?: Date | string | null
    createdAt?: Date | string
    porter: PorterCreateNestedOneWithoutPorterCapabilitiesInput
    capability: CapabilityCreateNestedOneWithoutPorterCapabilitiesInput
  }

  export type PorterCapabilityUncheckedCreateInput = {
    porterId: string
    capabilityId: string
    expiryDate?: Date | string | null
    createdAt?: Date | string
  }

  export type PorterCapabilityUpdateInput = {
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    porter?: PorterUpdateOneRequiredWithoutPorterCapabilitiesNestedInput
    capability?: CapabilityUpdateOneRequiredWithoutPorterCapabilitiesNestedInput
  }

  export type PorterCapabilityUncheckedUpdateInput = {
    porterId?: StringFieldUpdateOperationsInput | string
    capabilityId?: StringFieldUpdateOperationsInput | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PorterCapabilityCreateManyInput = {
    porterId: string
    capabilityId: string
    expiryDate?: Date | string | null
    createdAt?: Date | string
  }

  export type PorterCapabilityUpdateManyMutationInput = {
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PorterCapabilityUncheckedUpdateManyInput = {
    porterId?: StringFieldUpdateOperationsInput | string
    capabilityId?: StringFieldUpdateOperationsInput | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentCapabilityCreateInput = {
    requiredLevel: $Enums.RequiredLevel
    department: DepartmentCreateNestedOneWithoutDepartmentCapabilitiesInput
    capability: CapabilityCreateNestedOneWithoutDepartmentCapabilitiesInput
  }

  export type DepartmentCapabilityUncheckedCreateInput = {
    departmentId: string
    capabilityId: string
    requiredLevel: $Enums.RequiredLevel
  }

  export type DepartmentCapabilityUpdateInput = {
    requiredLevel?: EnumRequiredLevelFieldUpdateOperationsInput | $Enums.RequiredLevel
    department?: DepartmentUpdateOneRequiredWithoutDepartmentCapabilitiesNestedInput
    capability?: CapabilityUpdateOneRequiredWithoutDepartmentCapabilitiesNestedInput
  }

  export type DepartmentCapabilityUncheckedUpdateInput = {
    departmentId?: StringFieldUpdateOperationsInput | string
    capabilityId?: StringFieldUpdateOperationsInput | string
    requiredLevel?: EnumRequiredLevelFieldUpdateOperationsInput | $Enums.RequiredLevel
  }

  export type DepartmentCapabilityCreateManyInput = {
    departmentId: string
    capabilityId: string
    requiredLevel: $Enums.RequiredLevel
  }

  export type DepartmentCapabilityUpdateManyMutationInput = {
    requiredLevel?: EnumRequiredLevelFieldUpdateOperationsInput | $Enums.RequiredLevel
  }

  export type DepartmentCapabilityUncheckedUpdateManyInput = {
    departmentId?: StringFieldUpdateOperationsInput | string
    capabilityId?: StringFieldUpdateOperationsInput | string
    requiredLevel?: EnumRequiredLevelFieldUpdateOperationsInput | $Enums.RequiredLevel
  }

  export type ServiceCapabilityCreateInput = {
    requiredLevel: $Enums.RequiredLevel
    service: ServiceCreateNestedOneWithoutServiceCapabilitiesInput
    capability: CapabilityCreateNestedOneWithoutServiceCapabilitiesInput
  }

  export type ServiceCapabilityUncheckedCreateInput = {
    serviceId: string
    capabilityId: string
    requiredLevel: $Enums.RequiredLevel
  }

  export type ServiceCapabilityUpdateInput = {
    requiredLevel?: EnumRequiredLevelFieldUpdateOperationsInput | $Enums.RequiredLevel
    service?: ServiceUpdateOneRequiredWithoutServiceCapabilitiesNestedInput
    capability?: CapabilityUpdateOneRequiredWithoutServiceCapabilitiesNestedInput
  }

  export type ServiceCapabilityUncheckedUpdateInput = {
    serviceId?: StringFieldUpdateOperationsInput | string
    capabilityId?: StringFieldUpdateOperationsInput | string
    requiredLevel?: EnumRequiredLevelFieldUpdateOperationsInput | $Enums.RequiredLevel
  }

  export type ServiceCapabilityCreateManyInput = {
    serviceId: string
    capabilityId: string
    requiredLevel: $Enums.RequiredLevel
  }

  export type ServiceCapabilityUpdateManyMutationInput = {
    requiredLevel?: EnumRequiredLevelFieldUpdateOperationsInput | $Enums.RequiredLevel
  }

  export type ServiceCapabilityUncheckedUpdateManyInput = {
    serviceId?: StringFieldUpdateOperationsInput | string
    capabilityId?: StringFieldUpdateOperationsInput | string
    requiredLevel?: EnumRequiredLevelFieldUpdateOperationsInput | $Enums.RequiredLevel
  }

  export type AllocationCreateInput = {
    id?: string
    startDatetime: Date | string
    endDatetime?: Date | string | null
    type: $Enums.AllocationType
    reason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    porter: PorterCreateNestedOneWithoutAllocationsInput
    department: DepartmentCreateNestedOneWithoutAllocationsInput
    service?: ServiceCreateNestedOneWithoutAllocationsInput
  }

  export type AllocationUncheckedCreateInput = {
    id?: string
    porterId: string
    departmentId: string
    serviceId?: string | null
    startDatetime: Date | string
    endDatetime?: Date | string | null
    type: $Enums.AllocationType
    reason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AllocationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    endDatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: EnumAllocationTypeFieldUpdateOperationsInput | $Enums.AllocationType
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    porter?: PorterUpdateOneRequiredWithoutAllocationsNestedInput
    department?: DepartmentUpdateOneRequiredWithoutAllocationsNestedInput
    service?: ServiceUpdateOneWithoutAllocationsNestedInput
  }

  export type AllocationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    porterId?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    startDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    endDatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: EnumAllocationTypeFieldUpdateOperationsInput | $Enums.AllocationType
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AllocationCreateManyInput = {
    id?: string
    porterId: string
    departmentId: string
    serviceId?: string | null
    startDatetime: Date | string
    endDatetime?: Date | string | null
    type: $Enums.AllocationType
    reason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AllocationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    endDatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: EnumAllocationTypeFieldUpdateOperationsInput | $Enums.AllocationType
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AllocationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    porterId?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    startDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    endDatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: EnumAllocationTypeFieldUpdateOperationsInput | $Enums.AllocationType
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AvailabilityCreateInput = {
    id?: string
    startDatetime: Date | string
    endDatetime: Date | string
    status: $Enums.AvailabilityStatus
    reason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    porter: PorterCreateNestedOneWithoutAvailabilityInput
  }

  export type AvailabilityUncheckedCreateInput = {
    id?: string
    porterId: string
    startDatetime: Date | string
    endDatetime: Date | string
    status: $Enums.AvailabilityStatus
    reason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AvailabilityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    endDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAvailabilityStatusFieldUpdateOperationsInput | $Enums.AvailabilityStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    porter?: PorterUpdateOneRequiredWithoutAvailabilityNestedInput
  }

  export type AvailabilityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    porterId?: StringFieldUpdateOperationsInput | string
    startDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    endDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAvailabilityStatusFieldUpdateOperationsInput | $Enums.AvailabilityStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AvailabilityCreateManyInput = {
    id?: string
    porterId: string
    startDatetime: Date | string
    endDatetime: Date | string
    status: $Enums.AvailabilityStatus
    reason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AvailabilityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    endDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAvailabilityStatusFieldUpdateOperationsInput | $Enums.AvailabilityStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AvailabilityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    porterId?: StringFieldUpdateOperationsInput | string
    startDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    endDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAvailabilityStatusFieldUpdateOperationsInput | $Enums.AvailabilityStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingCreateInput = {
    settingKey: string
    settingValue: string
    description?: string | null
    updatedAt?: Date | string
  }

  export type SystemSettingUncheckedCreateInput = {
    settingKey: string
    settingValue: string
    description?: string | null
    updatedAt?: Date | string
  }

  export type SystemSettingUpdateInput = {
    settingKey?: StringFieldUpdateOperationsInput | string
    settingValue?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingUncheckedUpdateInput = {
    settingKey?: StringFieldUpdateOperationsInput | string
    settingValue?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingCreateManyInput = {
    settingKey: string
    settingValue: string
    description?: string | null
    updatedAt?: Date | string
  }

  export type SystemSettingUpdateManyMutationInput = {
    settingKey?: StringFieldUpdateOperationsInput | string
    settingValue?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingUncheckedUpdateManyInput = {
    settingKey?: StringFieldUpdateOperationsInput | string
    settingValue?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DepartmentListRelationFilter = {
    every?: DepartmentWhereInput
    some?: DepartmentWhereInput
    none?: DepartmentWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type DepartmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BuildingCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BuildingMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BuildingMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type BuildingRelationFilter = {
    is?: BuildingWhereInput
    isNot?: BuildingWhereInput
  }

  export type DepartmentScheduleNullableRelationFilter = {
    is?: DepartmentScheduleWhereInput | null
    isNot?: DepartmentScheduleWhereInput | null
  }

  export type ServiceListRelationFilter = {
    every?: ServiceWhereInput
    some?: ServiceWhereInput
    none?: ServiceWhereInput
  }

  export type PorterListRelationFilter = {
    every?: PorterWhereInput
    some?: PorterWhereInput
    none?: PorterWhereInput
  }

  export type AllocationListRelationFilter = {
    every?: AllocationWhereInput
    some?: AllocationWhereInput
    none?: AllocationWhereInput
  }

  export type DepartmentCapabilityListRelationFilter = {
    every?: DepartmentCapabilityWhereInput
    some?: DepartmentCapabilityWhereInput
    none?: DepartmentCapabilityWhereInput
  }

  export type ServiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PorterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AllocationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DepartmentCapabilityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DepartmentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    buildingId?: SortOrder
    scheduleId?: SortOrder
    description?: SortOrder
    is247?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepartmentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    buildingId?: SortOrder
    scheduleId?: SortOrder
    description?: SortOrder
    is247?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepartmentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    buildingId?: SortOrder
    scheduleId?: SortOrder
    description?: SortOrder
    is247?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DepartmentRelationFilter = {
    is?: DepartmentWhereInput
    isNot?: DepartmentWhereInput
  }

  export type ServiceCapabilityListRelationFilter = {
    every?: ServiceCapabilityWhereInput
    some?: ServiceCapabilityWhereInput
    none?: ServiceCapabilityWhereInput
  }

  export type ServiceCapabilityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    departmentId?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    inheritsSchedule?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    departmentId?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    inheritsSchedule?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    departmentId?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    inheritsSchedule?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumContractTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ContractType | EnumContractTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContractType[]
    notIn?: $Enums.ContractType[]
    not?: NestedEnumContractTypeFilter<$PrismaModel> | $Enums.ContractType
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type EnumPorterTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PorterType | EnumPorterTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PorterType[]
    notIn?: $Enums.PorterType[]
    not?: NestedEnumPorterTypeFilter<$PrismaModel> | $Enums.PorterType
  }

  export type ShiftNullableRelationFilter = {
    is?: ShiftWhereInput | null
    isNot?: ShiftWhereInput | null
  }

  export type DepartmentNullableRelationFilter = {
    is?: DepartmentWhereInput | null
    isNot?: DepartmentWhereInput | null
  }

  export type AvailabilityListRelationFilter = {
    every?: AvailabilityWhereInput
    some?: AvailabilityWhereInput
    none?: AvailabilityWhereInput
  }

  export type PorterCapabilityListRelationFilter = {
    every?: PorterCapabilityWhereInput
    some?: PorterCapabilityWhereInput
    none?: PorterCapabilityWhereInput
  }

  export type AvailabilityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PorterCapabilityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PorterCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contractType?: SortOrder
    shiftId?: SortOrder
    weeklyMinHours?: SortOrder
    contractedHours?: SortOrder
    regularDepartmentId?: SortOrder
    porterType?: SortOrder
    countsTowardsStaffing?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PorterAvgOrderByAggregateInput = {
    weeklyMinHours?: SortOrder
    contractedHours?: SortOrder
  }

  export type PorterMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contractType?: SortOrder
    shiftId?: SortOrder
    weeklyMinHours?: SortOrder
    contractedHours?: SortOrder
    regularDepartmentId?: SortOrder
    porterType?: SortOrder
    countsTowardsStaffing?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PorterMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contractType?: SortOrder
    shiftId?: SortOrder
    weeklyMinHours?: SortOrder
    contractedHours?: SortOrder
    regularDepartmentId?: SortOrder
    porterType?: SortOrder
    countsTowardsStaffing?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PorterSumOrderByAggregateInput = {
    weeklyMinHours?: SortOrder
    contractedHours?: SortOrder
  }

  export type EnumContractTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContractType | EnumContractTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContractType[]
    notIn?: $Enums.ContractType[]
    not?: NestedEnumContractTypeWithAggregatesFilter<$PrismaModel> | $Enums.ContractType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContractTypeFilter<$PrismaModel>
    _max?: NestedEnumContractTypeFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumPorterTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PorterType | EnumPorterTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PorterType[]
    notIn?: $Enums.PorterType[]
    not?: NestedEnumPorterTypeWithAggregatesFilter<$PrismaModel> | $Enums.PorterType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPorterTypeFilter<$PrismaModel>
    _max?: NestedEnumPorterTypeFilter<$PrismaModel>
  }

  export type EnumShiftModeFilter<$PrismaModel = never> = {
    equals?: $Enums.ShiftMode | EnumShiftModeFieldRefInput<$PrismaModel>
    in?: $Enums.ShiftMode[]
    notIn?: $Enums.ShiftMode[]
    not?: NestedEnumShiftModeFilter<$PrismaModel> | $Enums.ShiftMode
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type ShiftPatternRelationFilter = {
    is?: ShiftPatternWhereInput
    isNot?: ShiftPatternWhereInput
  }

  export type ShiftCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    patternId?: SortOrder
    shiftMode?: SortOrder
    ident?: SortOrder
    daysOn?: SortOrder
    daysOff?: SortOrder
    offsetDays?: SortOrder
    groundZero?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShiftAvgOrderByAggregateInput = {
    daysOn?: SortOrder
    daysOff?: SortOrder
    offsetDays?: SortOrder
  }

  export type ShiftMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    patternId?: SortOrder
    shiftMode?: SortOrder
    ident?: SortOrder
    daysOn?: SortOrder
    daysOff?: SortOrder
    offsetDays?: SortOrder
    groundZero?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShiftMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    patternId?: SortOrder
    shiftMode?: SortOrder
    ident?: SortOrder
    daysOn?: SortOrder
    daysOff?: SortOrder
    offsetDays?: SortOrder
    groundZero?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShiftSumOrderByAggregateInput = {
    daysOn?: SortOrder
    daysOff?: SortOrder
    offsetDays?: SortOrder
  }

  export type EnumShiftModeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ShiftMode | EnumShiftModeFieldRefInput<$PrismaModel>
    in?: $Enums.ShiftMode[]
    notIn?: $Enums.ShiftMode[]
    not?: NestedEnumShiftModeWithAggregatesFilter<$PrismaModel> | $Enums.ShiftMode
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumShiftModeFilter<$PrismaModel>
    _max?: NestedEnumShiftModeFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type ShiftListRelationFilter = {
    every?: ShiftWhereInput
    some?: ShiftWhereInput
    none?: ShiftWhereInput
  }

  export type ShiftOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShiftPatternCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    patternJson?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShiftPatternMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    patternJson?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShiftPatternMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    patternJson?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepartmentSchedulePeriodListRelationFilter = {
    every?: DepartmentSchedulePeriodWhereInput
    some?: DepartmentSchedulePeriodWhereInput
    none?: DepartmentSchedulePeriodWhereInput
  }

  export type DepartmentSchedulePeriodOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DepartmentScheduleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    patternId?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepartmentScheduleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    patternId?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepartmentScheduleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    patternId?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumDayOfWeekFilter<$PrismaModel = never> = {
    equals?: $Enums.DayOfWeek | EnumDayOfWeekFieldRefInput<$PrismaModel>
    in?: $Enums.DayOfWeek[]
    notIn?: $Enums.DayOfWeek[]
    not?: NestedEnumDayOfWeekFilter<$PrismaModel> | $Enums.DayOfWeek
  }

  export type DepartmentScheduleRelationFilter = {
    is?: DepartmentScheduleWhereInput
    isNot?: DepartmentScheduleWhereInput
  }

  export type DepartmentSchedulePeriodCountOrderByAggregateInput = {
    id?: SortOrder
    scheduleId?: SortOrder
    dayOfWeek?: SortOrder
    openTime?: SortOrder
    closeTime?: SortOrder
    requiredPorters?: SortOrder
  }

  export type DepartmentSchedulePeriodAvgOrderByAggregateInput = {
    requiredPorters?: SortOrder
  }

  export type DepartmentSchedulePeriodMaxOrderByAggregateInput = {
    id?: SortOrder
    scheduleId?: SortOrder
    dayOfWeek?: SortOrder
    openTime?: SortOrder
    closeTime?: SortOrder
    requiredPorters?: SortOrder
  }

  export type DepartmentSchedulePeriodMinOrderByAggregateInput = {
    id?: SortOrder
    scheduleId?: SortOrder
    dayOfWeek?: SortOrder
    openTime?: SortOrder
    closeTime?: SortOrder
    requiredPorters?: SortOrder
  }

  export type DepartmentSchedulePeriodSumOrderByAggregateInput = {
    requiredPorters?: SortOrder
  }

  export type EnumDayOfWeekWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DayOfWeek | EnumDayOfWeekFieldRefInput<$PrismaModel>
    in?: $Enums.DayOfWeek[]
    notIn?: $Enums.DayOfWeek[]
    not?: NestedEnumDayOfWeekWithAggregatesFilter<$PrismaModel> | $Enums.DayOfWeek
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDayOfWeekFilter<$PrismaModel>
    _max?: NestedEnumDayOfWeekFilter<$PrismaModel>
  }

  export type CapabilityCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CapabilityMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CapabilityMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type PorterRelationFilter = {
    is?: PorterWhereInput
    isNot?: PorterWhereInput
  }

  export type CapabilityRelationFilter = {
    is?: CapabilityWhereInput
    isNot?: CapabilityWhereInput
  }

  export type PorterCapabilityPorterIdCapabilityIdCompoundUniqueInput = {
    porterId: string
    capabilityId: string
  }

  export type PorterCapabilityCountOrderByAggregateInput = {
    porterId?: SortOrder
    capabilityId?: SortOrder
    expiryDate?: SortOrder
    createdAt?: SortOrder
  }

  export type PorterCapabilityMaxOrderByAggregateInput = {
    porterId?: SortOrder
    capabilityId?: SortOrder
    expiryDate?: SortOrder
    createdAt?: SortOrder
  }

  export type PorterCapabilityMinOrderByAggregateInput = {
    porterId?: SortOrder
    capabilityId?: SortOrder
    expiryDate?: SortOrder
    createdAt?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumRequiredLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.RequiredLevel | EnumRequiredLevelFieldRefInput<$PrismaModel>
    in?: $Enums.RequiredLevel[]
    notIn?: $Enums.RequiredLevel[]
    not?: NestedEnumRequiredLevelFilter<$PrismaModel> | $Enums.RequiredLevel
  }

  export type DepartmentCapabilityDepartmentIdCapabilityIdCompoundUniqueInput = {
    departmentId: string
    capabilityId: string
  }

  export type DepartmentCapabilityCountOrderByAggregateInput = {
    departmentId?: SortOrder
    capabilityId?: SortOrder
    requiredLevel?: SortOrder
  }

  export type DepartmentCapabilityMaxOrderByAggregateInput = {
    departmentId?: SortOrder
    capabilityId?: SortOrder
    requiredLevel?: SortOrder
  }

  export type DepartmentCapabilityMinOrderByAggregateInput = {
    departmentId?: SortOrder
    capabilityId?: SortOrder
    requiredLevel?: SortOrder
  }

  export type EnumRequiredLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RequiredLevel | EnumRequiredLevelFieldRefInput<$PrismaModel>
    in?: $Enums.RequiredLevel[]
    notIn?: $Enums.RequiredLevel[]
    not?: NestedEnumRequiredLevelWithAggregatesFilter<$PrismaModel> | $Enums.RequiredLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRequiredLevelFilter<$PrismaModel>
    _max?: NestedEnumRequiredLevelFilter<$PrismaModel>
  }

  export type ServiceRelationFilter = {
    is?: ServiceWhereInput
    isNot?: ServiceWhereInput
  }

  export type ServiceCapabilityServiceIdCapabilityIdCompoundUniqueInput = {
    serviceId: string
    capabilityId: string
  }

  export type ServiceCapabilityCountOrderByAggregateInput = {
    serviceId?: SortOrder
    capabilityId?: SortOrder
    requiredLevel?: SortOrder
  }

  export type ServiceCapabilityMaxOrderByAggregateInput = {
    serviceId?: SortOrder
    capabilityId?: SortOrder
    requiredLevel?: SortOrder
  }

  export type ServiceCapabilityMinOrderByAggregateInput = {
    serviceId?: SortOrder
    capabilityId?: SortOrder
    requiredLevel?: SortOrder
  }

  export type EnumAllocationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AllocationType | EnumAllocationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AllocationType[]
    notIn?: $Enums.AllocationType[]
    not?: NestedEnumAllocationTypeFilter<$PrismaModel> | $Enums.AllocationType
  }

  export type ServiceNullableRelationFilter = {
    is?: ServiceWhereInput | null
    isNot?: ServiceWhereInput | null
  }

  export type AllocationCountOrderByAggregateInput = {
    id?: SortOrder
    porterId?: SortOrder
    departmentId?: SortOrder
    serviceId?: SortOrder
    startDatetime?: SortOrder
    endDatetime?: SortOrder
    type?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AllocationMaxOrderByAggregateInput = {
    id?: SortOrder
    porterId?: SortOrder
    departmentId?: SortOrder
    serviceId?: SortOrder
    startDatetime?: SortOrder
    endDatetime?: SortOrder
    type?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AllocationMinOrderByAggregateInput = {
    id?: SortOrder
    porterId?: SortOrder
    departmentId?: SortOrder
    serviceId?: SortOrder
    startDatetime?: SortOrder
    endDatetime?: SortOrder
    type?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAllocationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AllocationType | EnumAllocationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AllocationType[]
    notIn?: $Enums.AllocationType[]
    not?: NestedEnumAllocationTypeWithAggregatesFilter<$PrismaModel> | $Enums.AllocationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAllocationTypeFilter<$PrismaModel>
    _max?: NestedEnumAllocationTypeFilter<$PrismaModel>
  }

  export type EnumAvailabilityStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AvailabilityStatus | EnumAvailabilityStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AvailabilityStatus[]
    notIn?: $Enums.AvailabilityStatus[]
    not?: NestedEnumAvailabilityStatusFilter<$PrismaModel> | $Enums.AvailabilityStatus
  }

  export type AvailabilityCountOrderByAggregateInput = {
    id?: SortOrder
    porterId?: SortOrder
    startDatetime?: SortOrder
    endDatetime?: SortOrder
    status?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AvailabilityMaxOrderByAggregateInput = {
    id?: SortOrder
    porterId?: SortOrder
    startDatetime?: SortOrder
    endDatetime?: SortOrder
    status?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AvailabilityMinOrderByAggregateInput = {
    id?: SortOrder
    porterId?: SortOrder
    startDatetime?: SortOrder
    endDatetime?: SortOrder
    status?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAvailabilityStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AvailabilityStatus | EnumAvailabilityStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AvailabilityStatus[]
    notIn?: $Enums.AvailabilityStatus[]
    not?: NestedEnumAvailabilityStatusWithAggregatesFilter<$PrismaModel> | $Enums.AvailabilityStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAvailabilityStatusFilter<$PrismaModel>
    _max?: NestedEnumAvailabilityStatusFilter<$PrismaModel>
  }

  export type SystemSettingCountOrderByAggregateInput = {
    settingKey?: SortOrder
    settingValue?: SortOrder
    description?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemSettingMaxOrderByAggregateInput = {
    settingKey?: SortOrder
    settingValue?: SortOrder
    description?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemSettingMinOrderByAggregateInput = {
    settingKey?: SortOrder
    settingValue?: SortOrder
    description?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepartmentCreateNestedManyWithoutBuildingInput = {
    create?: XOR<DepartmentCreateWithoutBuildingInput, DepartmentUncheckedCreateWithoutBuildingInput> | DepartmentCreateWithoutBuildingInput[] | DepartmentUncheckedCreateWithoutBuildingInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutBuildingInput | DepartmentCreateOrConnectWithoutBuildingInput[]
    createMany?: DepartmentCreateManyBuildingInputEnvelope
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
  }

  export type DepartmentUncheckedCreateNestedManyWithoutBuildingInput = {
    create?: XOR<DepartmentCreateWithoutBuildingInput, DepartmentUncheckedCreateWithoutBuildingInput> | DepartmentCreateWithoutBuildingInput[] | DepartmentUncheckedCreateWithoutBuildingInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutBuildingInput | DepartmentCreateOrConnectWithoutBuildingInput[]
    createMany?: DepartmentCreateManyBuildingInputEnvelope
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type DepartmentUpdateManyWithoutBuildingNestedInput = {
    create?: XOR<DepartmentCreateWithoutBuildingInput, DepartmentUncheckedCreateWithoutBuildingInput> | DepartmentCreateWithoutBuildingInput[] | DepartmentUncheckedCreateWithoutBuildingInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutBuildingInput | DepartmentCreateOrConnectWithoutBuildingInput[]
    upsert?: DepartmentUpsertWithWhereUniqueWithoutBuildingInput | DepartmentUpsertWithWhereUniqueWithoutBuildingInput[]
    createMany?: DepartmentCreateManyBuildingInputEnvelope
    set?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    disconnect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    delete?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    update?: DepartmentUpdateWithWhereUniqueWithoutBuildingInput | DepartmentUpdateWithWhereUniqueWithoutBuildingInput[]
    updateMany?: DepartmentUpdateManyWithWhereWithoutBuildingInput | DepartmentUpdateManyWithWhereWithoutBuildingInput[]
    deleteMany?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
  }

  export type DepartmentUncheckedUpdateManyWithoutBuildingNestedInput = {
    create?: XOR<DepartmentCreateWithoutBuildingInput, DepartmentUncheckedCreateWithoutBuildingInput> | DepartmentCreateWithoutBuildingInput[] | DepartmentUncheckedCreateWithoutBuildingInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutBuildingInput | DepartmentCreateOrConnectWithoutBuildingInput[]
    upsert?: DepartmentUpsertWithWhereUniqueWithoutBuildingInput | DepartmentUpsertWithWhereUniqueWithoutBuildingInput[]
    createMany?: DepartmentCreateManyBuildingInputEnvelope
    set?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    disconnect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    delete?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    update?: DepartmentUpdateWithWhereUniqueWithoutBuildingInput | DepartmentUpdateWithWhereUniqueWithoutBuildingInput[]
    updateMany?: DepartmentUpdateManyWithWhereWithoutBuildingInput | DepartmentUpdateManyWithWhereWithoutBuildingInput[]
    deleteMany?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
  }

  export type BuildingCreateNestedOneWithoutDepartmentsInput = {
    create?: XOR<BuildingCreateWithoutDepartmentsInput, BuildingUncheckedCreateWithoutDepartmentsInput>
    connectOrCreate?: BuildingCreateOrConnectWithoutDepartmentsInput
    connect?: BuildingWhereUniqueInput
  }

  export type DepartmentScheduleCreateNestedOneWithoutDepartmentsInput = {
    create?: XOR<DepartmentScheduleCreateWithoutDepartmentsInput, DepartmentScheduleUncheckedCreateWithoutDepartmentsInput>
    connectOrCreate?: DepartmentScheduleCreateOrConnectWithoutDepartmentsInput
    connect?: DepartmentScheduleWhereUniqueInput
  }

  export type ServiceCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<ServiceCreateWithoutDepartmentInput, ServiceUncheckedCreateWithoutDepartmentInput> | ServiceCreateWithoutDepartmentInput[] | ServiceUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutDepartmentInput | ServiceCreateOrConnectWithoutDepartmentInput[]
    createMany?: ServiceCreateManyDepartmentInputEnvelope
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
  }

  export type PorterCreateNestedManyWithoutRegularDepartmentInput = {
    create?: XOR<PorterCreateWithoutRegularDepartmentInput, PorterUncheckedCreateWithoutRegularDepartmentInput> | PorterCreateWithoutRegularDepartmentInput[] | PorterUncheckedCreateWithoutRegularDepartmentInput[]
    connectOrCreate?: PorterCreateOrConnectWithoutRegularDepartmentInput | PorterCreateOrConnectWithoutRegularDepartmentInput[]
    createMany?: PorterCreateManyRegularDepartmentInputEnvelope
    connect?: PorterWhereUniqueInput | PorterWhereUniqueInput[]
  }

  export type AllocationCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<AllocationCreateWithoutDepartmentInput, AllocationUncheckedCreateWithoutDepartmentInput> | AllocationCreateWithoutDepartmentInput[] | AllocationUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: AllocationCreateOrConnectWithoutDepartmentInput | AllocationCreateOrConnectWithoutDepartmentInput[]
    createMany?: AllocationCreateManyDepartmentInputEnvelope
    connect?: AllocationWhereUniqueInput | AllocationWhereUniqueInput[]
  }

  export type DepartmentCapabilityCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<DepartmentCapabilityCreateWithoutDepartmentInput, DepartmentCapabilityUncheckedCreateWithoutDepartmentInput> | DepartmentCapabilityCreateWithoutDepartmentInput[] | DepartmentCapabilityUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: DepartmentCapabilityCreateOrConnectWithoutDepartmentInput | DepartmentCapabilityCreateOrConnectWithoutDepartmentInput[]
    createMany?: DepartmentCapabilityCreateManyDepartmentInputEnvelope
    connect?: DepartmentCapabilityWhereUniqueInput | DepartmentCapabilityWhereUniqueInput[]
  }

  export type ServiceUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<ServiceCreateWithoutDepartmentInput, ServiceUncheckedCreateWithoutDepartmentInput> | ServiceCreateWithoutDepartmentInput[] | ServiceUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutDepartmentInput | ServiceCreateOrConnectWithoutDepartmentInput[]
    createMany?: ServiceCreateManyDepartmentInputEnvelope
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
  }

  export type PorterUncheckedCreateNestedManyWithoutRegularDepartmentInput = {
    create?: XOR<PorterCreateWithoutRegularDepartmentInput, PorterUncheckedCreateWithoutRegularDepartmentInput> | PorterCreateWithoutRegularDepartmentInput[] | PorterUncheckedCreateWithoutRegularDepartmentInput[]
    connectOrCreate?: PorterCreateOrConnectWithoutRegularDepartmentInput | PorterCreateOrConnectWithoutRegularDepartmentInput[]
    createMany?: PorterCreateManyRegularDepartmentInputEnvelope
    connect?: PorterWhereUniqueInput | PorterWhereUniqueInput[]
  }

  export type AllocationUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<AllocationCreateWithoutDepartmentInput, AllocationUncheckedCreateWithoutDepartmentInput> | AllocationCreateWithoutDepartmentInput[] | AllocationUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: AllocationCreateOrConnectWithoutDepartmentInput | AllocationCreateOrConnectWithoutDepartmentInput[]
    createMany?: AllocationCreateManyDepartmentInputEnvelope
    connect?: AllocationWhereUniqueInput | AllocationWhereUniqueInput[]
  }

  export type DepartmentCapabilityUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<DepartmentCapabilityCreateWithoutDepartmentInput, DepartmentCapabilityUncheckedCreateWithoutDepartmentInput> | DepartmentCapabilityCreateWithoutDepartmentInput[] | DepartmentCapabilityUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: DepartmentCapabilityCreateOrConnectWithoutDepartmentInput | DepartmentCapabilityCreateOrConnectWithoutDepartmentInput[]
    createMany?: DepartmentCapabilityCreateManyDepartmentInputEnvelope
    connect?: DepartmentCapabilityWhereUniqueInput | DepartmentCapabilityWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type BuildingUpdateOneRequiredWithoutDepartmentsNestedInput = {
    create?: XOR<BuildingCreateWithoutDepartmentsInput, BuildingUncheckedCreateWithoutDepartmentsInput>
    connectOrCreate?: BuildingCreateOrConnectWithoutDepartmentsInput
    upsert?: BuildingUpsertWithoutDepartmentsInput
    connect?: BuildingWhereUniqueInput
    update?: XOR<XOR<BuildingUpdateToOneWithWhereWithoutDepartmentsInput, BuildingUpdateWithoutDepartmentsInput>, BuildingUncheckedUpdateWithoutDepartmentsInput>
  }

  export type DepartmentScheduleUpdateOneWithoutDepartmentsNestedInput = {
    create?: XOR<DepartmentScheduleCreateWithoutDepartmentsInput, DepartmentScheduleUncheckedCreateWithoutDepartmentsInput>
    connectOrCreate?: DepartmentScheduleCreateOrConnectWithoutDepartmentsInput
    upsert?: DepartmentScheduleUpsertWithoutDepartmentsInput
    disconnect?: DepartmentScheduleWhereInput | boolean
    delete?: DepartmentScheduleWhereInput | boolean
    connect?: DepartmentScheduleWhereUniqueInput
    update?: XOR<XOR<DepartmentScheduleUpdateToOneWithWhereWithoutDepartmentsInput, DepartmentScheduleUpdateWithoutDepartmentsInput>, DepartmentScheduleUncheckedUpdateWithoutDepartmentsInput>
  }

  export type ServiceUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<ServiceCreateWithoutDepartmentInput, ServiceUncheckedCreateWithoutDepartmentInput> | ServiceCreateWithoutDepartmentInput[] | ServiceUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutDepartmentInput | ServiceCreateOrConnectWithoutDepartmentInput[]
    upsert?: ServiceUpsertWithWhereUniqueWithoutDepartmentInput | ServiceUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: ServiceCreateManyDepartmentInputEnvelope
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    update?: ServiceUpdateWithWhereUniqueWithoutDepartmentInput | ServiceUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: ServiceUpdateManyWithWhereWithoutDepartmentInput | ServiceUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
  }

  export type PorterUpdateManyWithoutRegularDepartmentNestedInput = {
    create?: XOR<PorterCreateWithoutRegularDepartmentInput, PorterUncheckedCreateWithoutRegularDepartmentInput> | PorterCreateWithoutRegularDepartmentInput[] | PorterUncheckedCreateWithoutRegularDepartmentInput[]
    connectOrCreate?: PorterCreateOrConnectWithoutRegularDepartmentInput | PorterCreateOrConnectWithoutRegularDepartmentInput[]
    upsert?: PorterUpsertWithWhereUniqueWithoutRegularDepartmentInput | PorterUpsertWithWhereUniqueWithoutRegularDepartmentInput[]
    createMany?: PorterCreateManyRegularDepartmentInputEnvelope
    set?: PorterWhereUniqueInput | PorterWhereUniqueInput[]
    disconnect?: PorterWhereUniqueInput | PorterWhereUniqueInput[]
    delete?: PorterWhereUniqueInput | PorterWhereUniqueInput[]
    connect?: PorterWhereUniqueInput | PorterWhereUniqueInput[]
    update?: PorterUpdateWithWhereUniqueWithoutRegularDepartmentInput | PorterUpdateWithWhereUniqueWithoutRegularDepartmentInput[]
    updateMany?: PorterUpdateManyWithWhereWithoutRegularDepartmentInput | PorterUpdateManyWithWhereWithoutRegularDepartmentInput[]
    deleteMany?: PorterScalarWhereInput | PorterScalarWhereInput[]
  }

  export type AllocationUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<AllocationCreateWithoutDepartmentInput, AllocationUncheckedCreateWithoutDepartmentInput> | AllocationCreateWithoutDepartmentInput[] | AllocationUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: AllocationCreateOrConnectWithoutDepartmentInput | AllocationCreateOrConnectWithoutDepartmentInput[]
    upsert?: AllocationUpsertWithWhereUniqueWithoutDepartmentInput | AllocationUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: AllocationCreateManyDepartmentInputEnvelope
    set?: AllocationWhereUniqueInput | AllocationWhereUniqueInput[]
    disconnect?: AllocationWhereUniqueInput | AllocationWhereUniqueInput[]
    delete?: AllocationWhereUniqueInput | AllocationWhereUniqueInput[]
    connect?: AllocationWhereUniqueInput | AllocationWhereUniqueInput[]
    update?: AllocationUpdateWithWhereUniqueWithoutDepartmentInput | AllocationUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: AllocationUpdateManyWithWhereWithoutDepartmentInput | AllocationUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: AllocationScalarWhereInput | AllocationScalarWhereInput[]
  }

  export type DepartmentCapabilityUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<DepartmentCapabilityCreateWithoutDepartmentInput, DepartmentCapabilityUncheckedCreateWithoutDepartmentInput> | DepartmentCapabilityCreateWithoutDepartmentInput[] | DepartmentCapabilityUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: DepartmentCapabilityCreateOrConnectWithoutDepartmentInput | DepartmentCapabilityCreateOrConnectWithoutDepartmentInput[]
    upsert?: DepartmentCapabilityUpsertWithWhereUniqueWithoutDepartmentInput | DepartmentCapabilityUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: DepartmentCapabilityCreateManyDepartmentInputEnvelope
    set?: DepartmentCapabilityWhereUniqueInput | DepartmentCapabilityWhereUniqueInput[]
    disconnect?: DepartmentCapabilityWhereUniqueInput | DepartmentCapabilityWhereUniqueInput[]
    delete?: DepartmentCapabilityWhereUniqueInput | DepartmentCapabilityWhereUniqueInput[]
    connect?: DepartmentCapabilityWhereUniqueInput | DepartmentCapabilityWhereUniqueInput[]
    update?: DepartmentCapabilityUpdateWithWhereUniqueWithoutDepartmentInput | DepartmentCapabilityUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: DepartmentCapabilityUpdateManyWithWhereWithoutDepartmentInput | DepartmentCapabilityUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: DepartmentCapabilityScalarWhereInput | DepartmentCapabilityScalarWhereInput[]
  }

  export type ServiceUncheckedUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<ServiceCreateWithoutDepartmentInput, ServiceUncheckedCreateWithoutDepartmentInput> | ServiceCreateWithoutDepartmentInput[] | ServiceUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutDepartmentInput | ServiceCreateOrConnectWithoutDepartmentInput[]
    upsert?: ServiceUpsertWithWhereUniqueWithoutDepartmentInput | ServiceUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: ServiceCreateManyDepartmentInputEnvelope
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    update?: ServiceUpdateWithWhereUniqueWithoutDepartmentInput | ServiceUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: ServiceUpdateManyWithWhereWithoutDepartmentInput | ServiceUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
  }

  export type PorterUncheckedUpdateManyWithoutRegularDepartmentNestedInput = {
    create?: XOR<PorterCreateWithoutRegularDepartmentInput, PorterUncheckedCreateWithoutRegularDepartmentInput> | PorterCreateWithoutRegularDepartmentInput[] | PorterUncheckedCreateWithoutRegularDepartmentInput[]
    connectOrCreate?: PorterCreateOrConnectWithoutRegularDepartmentInput | PorterCreateOrConnectWithoutRegularDepartmentInput[]
    upsert?: PorterUpsertWithWhereUniqueWithoutRegularDepartmentInput | PorterUpsertWithWhereUniqueWithoutRegularDepartmentInput[]
    createMany?: PorterCreateManyRegularDepartmentInputEnvelope
    set?: PorterWhereUniqueInput | PorterWhereUniqueInput[]
    disconnect?: PorterWhereUniqueInput | PorterWhereUniqueInput[]
    delete?: PorterWhereUniqueInput | PorterWhereUniqueInput[]
    connect?: PorterWhereUniqueInput | PorterWhereUniqueInput[]
    update?: PorterUpdateWithWhereUniqueWithoutRegularDepartmentInput | PorterUpdateWithWhereUniqueWithoutRegularDepartmentInput[]
    updateMany?: PorterUpdateManyWithWhereWithoutRegularDepartmentInput | PorterUpdateManyWithWhereWithoutRegularDepartmentInput[]
    deleteMany?: PorterScalarWhereInput | PorterScalarWhereInput[]
  }

  export type AllocationUncheckedUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<AllocationCreateWithoutDepartmentInput, AllocationUncheckedCreateWithoutDepartmentInput> | AllocationCreateWithoutDepartmentInput[] | AllocationUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: AllocationCreateOrConnectWithoutDepartmentInput | AllocationCreateOrConnectWithoutDepartmentInput[]
    upsert?: AllocationUpsertWithWhereUniqueWithoutDepartmentInput | AllocationUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: AllocationCreateManyDepartmentInputEnvelope
    set?: AllocationWhereUniqueInput | AllocationWhereUniqueInput[]
    disconnect?: AllocationWhereUniqueInput | AllocationWhereUniqueInput[]
    delete?: AllocationWhereUniqueInput | AllocationWhereUniqueInput[]
    connect?: AllocationWhereUniqueInput | AllocationWhereUniqueInput[]
    update?: AllocationUpdateWithWhereUniqueWithoutDepartmentInput | AllocationUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: AllocationUpdateManyWithWhereWithoutDepartmentInput | AllocationUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: AllocationScalarWhereInput | AllocationScalarWhereInput[]
  }

  export type DepartmentCapabilityUncheckedUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<DepartmentCapabilityCreateWithoutDepartmentInput, DepartmentCapabilityUncheckedCreateWithoutDepartmentInput> | DepartmentCapabilityCreateWithoutDepartmentInput[] | DepartmentCapabilityUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: DepartmentCapabilityCreateOrConnectWithoutDepartmentInput | DepartmentCapabilityCreateOrConnectWithoutDepartmentInput[]
    upsert?: DepartmentCapabilityUpsertWithWhereUniqueWithoutDepartmentInput | DepartmentCapabilityUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: DepartmentCapabilityCreateManyDepartmentInputEnvelope
    set?: DepartmentCapabilityWhereUniqueInput | DepartmentCapabilityWhereUniqueInput[]
    disconnect?: DepartmentCapabilityWhereUniqueInput | DepartmentCapabilityWhereUniqueInput[]
    delete?: DepartmentCapabilityWhereUniqueInput | DepartmentCapabilityWhereUniqueInput[]
    connect?: DepartmentCapabilityWhereUniqueInput | DepartmentCapabilityWhereUniqueInput[]
    update?: DepartmentCapabilityUpdateWithWhereUniqueWithoutDepartmentInput | DepartmentCapabilityUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: DepartmentCapabilityUpdateManyWithWhereWithoutDepartmentInput | DepartmentCapabilityUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: DepartmentCapabilityScalarWhereInput | DepartmentCapabilityScalarWhereInput[]
  }

  export type DepartmentCreateNestedOneWithoutServicesInput = {
    create?: XOR<DepartmentCreateWithoutServicesInput, DepartmentUncheckedCreateWithoutServicesInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutServicesInput
    connect?: DepartmentWhereUniqueInput
  }

  export type AllocationCreateNestedManyWithoutServiceInput = {
    create?: XOR<AllocationCreateWithoutServiceInput, AllocationUncheckedCreateWithoutServiceInput> | AllocationCreateWithoutServiceInput[] | AllocationUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: AllocationCreateOrConnectWithoutServiceInput | AllocationCreateOrConnectWithoutServiceInput[]
    createMany?: AllocationCreateManyServiceInputEnvelope
    connect?: AllocationWhereUniqueInput | AllocationWhereUniqueInput[]
  }

  export type ServiceCapabilityCreateNestedManyWithoutServiceInput = {
    create?: XOR<ServiceCapabilityCreateWithoutServiceInput, ServiceCapabilityUncheckedCreateWithoutServiceInput> | ServiceCapabilityCreateWithoutServiceInput[] | ServiceCapabilityUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceCapabilityCreateOrConnectWithoutServiceInput | ServiceCapabilityCreateOrConnectWithoutServiceInput[]
    createMany?: ServiceCapabilityCreateManyServiceInputEnvelope
    connect?: ServiceCapabilityWhereUniqueInput | ServiceCapabilityWhereUniqueInput[]
  }

  export type AllocationUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<AllocationCreateWithoutServiceInput, AllocationUncheckedCreateWithoutServiceInput> | AllocationCreateWithoutServiceInput[] | AllocationUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: AllocationCreateOrConnectWithoutServiceInput | AllocationCreateOrConnectWithoutServiceInput[]
    createMany?: AllocationCreateManyServiceInputEnvelope
    connect?: AllocationWhereUniqueInput | AllocationWhereUniqueInput[]
  }

  export type ServiceCapabilityUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<ServiceCapabilityCreateWithoutServiceInput, ServiceCapabilityUncheckedCreateWithoutServiceInput> | ServiceCapabilityCreateWithoutServiceInput[] | ServiceCapabilityUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceCapabilityCreateOrConnectWithoutServiceInput | ServiceCapabilityCreateOrConnectWithoutServiceInput[]
    createMany?: ServiceCapabilityCreateManyServiceInputEnvelope
    connect?: ServiceCapabilityWhereUniqueInput | ServiceCapabilityWhereUniqueInput[]
  }

  export type DepartmentUpdateOneRequiredWithoutServicesNestedInput = {
    create?: XOR<DepartmentCreateWithoutServicesInput, DepartmentUncheckedCreateWithoutServicesInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutServicesInput
    upsert?: DepartmentUpsertWithoutServicesInput
    connect?: DepartmentWhereUniqueInput
    update?: XOR<XOR<DepartmentUpdateToOneWithWhereWithoutServicesInput, DepartmentUpdateWithoutServicesInput>, DepartmentUncheckedUpdateWithoutServicesInput>
  }

  export type AllocationUpdateManyWithoutServiceNestedInput = {
    create?: XOR<AllocationCreateWithoutServiceInput, AllocationUncheckedCreateWithoutServiceInput> | AllocationCreateWithoutServiceInput[] | AllocationUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: AllocationCreateOrConnectWithoutServiceInput | AllocationCreateOrConnectWithoutServiceInput[]
    upsert?: AllocationUpsertWithWhereUniqueWithoutServiceInput | AllocationUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: AllocationCreateManyServiceInputEnvelope
    set?: AllocationWhereUniqueInput | AllocationWhereUniqueInput[]
    disconnect?: AllocationWhereUniqueInput | AllocationWhereUniqueInput[]
    delete?: AllocationWhereUniqueInput | AllocationWhereUniqueInput[]
    connect?: AllocationWhereUniqueInput | AllocationWhereUniqueInput[]
    update?: AllocationUpdateWithWhereUniqueWithoutServiceInput | AllocationUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: AllocationUpdateManyWithWhereWithoutServiceInput | AllocationUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: AllocationScalarWhereInput | AllocationScalarWhereInput[]
  }

  export type ServiceCapabilityUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ServiceCapabilityCreateWithoutServiceInput, ServiceCapabilityUncheckedCreateWithoutServiceInput> | ServiceCapabilityCreateWithoutServiceInput[] | ServiceCapabilityUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceCapabilityCreateOrConnectWithoutServiceInput | ServiceCapabilityCreateOrConnectWithoutServiceInput[]
    upsert?: ServiceCapabilityUpsertWithWhereUniqueWithoutServiceInput | ServiceCapabilityUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ServiceCapabilityCreateManyServiceInputEnvelope
    set?: ServiceCapabilityWhereUniqueInput | ServiceCapabilityWhereUniqueInput[]
    disconnect?: ServiceCapabilityWhereUniqueInput | ServiceCapabilityWhereUniqueInput[]
    delete?: ServiceCapabilityWhereUniqueInput | ServiceCapabilityWhereUniqueInput[]
    connect?: ServiceCapabilityWhereUniqueInput | ServiceCapabilityWhereUniqueInput[]
    update?: ServiceCapabilityUpdateWithWhereUniqueWithoutServiceInput | ServiceCapabilityUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ServiceCapabilityUpdateManyWithWhereWithoutServiceInput | ServiceCapabilityUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ServiceCapabilityScalarWhereInput | ServiceCapabilityScalarWhereInput[]
  }

  export type AllocationUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<AllocationCreateWithoutServiceInput, AllocationUncheckedCreateWithoutServiceInput> | AllocationCreateWithoutServiceInput[] | AllocationUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: AllocationCreateOrConnectWithoutServiceInput | AllocationCreateOrConnectWithoutServiceInput[]
    upsert?: AllocationUpsertWithWhereUniqueWithoutServiceInput | AllocationUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: AllocationCreateManyServiceInputEnvelope
    set?: AllocationWhereUniqueInput | AllocationWhereUniqueInput[]
    disconnect?: AllocationWhereUniqueInput | AllocationWhereUniqueInput[]
    delete?: AllocationWhereUniqueInput | AllocationWhereUniqueInput[]
    connect?: AllocationWhereUniqueInput | AllocationWhereUniqueInput[]
    update?: AllocationUpdateWithWhereUniqueWithoutServiceInput | AllocationUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: AllocationUpdateManyWithWhereWithoutServiceInput | AllocationUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: AllocationScalarWhereInput | AllocationScalarWhereInput[]
  }

  export type ServiceCapabilityUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ServiceCapabilityCreateWithoutServiceInput, ServiceCapabilityUncheckedCreateWithoutServiceInput> | ServiceCapabilityCreateWithoutServiceInput[] | ServiceCapabilityUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceCapabilityCreateOrConnectWithoutServiceInput | ServiceCapabilityCreateOrConnectWithoutServiceInput[]
    upsert?: ServiceCapabilityUpsertWithWhereUniqueWithoutServiceInput | ServiceCapabilityUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ServiceCapabilityCreateManyServiceInputEnvelope
    set?: ServiceCapabilityWhereUniqueInput | ServiceCapabilityWhereUniqueInput[]
    disconnect?: ServiceCapabilityWhereUniqueInput | ServiceCapabilityWhereUniqueInput[]
    delete?: ServiceCapabilityWhereUniqueInput | ServiceCapabilityWhereUniqueInput[]
    connect?: ServiceCapabilityWhereUniqueInput | ServiceCapabilityWhereUniqueInput[]
    update?: ServiceCapabilityUpdateWithWhereUniqueWithoutServiceInput | ServiceCapabilityUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ServiceCapabilityUpdateManyWithWhereWithoutServiceInput | ServiceCapabilityUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ServiceCapabilityScalarWhereInput | ServiceCapabilityScalarWhereInput[]
  }

  export type ShiftCreateNestedOneWithoutPortersInput = {
    create?: XOR<ShiftCreateWithoutPortersInput, ShiftUncheckedCreateWithoutPortersInput>
    connectOrCreate?: ShiftCreateOrConnectWithoutPortersInput
    connect?: ShiftWhereUniqueInput
  }

  export type DepartmentCreateNestedOneWithoutPortersInput = {
    create?: XOR<DepartmentCreateWithoutPortersInput, DepartmentUncheckedCreateWithoutPortersInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutPortersInput
    connect?: DepartmentWhereUniqueInput
  }

  export type AllocationCreateNestedManyWithoutPorterInput = {
    create?: XOR<AllocationCreateWithoutPorterInput, AllocationUncheckedCreateWithoutPorterInput> | AllocationCreateWithoutPorterInput[] | AllocationUncheckedCreateWithoutPorterInput[]
    connectOrCreate?: AllocationCreateOrConnectWithoutPorterInput | AllocationCreateOrConnectWithoutPorterInput[]
    createMany?: AllocationCreateManyPorterInputEnvelope
    connect?: AllocationWhereUniqueInput | AllocationWhereUniqueInput[]
  }

  export type AvailabilityCreateNestedManyWithoutPorterInput = {
    create?: XOR<AvailabilityCreateWithoutPorterInput, AvailabilityUncheckedCreateWithoutPorterInput> | AvailabilityCreateWithoutPorterInput[] | AvailabilityUncheckedCreateWithoutPorterInput[]
    connectOrCreate?: AvailabilityCreateOrConnectWithoutPorterInput | AvailabilityCreateOrConnectWithoutPorterInput[]
    createMany?: AvailabilityCreateManyPorterInputEnvelope
    connect?: AvailabilityWhereUniqueInput | AvailabilityWhereUniqueInput[]
  }

  export type PorterCapabilityCreateNestedManyWithoutPorterInput = {
    create?: XOR<PorterCapabilityCreateWithoutPorterInput, PorterCapabilityUncheckedCreateWithoutPorterInput> | PorterCapabilityCreateWithoutPorterInput[] | PorterCapabilityUncheckedCreateWithoutPorterInput[]
    connectOrCreate?: PorterCapabilityCreateOrConnectWithoutPorterInput | PorterCapabilityCreateOrConnectWithoutPorterInput[]
    createMany?: PorterCapabilityCreateManyPorterInputEnvelope
    connect?: PorterCapabilityWhereUniqueInput | PorterCapabilityWhereUniqueInput[]
  }

  export type AllocationUncheckedCreateNestedManyWithoutPorterInput = {
    create?: XOR<AllocationCreateWithoutPorterInput, AllocationUncheckedCreateWithoutPorterInput> | AllocationCreateWithoutPorterInput[] | AllocationUncheckedCreateWithoutPorterInput[]
    connectOrCreate?: AllocationCreateOrConnectWithoutPorterInput | AllocationCreateOrConnectWithoutPorterInput[]
    createMany?: AllocationCreateManyPorterInputEnvelope
    connect?: AllocationWhereUniqueInput | AllocationWhereUniqueInput[]
  }

  export type AvailabilityUncheckedCreateNestedManyWithoutPorterInput = {
    create?: XOR<AvailabilityCreateWithoutPorterInput, AvailabilityUncheckedCreateWithoutPorterInput> | AvailabilityCreateWithoutPorterInput[] | AvailabilityUncheckedCreateWithoutPorterInput[]
    connectOrCreate?: AvailabilityCreateOrConnectWithoutPorterInput | AvailabilityCreateOrConnectWithoutPorterInput[]
    createMany?: AvailabilityCreateManyPorterInputEnvelope
    connect?: AvailabilityWhereUniqueInput | AvailabilityWhereUniqueInput[]
  }

  export type PorterCapabilityUncheckedCreateNestedManyWithoutPorterInput = {
    create?: XOR<PorterCapabilityCreateWithoutPorterInput, PorterCapabilityUncheckedCreateWithoutPorterInput> | PorterCapabilityCreateWithoutPorterInput[] | PorterCapabilityUncheckedCreateWithoutPorterInput[]
    connectOrCreate?: PorterCapabilityCreateOrConnectWithoutPorterInput | PorterCapabilityCreateOrConnectWithoutPorterInput[]
    createMany?: PorterCapabilityCreateManyPorterInputEnvelope
    connect?: PorterCapabilityWhereUniqueInput | PorterCapabilityWhereUniqueInput[]
  }

  export type EnumContractTypeFieldUpdateOperationsInput = {
    set?: $Enums.ContractType
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumPorterTypeFieldUpdateOperationsInput = {
    set?: $Enums.PorterType
  }

  export type ShiftUpdateOneWithoutPortersNestedInput = {
    create?: XOR<ShiftCreateWithoutPortersInput, ShiftUncheckedCreateWithoutPortersInput>
    connectOrCreate?: ShiftCreateOrConnectWithoutPortersInput
    upsert?: ShiftUpsertWithoutPortersInput
    disconnect?: ShiftWhereInput | boolean
    delete?: ShiftWhereInput | boolean
    connect?: ShiftWhereUniqueInput
    update?: XOR<XOR<ShiftUpdateToOneWithWhereWithoutPortersInput, ShiftUpdateWithoutPortersInput>, ShiftUncheckedUpdateWithoutPortersInput>
  }

  export type DepartmentUpdateOneWithoutPortersNestedInput = {
    create?: XOR<DepartmentCreateWithoutPortersInput, DepartmentUncheckedCreateWithoutPortersInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutPortersInput
    upsert?: DepartmentUpsertWithoutPortersInput
    disconnect?: DepartmentWhereInput | boolean
    delete?: DepartmentWhereInput | boolean
    connect?: DepartmentWhereUniqueInput
    update?: XOR<XOR<DepartmentUpdateToOneWithWhereWithoutPortersInput, DepartmentUpdateWithoutPortersInput>, DepartmentUncheckedUpdateWithoutPortersInput>
  }

  export type AllocationUpdateManyWithoutPorterNestedInput = {
    create?: XOR<AllocationCreateWithoutPorterInput, AllocationUncheckedCreateWithoutPorterInput> | AllocationCreateWithoutPorterInput[] | AllocationUncheckedCreateWithoutPorterInput[]
    connectOrCreate?: AllocationCreateOrConnectWithoutPorterInput | AllocationCreateOrConnectWithoutPorterInput[]
    upsert?: AllocationUpsertWithWhereUniqueWithoutPorterInput | AllocationUpsertWithWhereUniqueWithoutPorterInput[]
    createMany?: AllocationCreateManyPorterInputEnvelope
    set?: AllocationWhereUniqueInput | AllocationWhereUniqueInput[]
    disconnect?: AllocationWhereUniqueInput | AllocationWhereUniqueInput[]
    delete?: AllocationWhereUniqueInput | AllocationWhereUniqueInput[]
    connect?: AllocationWhereUniqueInput | AllocationWhereUniqueInput[]
    update?: AllocationUpdateWithWhereUniqueWithoutPorterInput | AllocationUpdateWithWhereUniqueWithoutPorterInput[]
    updateMany?: AllocationUpdateManyWithWhereWithoutPorterInput | AllocationUpdateManyWithWhereWithoutPorterInput[]
    deleteMany?: AllocationScalarWhereInput | AllocationScalarWhereInput[]
  }

  export type AvailabilityUpdateManyWithoutPorterNestedInput = {
    create?: XOR<AvailabilityCreateWithoutPorterInput, AvailabilityUncheckedCreateWithoutPorterInput> | AvailabilityCreateWithoutPorterInput[] | AvailabilityUncheckedCreateWithoutPorterInput[]
    connectOrCreate?: AvailabilityCreateOrConnectWithoutPorterInput | AvailabilityCreateOrConnectWithoutPorterInput[]
    upsert?: AvailabilityUpsertWithWhereUniqueWithoutPorterInput | AvailabilityUpsertWithWhereUniqueWithoutPorterInput[]
    createMany?: AvailabilityCreateManyPorterInputEnvelope
    set?: AvailabilityWhereUniqueInput | AvailabilityWhereUniqueInput[]
    disconnect?: AvailabilityWhereUniqueInput | AvailabilityWhereUniqueInput[]
    delete?: AvailabilityWhereUniqueInput | AvailabilityWhereUniqueInput[]
    connect?: AvailabilityWhereUniqueInput | AvailabilityWhereUniqueInput[]
    update?: AvailabilityUpdateWithWhereUniqueWithoutPorterInput | AvailabilityUpdateWithWhereUniqueWithoutPorterInput[]
    updateMany?: AvailabilityUpdateManyWithWhereWithoutPorterInput | AvailabilityUpdateManyWithWhereWithoutPorterInput[]
    deleteMany?: AvailabilityScalarWhereInput | AvailabilityScalarWhereInput[]
  }

  export type PorterCapabilityUpdateManyWithoutPorterNestedInput = {
    create?: XOR<PorterCapabilityCreateWithoutPorterInput, PorterCapabilityUncheckedCreateWithoutPorterInput> | PorterCapabilityCreateWithoutPorterInput[] | PorterCapabilityUncheckedCreateWithoutPorterInput[]
    connectOrCreate?: PorterCapabilityCreateOrConnectWithoutPorterInput | PorterCapabilityCreateOrConnectWithoutPorterInput[]
    upsert?: PorterCapabilityUpsertWithWhereUniqueWithoutPorterInput | PorterCapabilityUpsertWithWhereUniqueWithoutPorterInput[]
    createMany?: PorterCapabilityCreateManyPorterInputEnvelope
    set?: PorterCapabilityWhereUniqueInput | PorterCapabilityWhereUniqueInput[]
    disconnect?: PorterCapabilityWhereUniqueInput | PorterCapabilityWhereUniqueInput[]
    delete?: PorterCapabilityWhereUniqueInput | PorterCapabilityWhereUniqueInput[]
    connect?: PorterCapabilityWhereUniqueInput | PorterCapabilityWhereUniqueInput[]
    update?: PorterCapabilityUpdateWithWhereUniqueWithoutPorterInput | PorterCapabilityUpdateWithWhereUniqueWithoutPorterInput[]
    updateMany?: PorterCapabilityUpdateManyWithWhereWithoutPorterInput | PorterCapabilityUpdateManyWithWhereWithoutPorterInput[]
    deleteMany?: PorterCapabilityScalarWhereInput | PorterCapabilityScalarWhereInput[]
  }

  export type AllocationUncheckedUpdateManyWithoutPorterNestedInput = {
    create?: XOR<AllocationCreateWithoutPorterInput, AllocationUncheckedCreateWithoutPorterInput> | AllocationCreateWithoutPorterInput[] | AllocationUncheckedCreateWithoutPorterInput[]
    connectOrCreate?: AllocationCreateOrConnectWithoutPorterInput | AllocationCreateOrConnectWithoutPorterInput[]
    upsert?: AllocationUpsertWithWhereUniqueWithoutPorterInput | AllocationUpsertWithWhereUniqueWithoutPorterInput[]
    createMany?: AllocationCreateManyPorterInputEnvelope
    set?: AllocationWhereUniqueInput | AllocationWhereUniqueInput[]
    disconnect?: AllocationWhereUniqueInput | AllocationWhereUniqueInput[]
    delete?: AllocationWhereUniqueInput | AllocationWhereUniqueInput[]
    connect?: AllocationWhereUniqueInput | AllocationWhereUniqueInput[]
    update?: AllocationUpdateWithWhereUniqueWithoutPorterInput | AllocationUpdateWithWhereUniqueWithoutPorterInput[]
    updateMany?: AllocationUpdateManyWithWhereWithoutPorterInput | AllocationUpdateManyWithWhereWithoutPorterInput[]
    deleteMany?: AllocationScalarWhereInput | AllocationScalarWhereInput[]
  }

  export type AvailabilityUncheckedUpdateManyWithoutPorterNestedInput = {
    create?: XOR<AvailabilityCreateWithoutPorterInput, AvailabilityUncheckedCreateWithoutPorterInput> | AvailabilityCreateWithoutPorterInput[] | AvailabilityUncheckedCreateWithoutPorterInput[]
    connectOrCreate?: AvailabilityCreateOrConnectWithoutPorterInput | AvailabilityCreateOrConnectWithoutPorterInput[]
    upsert?: AvailabilityUpsertWithWhereUniqueWithoutPorterInput | AvailabilityUpsertWithWhereUniqueWithoutPorterInput[]
    createMany?: AvailabilityCreateManyPorterInputEnvelope
    set?: AvailabilityWhereUniqueInput | AvailabilityWhereUniqueInput[]
    disconnect?: AvailabilityWhereUniqueInput | AvailabilityWhereUniqueInput[]
    delete?: AvailabilityWhereUniqueInput | AvailabilityWhereUniqueInput[]
    connect?: AvailabilityWhereUniqueInput | AvailabilityWhereUniqueInput[]
    update?: AvailabilityUpdateWithWhereUniqueWithoutPorterInput | AvailabilityUpdateWithWhereUniqueWithoutPorterInput[]
    updateMany?: AvailabilityUpdateManyWithWhereWithoutPorterInput | AvailabilityUpdateManyWithWhereWithoutPorterInput[]
    deleteMany?: AvailabilityScalarWhereInput | AvailabilityScalarWhereInput[]
  }

  export type PorterCapabilityUncheckedUpdateManyWithoutPorterNestedInput = {
    create?: XOR<PorterCapabilityCreateWithoutPorterInput, PorterCapabilityUncheckedCreateWithoutPorterInput> | PorterCapabilityCreateWithoutPorterInput[] | PorterCapabilityUncheckedCreateWithoutPorterInput[]
    connectOrCreate?: PorterCapabilityCreateOrConnectWithoutPorterInput | PorterCapabilityCreateOrConnectWithoutPorterInput[]
    upsert?: PorterCapabilityUpsertWithWhereUniqueWithoutPorterInput | PorterCapabilityUpsertWithWhereUniqueWithoutPorterInput[]
    createMany?: PorterCapabilityCreateManyPorterInputEnvelope
    set?: PorterCapabilityWhereUniqueInput | PorterCapabilityWhereUniqueInput[]
    disconnect?: PorterCapabilityWhereUniqueInput | PorterCapabilityWhereUniqueInput[]
    delete?: PorterCapabilityWhereUniqueInput | PorterCapabilityWhereUniqueInput[]
    connect?: PorterCapabilityWhereUniqueInput | PorterCapabilityWhereUniqueInput[]
    update?: PorterCapabilityUpdateWithWhereUniqueWithoutPorterInput | PorterCapabilityUpdateWithWhereUniqueWithoutPorterInput[]
    updateMany?: PorterCapabilityUpdateManyWithWhereWithoutPorterInput | PorterCapabilityUpdateManyWithWhereWithoutPorterInput[]
    deleteMany?: PorterCapabilityScalarWhereInput | PorterCapabilityScalarWhereInput[]
  }

  export type ShiftPatternCreateNestedOneWithoutShiftsInput = {
    create?: XOR<ShiftPatternCreateWithoutShiftsInput, ShiftPatternUncheckedCreateWithoutShiftsInput>
    connectOrCreate?: ShiftPatternCreateOrConnectWithoutShiftsInput
    connect?: ShiftPatternWhereUniqueInput
  }

  export type PorterCreateNestedManyWithoutShiftInput = {
    create?: XOR<PorterCreateWithoutShiftInput, PorterUncheckedCreateWithoutShiftInput> | PorterCreateWithoutShiftInput[] | PorterUncheckedCreateWithoutShiftInput[]
    connectOrCreate?: PorterCreateOrConnectWithoutShiftInput | PorterCreateOrConnectWithoutShiftInput[]
    createMany?: PorterCreateManyShiftInputEnvelope
    connect?: PorterWhereUniqueInput | PorterWhereUniqueInput[]
  }

  export type PorterUncheckedCreateNestedManyWithoutShiftInput = {
    create?: XOR<PorterCreateWithoutShiftInput, PorterUncheckedCreateWithoutShiftInput> | PorterCreateWithoutShiftInput[] | PorterUncheckedCreateWithoutShiftInput[]
    connectOrCreate?: PorterCreateOrConnectWithoutShiftInput | PorterCreateOrConnectWithoutShiftInput[]
    createMany?: PorterCreateManyShiftInputEnvelope
    connect?: PorterWhereUniqueInput | PorterWhereUniqueInput[]
  }

  export type EnumShiftModeFieldUpdateOperationsInput = {
    set?: $Enums.ShiftMode
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ShiftPatternUpdateOneRequiredWithoutShiftsNestedInput = {
    create?: XOR<ShiftPatternCreateWithoutShiftsInput, ShiftPatternUncheckedCreateWithoutShiftsInput>
    connectOrCreate?: ShiftPatternCreateOrConnectWithoutShiftsInput
    upsert?: ShiftPatternUpsertWithoutShiftsInput
    connect?: ShiftPatternWhereUniqueInput
    update?: XOR<XOR<ShiftPatternUpdateToOneWithWhereWithoutShiftsInput, ShiftPatternUpdateWithoutShiftsInput>, ShiftPatternUncheckedUpdateWithoutShiftsInput>
  }

  export type PorterUpdateManyWithoutShiftNestedInput = {
    create?: XOR<PorterCreateWithoutShiftInput, PorterUncheckedCreateWithoutShiftInput> | PorterCreateWithoutShiftInput[] | PorterUncheckedCreateWithoutShiftInput[]
    connectOrCreate?: PorterCreateOrConnectWithoutShiftInput | PorterCreateOrConnectWithoutShiftInput[]
    upsert?: PorterUpsertWithWhereUniqueWithoutShiftInput | PorterUpsertWithWhereUniqueWithoutShiftInput[]
    createMany?: PorterCreateManyShiftInputEnvelope
    set?: PorterWhereUniqueInput | PorterWhereUniqueInput[]
    disconnect?: PorterWhereUniqueInput | PorterWhereUniqueInput[]
    delete?: PorterWhereUniqueInput | PorterWhereUniqueInput[]
    connect?: PorterWhereUniqueInput | PorterWhereUniqueInput[]
    update?: PorterUpdateWithWhereUniqueWithoutShiftInput | PorterUpdateWithWhereUniqueWithoutShiftInput[]
    updateMany?: PorterUpdateManyWithWhereWithoutShiftInput | PorterUpdateManyWithWhereWithoutShiftInput[]
    deleteMany?: PorterScalarWhereInput | PorterScalarWhereInput[]
  }

  export type PorterUncheckedUpdateManyWithoutShiftNestedInput = {
    create?: XOR<PorterCreateWithoutShiftInput, PorterUncheckedCreateWithoutShiftInput> | PorterCreateWithoutShiftInput[] | PorterUncheckedCreateWithoutShiftInput[]
    connectOrCreate?: PorterCreateOrConnectWithoutShiftInput | PorterCreateOrConnectWithoutShiftInput[]
    upsert?: PorterUpsertWithWhereUniqueWithoutShiftInput | PorterUpsertWithWhereUniqueWithoutShiftInput[]
    createMany?: PorterCreateManyShiftInputEnvelope
    set?: PorterWhereUniqueInput | PorterWhereUniqueInput[]
    disconnect?: PorterWhereUniqueInput | PorterWhereUniqueInput[]
    delete?: PorterWhereUniqueInput | PorterWhereUniqueInput[]
    connect?: PorterWhereUniqueInput | PorterWhereUniqueInput[]
    update?: PorterUpdateWithWhereUniqueWithoutShiftInput | PorterUpdateWithWhereUniqueWithoutShiftInput[]
    updateMany?: PorterUpdateManyWithWhereWithoutShiftInput | PorterUpdateManyWithWhereWithoutShiftInput[]
    deleteMany?: PorterScalarWhereInput | PorterScalarWhereInput[]
  }

  export type ShiftCreateNestedManyWithoutPatternInput = {
    create?: XOR<ShiftCreateWithoutPatternInput, ShiftUncheckedCreateWithoutPatternInput> | ShiftCreateWithoutPatternInput[] | ShiftUncheckedCreateWithoutPatternInput[]
    connectOrCreate?: ShiftCreateOrConnectWithoutPatternInput | ShiftCreateOrConnectWithoutPatternInput[]
    createMany?: ShiftCreateManyPatternInputEnvelope
    connect?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
  }

  export type ShiftUncheckedCreateNestedManyWithoutPatternInput = {
    create?: XOR<ShiftCreateWithoutPatternInput, ShiftUncheckedCreateWithoutPatternInput> | ShiftCreateWithoutPatternInput[] | ShiftUncheckedCreateWithoutPatternInput[]
    connectOrCreate?: ShiftCreateOrConnectWithoutPatternInput | ShiftCreateOrConnectWithoutPatternInput[]
    createMany?: ShiftCreateManyPatternInputEnvelope
    connect?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
  }

  export type ShiftUpdateManyWithoutPatternNestedInput = {
    create?: XOR<ShiftCreateWithoutPatternInput, ShiftUncheckedCreateWithoutPatternInput> | ShiftCreateWithoutPatternInput[] | ShiftUncheckedCreateWithoutPatternInput[]
    connectOrCreate?: ShiftCreateOrConnectWithoutPatternInput | ShiftCreateOrConnectWithoutPatternInput[]
    upsert?: ShiftUpsertWithWhereUniqueWithoutPatternInput | ShiftUpsertWithWhereUniqueWithoutPatternInput[]
    createMany?: ShiftCreateManyPatternInputEnvelope
    set?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    disconnect?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    delete?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    connect?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    update?: ShiftUpdateWithWhereUniqueWithoutPatternInput | ShiftUpdateWithWhereUniqueWithoutPatternInput[]
    updateMany?: ShiftUpdateManyWithWhereWithoutPatternInput | ShiftUpdateManyWithWhereWithoutPatternInput[]
    deleteMany?: ShiftScalarWhereInput | ShiftScalarWhereInput[]
  }

  export type ShiftUncheckedUpdateManyWithoutPatternNestedInput = {
    create?: XOR<ShiftCreateWithoutPatternInput, ShiftUncheckedCreateWithoutPatternInput> | ShiftCreateWithoutPatternInput[] | ShiftUncheckedCreateWithoutPatternInput[]
    connectOrCreate?: ShiftCreateOrConnectWithoutPatternInput | ShiftCreateOrConnectWithoutPatternInput[]
    upsert?: ShiftUpsertWithWhereUniqueWithoutPatternInput | ShiftUpsertWithWhereUniqueWithoutPatternInput[]
    createMany?: ShiftCreateManyPatternInputEnvelope
    set?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    disconnect?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    delete?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    connect?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    update?: ShiftUpdateWithWhereUniqueWithoutPatternInput | ShiftUpdateWithWhereUniqueWithoutPatternInput[]
    updateMany?: ShiftUpdateManyWithWhereWithoutPatternInput | ShiftUpdateManyWithWhereWithoutPatternInput[]
    deleteMany?: ShiftScalarWhereInput | ShiftScalarWhereInput[]
  }

  export type DepartmentCreateNestedManyWithoutScheduleInput = {
    create?: XOR<DepartmentCreateWithoutScheduleInput, DepartmentUncheckedCreateWithoutScheduleInput> | DepartmentCreateWithoutScheduleInput[] | DepartmentUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutScheduleInput | DepartmentCreateOrConnectWithoutScheduleInput[]
    createMany?: DepartmentCreateManyScheduleInputEnvelope
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
  }

  export type DepartmentSchedulePeriodCreateNestedManyWithoutScheduleInput = {
    create?: XOR<DepartmentSchedulePeriodCreateWithoutScheduleInput, DepartmentSchedulePeriodUncheckedCreateWithoutScheduleInput> | DepartmentSchedulePeriodCreateWithoutScheduleInput[] | DepartmentSchedulePeriodUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: DepartmentSchedulePeriodCreateOrConnectWithoutScheduleInput | DepartmentSchedulePeriodCreateOrConnectWithoutScheduleInput[]
    createMany?: DepartmentSchedulePeriodCreateManyScheduleInputEnvelope
    connect?: DepartmentSchedulePeriodWhereUniqueInput | DepartmentSchedulePeriodWhereUniqueInput[]
  }

  export type DepartmentUncheckedCreateNestedManyWithoutScheduleInput = {
    create?: XOR<DepartmentCreateWithoutScheduleInput, DepartmentUncheckedCreateWithoutScheduleInput> | DepartmentCreateWithoutScheduleInput[] | DepartmentUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutScheduleInput | DepartmentCreateOrConnectWithoutScheduleInput[]
    createMany?: DepartmentCreateManyScheduleInputEnvelope
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
  }

  export type DepartmentSchedulePeriodUncheckedCreateNestedManyWithoutScheduleInput = {
    create?: XOR<DepartmentSchedulePeriodCreateWithoutScheduleInput, DepartmentSchedulePeriodUncheckedCreateWithoutScheduleInput> | DepartmentSchedulePeriodCreateWithoutScheduleInput[] | DepartmentSchedulePeriodUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: DepartmentSchedulePeriodCreateOrConnectWithoutScheduleInput | DepartmentSchedulePeriodCreateOrConnectWithoutScheduleInput[]
    createMany?: DepartmentSchedulePeriodCreateManyScheduleInputEnvelope
    connect?: DepartmentSchedulePeriodWhereUniqueInput | DepartmentSchedulePeriodWhereUniqueInput[]
  }

  export type DepartmentUpdateManyWithoutScheduleNestedInput = {
    create?: XOR<DepartmentCreateWithoutScheduleInput, DepartmentUncheckedCreateWithoutScheduleInput> | DepartmentCreateWithoutScheduleInput[] | DepartmentUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutScheduleInput | DepartmentCreateOrConnectWithoutScheduleInput[]
    upsert?: DepartmentUpsertWithWhereUniqueWithoutScheduleInput | DepartmentUpsertWithWhereUniqueWithoutScheduleInput[]
    createMany?: DepartmentCreateManyScheduleInputEnvelope
    set?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    disconnect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    delete?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    update?: DepartmentUpdateWithWhereUniqueWithoutScheduleInput | DepartmentUpdateWithWhereUniqueWithoutScheduleInput[]
    updateMany?: DepartmentUpdateManyWithWhereWithoutScheduleInput | DepartmentUpdateManyWithWhereWithoutScheduleInput[]
    deleteMany?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
  }

  export type DepartmentSchedulePeriodUpdateManyWithoutScheduleNestedInput = {
    create?: XOR<DepartmentSchedulePeriodCreateWithoutScheduleInput, DepartmentSchedulePeriodUncheckedCreateWithoutScheduleInput> | DepartmentSchedulePeriodCreateWithoutScheduleInput[] | DepartmentSchedulePeriodUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: DepartmentSchedulePeriodCreateOrConnectWithoutScheduleInput | DepartmentSchedulePeriodCreateOrConnectWithoutScheduleInput[]
    upsert?: DepartmentSchedulePeriodUpsertWithWhereUniqueWithoutScheduleInput | DepartmentSchedulePeriodUpsertWithWhereUniqueWithoutScheduleInput[]
    createMany?: DepartmentSchedulePeriodCreateManyScheduleInputEnvelope
    set?: DepartmentSchedulePeriodWhereUniqueInput | DepartmentSchedulePeriodWhereUniqueInput[]
    disconnect?: DepartmentSchedulePeriodWhereUniqueInput | DepartmentSchedulePeriodWhereUniqueInput[]
    delete?: DepartmentSchedulePeriodWhereUniqueInput | DepartmentSchedulePeriodWhereUniqueInput[]
    connect?: DepartmentSchedulePeriodWhereUniqueInput | DepartmentSchedulePeriodWhereUniqueInput[]
    update?: DepartmentSchedulePeriodUpdateWithWhereUniqueWithoutScheduleInput | DepartmentSchedulePeriodUpdateWithWhereUniqueWithoutScheduleInput[]
    updateMany?: DepartmentSchedulePeriodUpdateManyWithWhereWithoutScheduleInput | DepartmentSchedulePeriodUpdateManyWithWhereWithoutScheduleInput[]
    deleteMany?: DepartmentSchedulePeriodScalarWhereInput | DepartmentSchedulePeriodScalarWhereInput[]
  }

  export type DepartmentUncheckedUpdateManyWithoutScheduleNestedInput = {
    create?: XOR<DepartmentCreateWithoutScheduleInput, DepartmentUncheckedCreateWithoutScheduleInput> | DepartmentCreateWithoutScheduleInput[] | DepartmentUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutScheduleInput | DepartmentCreateOrConnectWithoutScheduleInput[]
    upsert?: DepartmentUpsertWithWhereUniqueWithoutScheduleInput | DepartmentUpsertWithWhereUniqueWithoutScheduleInput[]
    createMany?: DepartmentCreateManyScheduleInputEnvelope
    set?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    disconnect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    delete?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    update?: DepartmentUpdateWithWhereUniqueWithoutScheduleInput | DepartmentUpdateWithWhereUniqueWithoutScheduleInput[]
    updateMany?: DepartmentUpdateManyWithWhereWithoutScheduleInput | DepartmentUpdateManyWithWhereWithoutScheduleInput[]
    deleteMany?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
  }

  export type DepartmentSchedulePeriodUncheckedUpdateManyWithoutScheduleNestedInput = {
    create?: XOR<DepartmentSchedulePeriodCreateWithoutScheduleInput, DepartmentSchedulePeriodUncheckedCreateWithoutScheduleInput> | DepartmentSchedulePeriodCreateWithoutScheduleInput[] | DepartmentSchedulePeriodUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: DepartmentSchedulePeriodCreateOrConnectWithoutScheduleInput | DepartmentSchedulePeriodCreateOrConnectWithoutScheduleInput[]
    upsert?: DepartmentSchedulePeriodUpsertWithWhereUniqueWithoutScheduleInput | DepartmentSchedulePeriodUpsertWithWhereUniqueWithoutScheduleInput[]
    createMany?: DepartmentSchedulePeriodCreateManyScheduleInputEnvelope
    set?: DepartmentSchedulePeriodWhereUniqueInput | DepartmentSchedulePeriodWhereUniqueInput[]
    disconnect?: DepartmentSchedulePeriodWhereUniqueInput | DepartmentSchedulePeriodWhereUniqueInput[]
    delete?: DepartmentSchedulePeriodWhereUniqueInput | DepartmentSchedulePeriodWhereUniqueInput[]
    connect?: DepartmentSchedulePeriodWhereUniqueInput | DepartmentSchedulePeriodWhereUniqueInput[]
    update?: DepartmentSchedulePeriodUpdateWithWhereUniqueWithoutScheduleInput | DepartmentSchedulePeriodUpdateWithWhereUniqueWithoutScheduleInput[]
    updateMany?: DepartmentSchedulePeriodUpdateManyWithWhereWithoutScheduleInput | DepartmentSchedulePeriodUpdateManyWithWhereWithoutScheduleInput[]
    deleteMany?: DepartmentSchedulePeriodScalarWhereInput | DepartmentSchedulePeriodScalarWhereInput[]
  }

  export type DepartmentScheduleCreateNestedOneWithoutPeriodsInput = {
    create?: XOR<DepartmentScheduleCreateWithoutPeriodsInput, DepartmentScheduleUncheckedCreateWithoutPeriodsInput>
    connectOrCreate?: DepartmentScheduleCreateOrConnectWithoutPeriodsInput
    connect?: DepartmentScheduleWhereUniqueInput
  }

  export type EnumDayOfWeekFieldUpdateOperationsInput = {
    set?: $Enums.DayOfWeek
  }

  export type DepartmentScheduleUpdateOneRequiredWithoutPeriodsNestedInput = {
    create?: XOR<DepartmentScheduleCreateWithoutPeriodsInput, DepartmentScheduleUncheckedCreateWithoutPeriodsInput>
    connectOrCreate?: DepartmentScheduleCreateOrConnectWithoutPeriodsInput
    upsert?: DepartmentScheduleUpsertWithoutPeriodsInput
    connect?: DepartmentScheduleWhereUniqueInput
    update?: XOR<XOR<DepartmentScheduleUpdateToOneWithWhereWithoutPeriodsInput, DepartmentScheduleUpdateWithoutPeriodsInput>, DepartmentScheduleUncheckedUpdateWithoutPeriodsInput>
  }

  export type PorterCapabilityCreateNestedManyWithoutCapabilityInput = {
    create?: XOR<PorterCapabilityCreateWithoutCapabilityInput, PorterCapabilityUncheckedCreateWithoutCapabilityInput> | PorterCapabilityCreateWithoutCapabilityInput[] | PorterCapabilityUncheckedCreateWithoutCapabilityInput[]
    connectOrCreate?: PorterCapabilityCreateOrConnectWithoutCapabilityInput | PorterCapabilityCreateOrConnectWithoutCapabilityInput[]
    createMany?: PorterCapabilityCreateManyCapabilityInputEnvelope
    connect?: PorterCapabilityWhereUniqueInput | PorterCapabilityWhereUniqueInput[]
  }

  export type DepartmentCapabilityCreateNestedManyWithoutCapabilityInput = {
    create?: XOR<DepartmentCapabilityCreateWithoutCapabilityInput, DepartmentCapabilityUncheckedCreateWithoutCapabilityInput> | DepartmentCapabilityCreateWithoutCapabilityInput[] | DepartmentCapabilityUncheckedCreateWithoutCapabilityInput[]
    connectOrCreate?: DepartmentCapabilityCreateOrConnectWithoutCapabilityInput | DepartmentCapabilityCreateOrConnectWithoutCapabilityInput[]
    createMany?: DepartmentCapabilityCreateManyCapabilityInputEnvelope
    connect?: DepartmentCapabilityWhereUniqueInput | DepartmentCapabilityWhereUniqueInput[]
  }

  export type ServiceCapabilityCreateNestedManyWithoutCapabilityInput = {
    create?: XOR<ServiceCapabilityCreateWithoutCapabilityInput, ServiceCapabilityUncheckedCreateWithoutCapabilityInput> | ServiceCapabilityCreateWithoutCapabilityInput[] | ServiceCapabilityUncheckedCreateWithoutCapabilityInput[]
    connectOrCreate?: ServiceCapabilityCreateOrConnectWithoutCapabilityInput | ServiceCapabilityCreateOrConnectWithoutCapabilityInput[]
    createMany?: ServiceCapabilityCreateManyCapabilityInputEnvelope
    connect?: ServiceCapabilityWhereUniqueInput | ServiceCapabilityWhereUniqueInput[]
  }

  export type PorterCapabilityUncheckedCreateNestedManyWithoutCapabilityInput = {
    create?: XOR<PorterCapabilityCreateWithoutCapabilityInput, PorterCapabilityUncheckedCreateWithoutCapabilityInput> | PorterCapabilityCreateWithoutCapabilityInput[] | PorterCapabilityUncheckedCreateWithoutCapabilityInput[]
    connectOrCreate?: PorterCapabilityCreateOrConnectWithoutCapabilityInput | PorterCapabilityCreateOrConnectWithoutCapabilityInput[]
    createMany?: PorterCapabilityCreateManyCapabilityInputEnvelope
    connect?: PorterCapabilityWhereUniqueInput | PorterCapabilityWhereUniqueInput[]
  }

  export type DepartmentCapabilityUncheckedCreateNestedManyWithoutCapabilityInput = {
    create?: XOR<DepartmentCapabilityCreateWithoutCapabilityInput, DepartmentCapabilityUncheckedCreateWithoutCapabilityInput> | DepartmentCapabilityCreateWithoutCapabilityInput[] | DepartmentCapabilityUncheckedCreateWithoutCapabilityInput[]
    connectOrCreate?: DepartmentCapabilityCreateOrConnectWithoutCapabilityInput | DepartmentCapabilityCreateOrConnectWithoutCapabilityInput[]
    createMany?: DepartmentCapabilityCreateManyCapabilityInputEnvelope
    connect?: DepartmentCapabilityWhereUniqueInput | DepartmentCapabilityWhereUniqueInput[]
  }

  export type ServiceCapabilityUncheckedCreateNestedManyWithoutCapabilityInput = {
    create?: XOR<ServiceCapabilityCreateWithoutCapabilityInput, ServiceCapabilityUncheckedCreateWithoutCapabilityInput> | ServiceCapabilityCreateWithoutCapabilityInput[] | ServiceCapabilityUncheckedCreateWithoutCapabilityInput[]
    connectOrCreate?: ServiceCapabilityCreateOrConnectWithoutCapabilityInput | ServiceCapabilityCreateOrConnectWithoutCapabilityInput[]
    createMany?: ServiceCapabilityCreateManyCapabilityInputEnvelope
    connect?: ServiceCapabilityWhereUniqueInput | ServiceCapabilityWhereUniqueInput[]
  }

  export type PorterCapabilityUpdateManyWithoutCapabilityNestedInput = {
    create?: XOR<PorterCapabilityCreateWithoutCapabilityInput, PorterCapabilityUncheckedCreateWithoutCapabilityInput> | PorterCapabilityCreateWithoutCapabilityInput[] | PorterCapabilityUncheckedCreateWithoutCapabilityInput[]
    connectOrCreate?: PorterCapabilityCreateOrConnectWithoutCapabilityInput | PorterCapabilityCreateOrConnectWithoutCapabilityInput[]
    upsert?: PorterCapabilityUpsertWithWhereUniqueWithoutCapabilityInput | PorterCapabilityUpsertWithWhereUniqueWithoutCapabilityInput[]
    createMany?: PorterCapabilityCreateManyCapabilityInputEnvelope
    set?: PorterCapabilityWhereUniqueInput | PorterCapabilityWhereUniqueInput[]
    disconnect?: PorterCapabilityWhereUniqueInput | PorterCapabilityWhereUniqueInput[]
    delete?: PorterCapabilityWhereUniqueInput | PorterCapabilityWhereUniqueInput[]
    connect?: PorterCapabilityWhereUniqueInput | PorterCapabilityWhereUniqueInput[]
    update?: PorterCapabilityUpdateWithWhereUniqueWithoutCapabilityInput | PorterCapabilityUpdateWithWhereUniqueWithoutCapabilityInput[]
    updateMany?: PorterCapabilityUpdateManyWithWhereWithoutCapabilityInput | PorterCapabilityUpdateManyWithWhereWithoutCapabilityInput[]
    deleteMany?: PorterCapabilityScalarWhereInput | PorterCapabilityScalarWhereInput[]
  }

  export type DepartmentCapabilityUpdateManyWithoutCapabilityNestedInput = {
    create?: XOR<DepartmentCapabilityCreateWithoutCapabilityInput, DepartmentCapabilityUncheckedCreateWithoutCapabilityInput> | DepartmentCapabilityCreateWithoutCapabilityInput[] | DepartmentCapabilityUncheckedCreateWithoutCapabilityInput[]
    connectOrCreate?: DepartmentCapabilityCreateOrConnectWithoutCapabilityInput | DepartmentCapabilityCreateOrConnectWithoutCapabilityInput[]
    upsert?: DepartmentCapabilityUpsertWithWhereUniqueWithoutCapabilityInput | DepartmentCapabilityUpsertWithWhereUniqueWithoutCapabilityInput[]
    createMany?: DepartmentCapabilityCreateManyCapabilityInputEnvelope
    set?: DepartmentCapabilityWhereUniqueInput | DepartmentCapabilityWhereUniqueInput[]
    disconnect?: DepartmentCapabilityWhereUniqueInput | DepartmentCapabilityWhereUniqueInput[]
    delete?: DepartmentCapabilityWhereUniqueInput | DepartmentCapabilityWhereUniqueInput[]
    connect?: DepartmentCapabilityWhereUniqueInput | DepartmentCapabilityWhereUniqueInput[]
    update?: DepartmentCapabilityUpdateWithWhereUniqueWithoutCapabilityInput | DepartmentCapabilityUpdateWithWhereUniqueWithoutCapabilityInput[]
    updateMany?: DepartmentCapabilityUpdateManyWithWhereWithoutCapabilityInput | DepartmentCapabilityUpdateManyWithWhereWithoutCapabilityInput[]
    deleteMany?: DepartmentCapabilityScalarWhereInput | DepartmentCapabilityScalarWhereInput[]
  }

  export type ServiceCapabilityUpdateManyWithoutCapabilityNestedInput = {
    create?: XOR<ServiceCapabilityCreateWithoutCapabilityInput, ServiceCapabilityUncheckedCreateWithoutCapabilityInput> | ServiceCapabilityCreateWithoutCapabilityInput[] | ServiceCapabilityUncheckedCreateWithoutCapabilityInput[]
    connectOrCreate?: ServiceCapabilityCreateOrConnectWithoutCapabilityInput | ServiceCapabilityCreateOrConnectWithoutCapabilityInput[]
    upsert?: ServiceCapabilityUpsertWithWhereUniqueWithoutCapabilityInput | ServiceCapabilityUpsertWithWhereUniqueWithoutCapabilityInput[]
    createMany?: ServiceCapabilityCreateManyCapabilityInputEnvelope
    set?: ServiceCapabilityWhereUniqueInput | ServiceCapabilityWhereUniqueInput[]
    disconnect?: ServiceCapabilityWhereUniqueInput | ServiceCapabilityWhereUniqueInput[]
    delete?: ServiceCapabilityWhereUniqueInput | ServiceCapabilityWhereUniqueInput[]
    connect?: ServiceCapabilityWhereUniqueInput | ServiceCapabilityWhereUniqueInput[]
    update?: ServiceCapabilityUpdateWithWhereUniqueWithoutCapabilityInput | ServiceCapabilityUpdateWithWhereUniqueWithoutCapabilityInput[]
    updateMany?: ServiceCapabilityUpdateManyWithWhereWithoutCapabilityInput | ServiceCapabilityUpdateManyWithWhereWithoutCapabilityInput[]
    deleteMany?: ServiceCapabilityScalarWhereInput | ServiceCapabilityScalarWhereInput[]
  }

  export type PorterCapabilityUncheckedUpdateManyWithoutCapabilityNestedInput = {
    create?: XOR<PorterCapabilityCreateWithoutCapabilityInput, PorterCapabilityUncheckedCreateWithoutCapabilityInput> | PorterCapabilityCreateWithoutCapabilityInput[] | PorterCapabilityUncheckedCreateWithoutCapabilityInput[]
    connectOrCreate?: PorterCapabilityCreateOrConnectWithoutCapabilityInput | PorterCapabilityCreateOrConnectWithoutCapabilityInput[]
    upsert?: PorterCapabilityUpsertWithWhereUniqueWithoutCapabilityInput | PorterCapabilityUpsertWithWhereUniqueWithoutCapabilityInput[]
    createMany?: PorterCapabilityCreateManyCapabilityInputEnvelope
    set?: PorterCapabilityWhereUniqueInput | PorterCapabilityWhereUniqueInput[]
    disconnect?: PorterCapabilityWhereUniqueInput | PorterCapabilityWhereUniqueInput[]
    delete?: PorterCapabilityWhereUniqueInput | PorterCapabilityWhereUniqueInput[]
    connect?: PorterCapabilityWhereUniqueInput | PorterCapabilityWhereUniqueInput[]
    update?: PorterCapabilityUpdateWithWhereUniqueWithoutCapabilityInput | PorterCapabilityUpdateWithWhereUniqueWithoutCapabilityInput[]
    updateMany?: PorterCapabilityUpdateManyWithWhereWithoutCapabilityInput | PorterCapabilityUpdateManyWithWhereWithoutCapabilityInput[]
    deleteMany?: PorterCapabilityScalarWhereInput | PorterCapabilityScalarWhereInput[]
  }

  export type DepartmentCapabilityUncheckedUpdateManyWithoutCapabilityNestedInput = {
    create?: XOR<DepartmentCapabilityCreateWithoutCapabilityInput, DepartmentCapabilityUncheckedCreateWithoutCapabilityInput> | DepartmentCapabilityCreateWithoutCapabilityInput[] | DepartmentCapabilityUncheckedCreateWithoutCapabilityInput[]
    connectOrCreate?: DepartmentCapabilityCreateOrConnectWithoutCapabilityInput | DepartmentCapabilityCreateOrConnectWithoutCapabilityInput[]
    upsert?: DepartmentCapabilityUpsertWithWhereUniqueWithoutCapabilityInput | DepartmentCapabilityUpsertWithWhereUniqueWithoutCapabilityInput[]
    createMany?: DepartmentCapabilityCreateManyCapabilityInputEnvelope
    set?: DepartmentCapabilityWhereUniqueInput | DepartmentCapabilityWhereUniqueInput[]
    disconnect?: DepartmentCapabilityWhereUniqueInput | DepartmentCapabilityWhereUniqueInput[]
    delete?: DepartmentCapabilityWhereUniqueInput | DepartmentCapabilityWhereUniqueInput[]
    connect?: DepartmentCapabilityWhereUniqueInput | DepartmentCapabilityWhereUniqueInput[]
    update?: DepartmentCapabilityUpdateWithWhereUniqueWithoutCapabilityInput | DepartmentCapabilityUpdateWithWhereUniqueWithoutCapabilityInput[]
    updateMany?: DepartmentCapabilityUpdateManyWithWhereWithoutCapabilityInput | DepartmentCapabilityUpdateManyWithWhereWithoutCapabilityInput[]
    deleteMany?: DepartmentCapabilityScalarWhereInput | DepartmentCapabilityScalarWhereInput[]
  }

  export type ServiceCapabilityUncheckedUpdateManyWithoutCapabilityNestedInput = {
    create?: XOR<ServiceCapabilityCreateWithoutCapabilityInput, ServiceCapabilityUncheckedCreateWithoutCapabilityInput> | ServiceCapabilityCreateWithoutCapabilityInput[] | ServiceCapabilityUncheckedCreateWithoutCapabilityInput[]
    connectOrCreate?: ServiceCapabilityCreateOrConnectWithoutCapabilityInput | ServiceCapabilityCreateOrConnectWithoutCapabilityInput[]
    upsert?: ServiceCapabilityUpsertWithWhereUniqueWithoutCapabilityInput | ServiceCapabilityUpsertWithWhereUniqueWithoutCapabilityInput[]
    createMany?: ServiceCapabilityCreateManyCapabilityInputEnvelope
    set?: ServiceCapabilityWhereUniqueInput | ServiceCapabilityWhereUniqueInput[]
    disconnect?: ServiceCapabilityWhereUniqueInput | ServiceCapabilityWhereUniqueInput[]
    delete?: ServiceCapabilityWhereUniqueInput | ServiceCapabilityWhereUniqueInput[]
    connect?: ServiceCapabilityWhereUniqueInput | ServiceCapabilityWhereUniqueInput[]
    update?: ServiceCapabilityUpdateWithWhereUniqueWithoutCapabilityInput | ServiceCapabilityUpdateWithWhereUniqueWithoutCapabilityInput[]
    updateMany?: ServiceCapabilityUpdateManyWithWhereWithoutCapabilityInput | ServiceCapabilityUpdateManyWithWhereWithoutCapabilityInput[]
    deleteMany?: ServiceCapabilityScalarWhereInput | ServiceCapabilityScalarWhereInput[]
  }

  export type PorterCreateNestedOneWithoutPorterCapabilitiesInput = {
    create?: XOR<PorterCreateWithoutPorterCapabilitiesInput, PorterUncheckedCreateWithoutPorterCapabilitiesInput>
    connectOrCreate?: PorterCreateOrConnectWithoutPorterCapabilitiesInput
    connect?: PorterWhereUniqueInput
  }

  export type CapabilityCreateNestedOneWithoutPorterCapabilitiesInput = {
    create?: XOR<CapabilityCreateWithoutPorterCapabilitiesInput, CapabilityUncheckedCreateWithoutPorterCapabilitiesInput>
    connectOrCreate?: CapabilityCreateOrConnectWithoutPorterCapabilitiesInput
    connect?: CapabilityWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type PorterUpdateOneRequiredWithoutPorterCapabilitiesNestedInput = {
    create?: XOR<PorterCreateWithoutPorterCapabilitiesInput, PorterUncheckedCreateWithoutPorterCapabilitiesInput>
    connectOrCreate?: PorterCreateOrConnectWithoutPorterCapabilitiesInput
    upsert?: PorterUpsertWithoutPorterCapabilitiesInput
    connect?: PorterWhereUniqueInput
    update?: XOR<XOR<PorterUpdateToOneWithWhereWithoutPorterCapabilitiesInput, PorterUpdateWithoutPorterCapabilitiesInput>, PorterUncheckedUpdateWithoutPorterCapabilitiesInput>
  }

  export type CapabilityUpdateOneRequiredWithoutPorterCapabilitiesNestedInput = {
    create?: XOR<CapabilityCreateWithoutPorterCapabilitiesInput, CapabilityUncheckedCreateWithoutPorterCapabilitiesInput>
    connectOrCreate?: CapabilityCreateOrConnectWithoutPorterCapabilitiesInput
    upsert?: CapabilityUpsertWithoutPorterCapabilitiesInput
    connect?: CapabilityWhereUniqueInput
    update?: XOR<XOR<CapabilityUpdateToOneWithWhereWithoutPorterCapabilitiesInput, CapabilityUpdateWithoutPorterCapabilitiesInput>, CapabilityUncheckedUpdateWithoutPorterCapabilitiesInput>
  }

  export type DepartmentCreateNestedOneWithoutDepartmentCapabilitiesInput = {
    create?: XOR<DepartmentCreateWithoutDepartmentCapabilitiesInput, DepartmentUncheckedCreateWithoutDepartmentCapabilitiesInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutDepartmentCapabilitiesInput
    connect?: DepartmentWhereUniqueInput
  }

  export type CapabilityCreateNestedOneWithoutDepartmentCapabilitiesInput = {
    create?: XOR<CapabilityCreateWithoutDepartmentCapabilitiesInput, CapabilityUncheckedCreateWithoutDepartmentCapabilitiesInput>
    connectOrCreate?: CapabilityCreateOrConnectWithoutDepartmentCapabilitiesInput
    connect?: CapabilityWhereUniqueInput
  }

  export type EnumRequiredLevelFieldUpdateOperationsInput = {
    set?: $Enums.RequiredLevel
  }

  export type DepartmentUpdateOneRequiredWithoutDepartmentCapabilitiesNestedInput = {
    create?: XOR<DepartmentCreateWithoutDepartmentCapabilitiesInput, DepartmentUncheckedCreateWithoutDepartmentCapabilitiesInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutDepartmentCapabilitiesInput
    upsert?: DepartmentUpsertWithoutDepartmentCapabilitiesInput
    connect?: DepartmentWhereUniqueInput
    update?: XOR<XOR<DepartmentUpdateToOneWithWhereWithoutDepartmentCapabilitiesInput, DepartmentUpdateWithoutDepartmentCapabilitiesInput>, DepartmentUncheckedUpdateWithoutDepartmentCapabilitiesInput>
  }

  export type CapabilityUpdateOneRequiredWithoutDepartmentCapabilitiesNestedInput = {
    create?: XOR<CapabilityCreateWithoutDepartmentCapabilitiesInput, CapabilityUncheckedCreateWithoutDepartmentCapabilitiesInput>
    connectOrCreate?: CapabilityCreateOrConnectWithoutDepartmentCapabilitiesInput
    upsert?: CapabilityUpsertWithoutDepartmentCapabilitiesInput
    connect?: CapabilityWhereUniqueInput
    update?: XOR<XOR<CapabilityUpdateToOneWithWhereWithoutDepartmentCapabilitiesInput, CapabilityUpdateWithoutDepartmentCapabilitiesInput>, CapabilityUncheckedUpdateWithoutDepartmentCapabilitiesInput>
  }

  export type ServiceCreateNestedOneWithoutServiceCapabilitiesInput = {
    create?: XOR<ServiceCreateWithoutServiceCapabilitiesInput, ServiceUncheckedCreateWithoutServiceCapabilitiesInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutServiceCapabilitiesInput
    connect?: ServiceWhereUniqueInput
  }

  export type CapabilityCreateNestedOneWithoutServiceCapabilitiesInput = {
    create?: XOR<CapabilityCreateWithoutServiceCapabilitiesInput, CapabilityUncheckedCreateWithoutServiceCapabilitiesInput>
    connectOrCreate?: CapabilityCreateOrConnectWithoutServiceCapabilitiesInput
    connect?: CapabilityWhereUniqueInput
  }

  export type ServiceUpdateOneRequiredWithoutServiceCapabilitiesNestedInput = {
    create?: XOR<ServiceCreateWithoutServiceCapabilitiesInput, ServiceUncheckedCreateWithoutServiceCapabilitiesInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutServiceCapabilitiesInput
    upsert?: ServiceUpsertWithoutServiceCapabilitiesInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutServiceCapabilitiesInput, ServiceUpdateWithoutServiceCapabilitiesInput>, ServiceUncheckedUpdateWithoutServiceCapabilitiesInput>
  }

  export type CapabilityUpdateOneRequiredWithoutServiceCapabilitiesNestedInput = {
    create?: XOR<CapabilityCreateWithoutServiceCapabilitiesInput, CapabilityUncheckedCreateWithoutServiceCapabilitiesInput>
    connectOrCreate?: CapabilityCreateOrConnectWithoutServiceCapabilitiesInput
    upsert?: CapabilityUpsertWithoutServiceCapabilitiesInput
    connect?: CapabilityWhereUniqueInput
    update?: XOR<XOR<CapabilityUpdateToOneWithWhereWithoutServiceCapabilitiesInput, CapabilityUpdateWithoutServiceCapabilitiesInput>, CapabilityUncheckedUpdateWithoutServiceCapabilitiesInput>
  }

  export type PorterCreateNestedOneWithoutAllocationsInput = {
    create?: XOR<PorterCreateWithoutAllocationsInput, PorterUncheckedCreateWithoutAllocationsInput>
    connectOrCreate?: PorterCreateOrConnectWithoutAllocationsInput
    connect?: PorterWhereUniqueInput
  }

  export type DepartmentCreateNestedOneWithoutAllocationsInput = {
    create?: XOR<DepartmentCreateWithoutAllocationsInput, DepartmentUncheckedCreateWithoutAllocationsInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutAllocationsInput
    connect?: DepartmentWhereUniqueInput
  }

  export type ServiceCreateNestedOneWithoutAllocationsInput = {
    create?: XOR<ServiceCreateWithoutAllocationsInput, ServiceUncheckedCreateWithoutAllocationsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutAllocationsInput
    connect?: ServiceWhereUniqueInput
  }

  export type EnumAllocationTypeFieldUpdateOperationsInput = {
    set?: $Enums.AllocationType
  }

  export type PorterUpdateOneRequiredWithoutAllocationsNestedInput = {
    create?: XOR<PorterCreateWithoutAllocationsInput, PorterUncheckedCreateWithoutAllocationsInput>
    connectOrCreate?: PorterCreateOrConnectWithoutAllocationsInput
    upsert?: PorterUpsertWithoutAllocationsInput
    connect?: PorterWhereUniqueInput
    update?: XOR<XOR<PorterUpdateToOneWithWhereWithoutAllocationsInput, PorterUpdateWithoutAllocationsInput>, PorterUncheckedUpdateWithoutAllocationsInput>
  }

  export type DepartmentUpdateOneRequiredWithoutAllocationsNestedInput = {
    create?: XOR<DepartmentCreateWithoutAllocationsInput, DepartmentUncheckedCreateWithoutAllocationsInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutAllocationsInput
    upsert?: DepartmentUpsertWithoutAllocationsInput
    connect?: DepartmentWhereUniqueInput
    update?: XOR<XOR<DepartmentUpdateToOneWithWhereWithoutAllocationsInput, DepartmentUpdateWithoutAllocationsInput>, DepartmentUncheckedUpdateWithoutAllocationsInput>
  }

  export type ServiceUpdateOneWithoutAllocationsNestedInput = {
    create?: XOR<ServiceCreateWithoutAllocationsInput, ServiceUncheckedCreateWithoutAllocationsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutAllocationsInput
    upsert?: ServiceUpsertWithoutAllocationsInput
    disconnect?: ServiceWhereInput | boolean
    delete?: ServiceWhereInput | boolean
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutAllocationsInput, ServiceUpdateWithoutAllocationsInput>, ServiceUncheckedUpdateWithoutAllocationsInput>
  }

  export type PorterCreateNestedOneWithoutAvailabilityInput = {
    create?: XOR<PorterCreateWithoutAvailabilityInput, PorterUncheckedCreateWithoutAvailabilityInput>
    connectOrCreate?: PorterCreateOrConnectWithoutAvailabilityInput
    connect?: PorterWhereUniqueInput
  }

  export type EnumAvailabilityStatusFieldUpdateOperationsInput = {
    set?: $Enums.AvailabilityStatus
  }

  export type PorterUpdateOneRequiredWithoutAvailabilityNestedInput = {
    create?: XOR<PorterCreateWithoutAvailabilityInput, PorterUncheckedCreateWithoutAvailabilityInput>
    connectOrCreate?: PorterCreateOrConnectWithoutAvailabilityInput
    upsert?: PorterUpsertWithoutAvailabilityInput
    connect?: PorterWhereUniqueInput
    update?: XOR<XOR<PorterUpdateToOneWithWhereWithoutAvailabilityInput, PorterUpdateWithoutAvailabilityInput>, PorterUncheckedUpdateWithoutAvailabilityInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumContractTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ContractType | EnumContractTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContractType[]
    notIn?: $Enums.ContractType[]
    not?: NestedEnumContractTypeFilter<$PrismaModel> | $Enums.ContractType
  }

  export type NestedEnumPorterTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PorterType | EnumPorterTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PorterType[]
    notIn?: $Enums.PorterType[]
    not?: NestedEnumPorterTypeFilter<$PrismaModel> | $Enums.PorterType
  }

  export type NestedEnumContractTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContractType | EnumContractTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContractType[]
    notIn?: $Enums.ContractType[]
    not?: NestedEnumContractTypeWithAggregatesFilter<$PrismaModel> | $Enums.ContractType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContractTypeFilter<$PrismaModel>
    _max?: NestedEnumContractTypeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumPorterTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PorterType | EnumPorterTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PorterType[]
    notIn?: $Enums.PorterType[]
    not?: NestedEnumPorterTypeWithAggregatesFilter<$PrismaModel> | $Enums.PorterType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPorterTypeFilter<$PrismaModel>
    _max?: NestedEnumPorterTypeFilter<$PrismaModel>
  }

  export type NestedEnumShiftModeFilter<$PrismaModel = never> = {
    equals?: $Enums.ShiftMode | EnumShiftModeFieldRefInput<$PrismaModel>
    in?: $Enums.ShiftMode[]
    notIn?: $Enums.ShiftMode[]
    not?: NestedEnumShiftModeFilter<$PrismaModel> | $Enums.ShiftMode
  }

  export type NestedEnumShiftModeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ShiftMode | EnumShiftModeFieldRefInput<$PrismaModel>
    in?: $Enums.ShiftMode[]
    notIn?: $Enums.ShiftMode[]
    not?: NestedEnumShiftModeWithAggregatesFilter<$PrismaModel> | $Enums.ShiftMode
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumShiftModeFilter<$PrismaModel>
    _max?: NestedEnumShiftModeFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumDayOfWeekFilter<$PrismaModel = never> = {
    equals?: $Enums.DayOfWeek | EnumDayOfWeekFieldRefInput<$PrismaModel>
    in?: $Enums.DayOfWeek[]
    notIn?: $Enums.DayOfWeek[]
    not?: NestedEnumDayOfWeekFilter<$PrismaModel> | $Enums.DayOfWeek
  }

  export type NestedEnumDayOfWeekWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DayOfWeek | EnumDayOfWeekFieldRefInput<$PrismaModel>
    in?: $Enums.DayOfWeek[]
    notIn?: $Enums.DayOfWeek[]
    not?: NestedEnumDayOfWeekWithAggregatesFilter<$PrismaModel> | $Enums.DayOfWeek
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDayOfWeekFilter<$PrismaModel>
    _max?: NestedEnumDayOfWeekFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumRequiredLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.RequiredLevel | EnumRequiredLevelFieldRefInput<$PrismaModel>
    in?: $Enums.RequiredLevel[]
    notIn?: $Enums.RequiredLevel[]
    not?: NestedEnumRequiredLevelFilter<$PrismaModel> | $Enums.RequiredLevel
  }

  export type NestedEnumRequiredLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RequiredLevel | EnumRequiredLevelFieldRefInput<$PrismaModel>
    in?: $Enums.RequiredLevel[]
    notIn?: $Enums.RequiredLevel[]
    not?: NestedEnumRequiredLevelWithAggregatesFilter<$PrismaModel> | $Enums.RequiredLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRequiredLevelFilter<$PrismaModel>
    _max?: NestedEnumRequiredLevelFilter<$PrismaModel>
  }

  export type NestedEnumAllocationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AllocationType | EnumAllocationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AllocationType[]
    notIn?: $Enums.AllocationType[]
    not?: NestedEnumAllocationTypeFilter<$PrismaModel> | $Enums.AllocationType
  }

  export type NestedEnumAllocationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AllocationType | EnumAllocationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AllocationType[]
    notIn?: $Enums.AllocationType[]
    not?: NestedEnumAllocationTypeWithAggregatesFilter<$PrismaModel> | $Enums.AllocationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAllocationTypeFilter<$PrismaModel>
    _max?: NestedEnumAllocationTypeFilter<$PrismaModel>
  }

  export type NestedEnumAvailabilityStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AvailabilityStatus | EnumAvailabilityStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AvailabilityStatus[]
    notIn?: $Enums.AvailabilityStatus[]
    not?: NestedEnumAvailabilityStatusFilter<$PrismaModel> | $Enums.AvailabilityStatus
  }

  export type NestedEnumAvailabilityStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AvailabilityStatus | EnumAvailabilityStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AvailabilityStatus[]
    notIn?: $Enums.AvailabilityStatus[]
    not?: NestedEnumAvailabilityStatusWithAggregatesFilter<$PrismaModel> | $Enums.AvailabilityStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAvailabilityStatusFilter<$PrismaModel>
    _max?: NestedEnumAvailabilityStatusFilter<$PrismaModel>
  }

  export type DepartmentCreateWithoutBuildingInput = {
    id?: string
    name: string
    description?: string | null
    is247?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    schedule?: DepartmentScheduleCreateNestedOneWithoutDepartmentsInput
    services?: ServiceCreateNestedManyWithoutDepartmentInput
    porters?: PorterCreateNestedManyWithoutRegularDepartmentInput
    allocations?: AllocationCreateNestedManyWithoutDepartmentInput
    departmentCapabilities?: DepartmentCapabilityCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutBuildingInput = {
    id?: string
    name: string
    scheduleId?: string | null
    description?: string | null
    is247?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ServiceUncheckedCreateNestedManyWithoutDepartmentInput
    porters?: PorterUncheckedCreateNestedManyWithoutRegularDepartmentInput
    allocations?: AllocationUncheckedCreateNestedManyWithoutDepartmentInput
    departmentCapabilities?: DepartmentCapabilityUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutBuildingInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutBuildingInput, DepartmentUncheckedCreateWithoutBuildingInput>
  }

  export type DepartmentCreateManyBuildingInputEnvelope = {
    data: DepartmentCreateManyBuildingInput | DepartmentCreateManyBuildingInput[]
    skipDuplicates?: boolean
  }

  export type DepartmentUpsertWithWhereUniqueWithoutBuildingInput = {
    where: DepartmentWhereUniqueInput
    update: XOR<DepartmentUpdateWithoutBuildingInput, DepartmentUncheckedUpdateWithoutBuildingInput>
    create: XOR<DepartmentCreateWithoutBuildingInput, DepartmentUncheckedCreateWithoutBuildingInput>
  }

  export type DepartmentUpdateWithWhereUniqueWithoutBuildingInput = {
    where: DepartmentWhereUniqueInput
    data: XOR<DepartmentUpdateWithoutBuildingInput, DepartmentUncheckedUpdateWithoutBuildingInput>
  }

  export type DepartmentUpdateManyWithWhereWithoutBuildingInput = {
    where: DepartmentScalarWhereInput
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyWithoutBuildingInput>
  }

  export type DepartmentScalarWhereInput = {
    AND?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
    OR?: DepartmentScalarWhereInput[]
    NOT?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
    id?: StringFilter<"Department"> | string
    name?: StringFilter<"Department"> | string
    buildingId?: StringFilter<"Department"> | string
    scheduleId?: StringNullableFilter<"Department"> | string | null
    description?: StringNullableFilter<"Department"> | string | null
    is247?: BoolFilter<"Department"> | boolean
    createdAt?: DateTimeFilter<"Department"> | Date | string
    updatedAt?: DateTimeFilter<"Department"> | Date | string
  }

  export type BuildingCreateWithoutDepartmentsInput = {
    id?: string
    name: string
    location?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BuildingUncheckedCreateWithoutDepartmentsInput = {
    id?: string
    name: string
    location?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BuildingCreateOrConnectWithoutDepartmentsInput = {
    where: BuildingWhereUniqueInput
    create: XOR<BuildingCreateWithoutDepartmentsInput, BuildingUncheckedCreateWithoutDepartmentsInput>
  }

  export type DepartmentScheduleCreateWithoutDepartmentsInput = {
    id?: string
    name: string
    patternId?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    periods?: DepartmentSchedulePeriodCreateNestedManyWithoutScheduleInput
  }

  export type DepartmentScheduleUncheckedCreateWithoutDepartmentsInput = {
    id?: string
    name: string
    patternId?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    periods?: DepartmentSchedulePeriodUncheckedCreateNestedManyWithoutScheduleInput
  }

  export type DepartmentScheduleCreateOrConnectWithoutDepartmentsInput = {
    where: DepartmentScheduleWhereUniqueInput
    create: XOR<DepartmentScheduleCreateWithoutDepartmentsInput, DepartmentScheduleUncheckedCreateWithoutDepartmentsInput>
  }

  export type ServiceCreateWithoutDepartmentInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    inheritsSchedule?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    allocations?: AllocationCreateNestedManyWithoutServiceInput
    serviceCapabilities?: ServiceCapabilityCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutDepartmentInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    inheritsSchedule?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    allocations?: AllocationUncheckedCreateNestedManyWithoutServiceInput
    serviceCapabilities?: ServiceCapabilityUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutDepartmentInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutDepartmentInput, ServiceUncheckedCreateWithoutDepartmentInput>
  }

  export type ServiceCreateManyDepartmentInputEnvelope = {
    data: ServiceCreateManyDepartmentInput | ServiceCreateManyDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type PorterCreateWithoutRegularDepartmentInput = {
    id?: string
    name: string
    contractType: $Enums.ContractType
    weeklyMinHours?: number | null
    contractedHours?: number | null
    porterType?: $Enums.PorterType
    countsTowardsStaffing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    shift?: ShiftCreateNestedOneWithoutPortersInput
    allocations?: AllocationCreateNestedManyWithoutPorterInput
    availability?: AvailabilityCreateNestedManyWithoutPorterInput
    porterCapabilities?: PorterCapabilityCreateNestedManyWithoutPorterInput
  }

  export type PorterUncheckedCreateWithoutRegularDepartmentInput = {
    id?: string
    name: string
    contractType: $Enums.ContractType
    shiftId?: string | null
    weeklyMinHours?: number | null
    contractedHours?: number | null
    porterType?: $Enums.PorterType
    countsTowardsStaffing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    allocations?: AllocationUncheckedCreateNestedManyWithoutPorterInput
    availability?: AvailabilityUncheckedCreateNestedManyWithoutPorterInput
    porterCapabilities?: PorterCapabilityUncheckedCreateNestedManyWithoutPorterInput
  }

  export type PorterCreateOrConnectWithoutRegularDepartmentInput = {
    where: PorterWhereUniqueInput
    create: XOR<PorterCreateWithoutRegularDepartmentInput, PorterUncheckedCreateWithoutRegularDepartmentInput>
  }

  export type PorterCreateManyRegularDepartmentInputEnvelope = {
    data: PorterCreateManyRegularDepartmentInput | PorterCreateManyRegularDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type AllocationCreateWithoutDepartmentInput = {
    id?: string
    startDatetime: Date | string
    endDatetime?: Date | string | null
    type: $Enums.AllocationType
    reason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    porter: PorterCreateNestedOneWithoutAllocationsInput
    service?: ServiceCreateNestedOneWithoutAllocationsInput
  }

  export type AllocationUncheckedCreateWithoutDepartmentInput = {
    id?: string
    porterId: string
    serviceId?: string | null
    startDatetime: Date | string
    endDatetime?: Date | string | null
    type: $Enums.AllocationType
    reason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AllocationCreateOrConnectWithoutDepartmentInput = {
    where: AllocationWhereUniqueInput
    create: XOR<AllocationCreateWithoutDepartmentInput, AllocationUncheckedCreateWithoutDepartmentInput>
  }

  export type AllocationCreateManyDepartmentInputEnvelope = {
    data: AllocationCreateManyDepartmentInput | AllocationCreateManyDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type DepartmentCapabilityCreateWithoutDepartmentInput = {
    requiredLevel: $Enums.RequiredLevel
    capability: CapabilityCreateNestedOneWithoutDepartmentCapabilitiesInput
  }

  export type DepartmentCapabilityUncheckedCreateWithoutDepartmentInput = {
    capabilityId: string
    requiredLevel: $Enums.RequiredLevel
  }

  export type DepartmentCapabilityCreateOrConnectWithoutDepartmentInput = {
    where: DepartmentCapabilityWhereUniqueInput
    create: XOR<DepartmentCapabilityCreateWithoutDepartmentInput, DepartmentCapabilityUncheckedCreateWithoutDepartmentInput>
  }

  export type DepartmentCapabilityCreateManyDepartmentInputEnvelope = {
    data: DepartmentCapabilityCreateManyDepartmentInput | DepartmentCapabilityCreateManyDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type BuildingUpsertWithoutDepartmentsInput = {
    update: XOR<BuildingUpdateWithoutDepartmentsInput, BuildingUncheckedUpdateWithoutDepartmentsInput>
    create: XOR<BuildingCreateWithoutDepartmentsInput, BuildingUncheckedCreateWithoutDepartmentsInput>
    where?: BuildingWhereInput
  }

  export type BuildingUpdateToOneWithWhereWithoutDepartmentsInput = {
    where?: BuildingWhereInput
    data: XOR<BuildingUpdateWithoutDepartmentsInput, BuildingUncheckedUpdateWithoutDepartmentsInput>
  }

  export type BuildingUpdateWithoutDepartmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BuildingUncheckedUpdateWithoutDepartmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentScheduleUpsertWithoutDepartmentsInput = {
    update: XOR<DepartmentScheduleUpdateWithoutDepartmentsInput, DepartmentScheduleUncheckedUpdateWithoutDepartmentsInput>
    create: XOR<DepartmentScheduleCreateWithoutDepartmentsInput, DepartmentScheduleUncheckedCreateWithoutDepartmentsInput>
    where?: DepartmentScheduleWhereInput
  }

  export type DepartmentScheduleUpdateToOneWithWhereWithoutDepartmentsInput = {
    where?: DepartmentScheduleWhereInput
    data: XOR<DepartmentScheduleUpdateWithoutDepartmentsInput, DepartmentScheduleUncheckedUpdateWithoutDepartmentsInput>
  }

  export type DepartmentScheduleUpdateWithoutDepartmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    patternId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    periods?: DepartmentSchedulePeriodUpdateManyWithoutScheduleNestedInput
  }

  export type DepartmentScheduleUncheckedUpdateWithoutDepartmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    patternId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    periods?: DepartmentSchedulePeriodUncheckedUpdateManyWithoutScheduleNestedInput
  }

  export type ServiceUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: ServiceWhereUniqueInput
    update: XOR<ServiceUpdateWithoutDepartmentInput, ServiceUncheckedUpdateWithoutDepartmentInput>
    create: XOR<ServiceCreateWithoutDepartmentInput, ServiceUncheckedCreateWithoutDepartmentInput>
  }

  export type ServiceUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: ServiceWhereUniqueInput
    data: XOR<ServiceUpdateWithoutDepartmentInput, ServiceUncheckedUpdateWithoutDepartmentInput>
  }

  export type ServiceUpdateManyWithWhereWithoutDepartmentInput = {
    where: ServiceScalarWhereInput
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyWithoutDepartmentInput>
  }

  export type ServiceScalarWhereInput = {
    AND?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
    OR?: ServiceScalarWhereInput[]
    NOT?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
    id?: StringFilter<"Service"> | string
    name?: StringFilter<"Service"> | string
    departmentId?: StringFilter<"Service"> | string
    description?: StringNullableFilter<"Service"> | string | null
    isActive?: BoolFilter<"Service"> | boolean
    inheritsSchedule?: BoolFilter<"Service"> | boolean
    createdAt?: DateTimeFilter<"Service"> | Date | string
    updatedAt?: DateTimeFilter<"Service"> | Date | string
  }

  export type PorterUpsertWithWhereUniqueWithoutRegularDepartmentInput = {
    where: PorterWhereUniqueInput
    update: XOR<PorterUpdateWithoutRegularDepartmentInput, PorterUncheckedUpdateWithoutRegularDepartmentInput>
    create: XOR<PorterCreateWithoutRegularDepartmentInput, PorterUncheckedCreateWithoutRegularDepartmentInput>
  }

  export type PorterUpdateWithWhereUniqueWithoutRegularDepartmentInput = {
    where: PorterWhereUniqueInput
    data: XOR<PorterUpdateWithoutRegularDepartmentInput, PorterUncheckedUpdateWithoutRegularDepartmentInput>
  }

  export type PorterUpdateManyWithWhereWithoutRegularDepartmentInput = {
    where: PorterScalarWhereInput
    data: XOR<PorterUpdateManyMutationInput, PorterUncheckedUpdateManyWithoutRegularDepartmentInput>
  }

  export type PorterScalarWhereInput = {
    AND?: PorterScalarWhereInput | PorterScalarWhereInput[]
    OR?: PorterScalarWhereInput[]
    NOT?: PorterScalarWhereInput | PorterScalarWhereInput[]
    id?: StringFilter<"Porter"> | string
    name?: StringFilter<"Porter"> | string
    contractType?: EnumContractTypeFilter<"Porter"> | $Enums.ContractType
    shiftId?: StringNullableFilter<"Porter"> | string | null
    weeklyMinHours?: IntNullableFilter<"Porter"> | number | null
    contractedHours?: IntNullableFilter<"Porter"> | number | null
    regularDepartmentId?: StringNullableFilter<"Porter"> | string | null
    porterType?: EnumPorterTypeFilter<"Porter"> | $Enums.PorterType
    countsTowardsStaffing?: BoolFilter<"Porter"> | boolean
    createdAt?: DateTimeFilter<"Porter"> | Date | string
    updatedAt?: DateTimeFilter<"Porter"> | Date | string
  }

  export type AllocationUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: AllocationWhereUniqueInput
    update: XOR<AllocationUpdateWithoutDepartmentInput, AllocationUncheckedUpdateWithoutDepartmentInput>
    create: XOR<AllocationCreateWithoutDepartmentInput, AllocationUncheckedCreateWithoutDepartmentInput>
  }

  export type AllocationUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: AllocationWhereUniqueInput
    data: XOR<AllocationUpdateWithoutDepartmentInput, AllocationUncheckedUpdateWithoutDepartmentInput>
  }

  export type AllocationUpdateManyWithWhereWithoutDepartmentInput = {
    where: AllocationScalarWhereInput
    data: XOR<AllocationUpdateManyMutationInput, AllocationUncheckedUpdateManyWithoutDepartmentInput>
  }

  export type AllocationScalarWhereInput = {
    AND?: AllocationScalarWhereInput | AllocationScalarWhereInput[]
    OR?: AllocationScalarWhereInput[]
    NOT?: AllocationScalarWhereInput | AllocationScalarWhereInput[]
    id?: StringFilter<"Allocation"> | string
    porterId?: StringFilter<"Allocation"> | string
    departmentId?: StringFilter<"Allocation"> | string
    serviceId?: StringNullableFilter<"Allocation"> | string | null
    startDatetime?: DateTimeFilter<"Allocation"> | Date | string
    endDatetime?: DateTimeNullableFilter<"Allocation"> | Date | string | null
    type?: EnumAllocationTypeFilter<"Allocation"> | $Enums.AllocationType
    reason?: StringNullableFilter<"Allocation"> | string | null
    createdAt?: DateTimeFilter<"Allocation"> | Date | string
    updatedAt?: DateTimeFilter<"Allocation"> | Date | string
  }

  export type DepartmentCapabilityUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: DepartmentCapabilityWhereUniqueInput
    update: XOR<DepartmentCapabilityUpdateWithoutDepartmentInput, DepartmentCapabilityUncheckedUpdateWithoutDepartmentInput>
    create: XOR<DepartmentCapabilityCreateWithoutDepartmentInput, DepartmentCapabilityUncheckedCreateWithoutDepartmentInput>
  }

  export type DepartmentCapabilityUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: DepartmentCapabilityWhereUniqueInput
    data: XOR<DepartmentCapabilityUpdateWithoutDepartmentInput, DepartmentCapabilityUncheckedUpdateWithoutDepartmentInput>
  }

  export type DepartmentCapabilityUpdateManyWithWhereWithoutDepartmentInput = {
    where: DepartmentCapabilityScalarWhereInput
    data: XOR<DepartmentCapabilityUpdateManyMutationInput, DepartmentCapabilityUncheckedUpdateManyWithoutDepartmentInput>
  }

  export type DepartmentCapabilityScalarWhereInput = {
    AND?: DepartmentCapabilityScalarWhereInput | DepartmentCapabilityScalarWhereInput[]
    OR?: DepartmentCapabilityScalarWhereInput[]
    NOT?: DepartmentCapabilityScalarWhereInput | DepartmentCapabilityScalarWhereInput[]
    departmentId?: StringFilter<"DepartmentCapability"> | string
    capabilityId?: StringFilter<"DepartmentCapability"> | string
    requiredLevel?: EnumRequiredLevelFilter<"DepartmentCapability"> | $Enums.RequiredLevel
  }

  export type DepartmentCreateWithoutServicesInput = {
    id?: string
    name: string
    description?: string | null
    is247?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    building: BuildingCreateNestedOneWithoutDepartmentsInput
    schedule?: DepartmentScheduleCreateNestedOneWithoutDepartmentsInput
    porters?: PorterCreateNestedManyWithoutRegularDepartmentInput
    allocations?: AllocationCreateNestedManyWithoutDepartmentInput
    departmentCapabilities?: DepartmentCapabilityCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutServicesInput = {
    id?: string
    name: string
    buildingId: string
    scheduleId?: string | null
    description?: string | null
    is247?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    porters?: PorterUncheckedCreateNestedManyWithoutRegularDepartmentInput
    allocations?: AllocationUncheckedCreateNestedManyWithoutDepartmentInput
    departmentCapabilities?: DepartmentCapabilityUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutServicesInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutServicesInput, DepartmentUncheckedCreateWithoutServicesInput>
  }

  export type AllocationCreateWithoutServiceInput = {
    id?: string
    startDatetime: Date | string
    endDatetime?: Date | string | null
    type: $Enums.AllocationType
    reason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    porter: PorterCreateNestedOneWithoutAllocationsInput
    department: DepartmentCreateNestedOneWithoutAllocationsInput
  }

  export type AllocationUncheckedCreateWithoutServiceInput = {
    id?: string
    porterId: string
    departmentId: string
    startDatetime: Date | string
    endDatetime?: Date | string | null
    type: $Enums.AllocationType
    reason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AllocationCreateOrConnectWithoutServiceInput = {
    where: AllocationWhereUniqueInput
    create: XOR<AllocationCreateWithoutServiceInput, AllocationUncheckedCreateWithoutServiceInput>
  }

  export type AllocationCreateManyServiceInputEnvelope = {
    data: AllocationCreateManyServiceInput | AllocationCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type ServiceCapabilityCreateWithoutServiceInput = {
    requiredLevel: $Enums.RequiredLevel
    capability: CapabilityCreateNestedOneWithoutServiceCapabilitiesInput
  }

  export type ServiceCapabilityUncheckedCreateWithoutServiceInput = {
    capabilityId: string
    requiredLevel: $Enums.RequiredLevel
  }

  export type ServiceCapabilityCreateOrConnectWithoutServiceInput = {
    where: ServiceCapabilityWhereUniqueInput
    create: XOR<ServiceCapabilityCreateWithoutServiceInput, ServiceCapabilityUncheckedCreateWithoutServiceInput>
  }

  export type ServiceCapabilityCreateManyServiceInputEnvelope = {
    data: ServiceCapabilityCreateManyServiceInput | ServiceCapabilityCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type DepartmentUpsertWithoutServicesInput = {
    update: XOR<DepartmentUpdateWithoutServicesInput, DepartmentUncheckedUpdateWithoutServicesInput>
    create: XOR<DepartmentCreateWithoutServicesInput, DepartmentUncheckedCreateWithoutServicesInput>
    where?: DepartmentWhereInput
  }

  export type DepartmentUpdateToOneWithWhereWithoutServicesInput = {
    where?: DepartmentWhereInput
    data: XOR<DepartmentUpdateWithoutServicesInput, DepartmentUncheckedUpdateWithoutServicesInput>
  }

  export type DepartmentUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is247?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    building?: BuildingUpdateOneRequiredWithoutDepartmentsNestedInput
    schedule?: DepartmentScheduleUpdateOneWithoutDepartmentsNestedInput
    porters?: PorterUpdateManyWithoutRegularDepartmentNestedInput
    allocations?: AllocationUpdateManyWithoutDepartmentNestedInput
    departmentCapabilities?: DepartmentCapabilityUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    buildingId?: StringFieldUpdateOperationsInput | string
    scheduleId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is247?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    porters?: PorterUncheckedUpdateManyWithoutRegularDepartmentNestedInput
    allocations?: AllocationUncheckedUpdateManyWithoutDepartmentNestedInput
    departmentCapabilities?: DepartmentCapabilityUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type AllocationUpsertWithWhereUniqueWithoutServiceInput = {
    where: AllocationWhereUniqueInput
    update: XOR<AllocationUpdateWithoutServiceInput, AllocationUncheckedUpdateWithoutServiceInput>
    create: XOR<AllocationCreateWithoutServiceInput, AllocationUncheckedCreateWithoutServiceInput>
  }

  export type AllocationUpdateWithWhereUniqueWithoutServiceInput = {
    where: AllocationWhereUniqueInput
    data: XOR<AllocationUpdateWithoutServiceInput, AllocationUncheckedUpdateWithoutServiceInput>
  }

  export type AllocationUpdateManyWithWhereWithoutServiceInput = {
    where: AllocationScalarWhereInput
    data: XOR<AllocationUpdateManyMutationInput, AllocationUncheckedUpdateManyWithoutServiceInput>
  }

  export type ServiceCapabilityUpsertWithWhereUniqueWithoutServiceInput = {
    where: ServiceCapabilityWhereUniqueInput
    update: XOR<ServiceCapabilityUpdateWithoutServiceInput, ServiceCapabilityUncheckedUpdateWithoutServiceInput>
    create: XOR<ServiceCapabilityCreateWithoutServiceInput, ServiceCapabilityUncheckedCreateWithoutServiceInput>
  }

  export type ServiceCapabilityUpdateWithWhereUniqueWithoutServiceInput = {
    where: ServiceCapabilityWhereUniqueInput
    data: XOR<ServiceCapabilityUpdateWithoutServiceInput, ServiceCapabilityUncheckedUpdateWithoutServiceInput>
  }

  export type ServiceCapabilityUpdateManyWithWhereWithoutServiceInput = {
    where: ServiceCapabilityScalarWhereInput
    data: XOR<ServiceCapabilityUpdateManyMutationInput, ServiceCapabilityUncheckedUpdateManyWithoutServiceInput>
  }

  export type ServiceCapabilityScalarWhereInput = {
    AND?: ServiceCapabilityScalarWhereInput | ServiceCapabilityScalarWhereInput[]
    OR?: ServiceCapabilityScalarWhereInput[]
    NOT?: ServiceCapabilityScalarWhereInput | ServiceCapabilityScalarWhereInput[]
    serviceId?: StringFilter<"ServiceCapability"> | string
    capabilityId?: StringFilter<"ServiceCapability"> | string
    requiredLevel?: EnumRequiredLevelFilter<"ServiceCapability"> | $Enums.RequiredLevel
  }

  export type ShiftCreateWithoutPortersInput = {
    id?: string
    name: string
    shiftMode: $Enums.ShiftMode
    ident: string
    daysOn: number
    daysOff: number
    offsetDays?: number
    groundZero: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    pattern: ShiftPatternCreateNestedOneWithoutShiftsInput
  }

  export type ShiftUncheckedCreateWithoutPortersInput = {
    id?: string
    name: string
    patternId: string
    shiftMode: $Enums.ShiftMode
    ident: string
    daysOn: number
    daysOff: number
    offsetDays?: number
    groundZero: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShiftCreateOrConnectWithoutPortersInput = {
    where: ShiftWhereUniqueInput
    create: XOR<ShiftCreateWithoutPortersInput, ShiftUncheckedCreateWithoutPortersInput>
  }

  export type DepartmentCreateWithoutPortersInput = {
    id?: string
    name: string
    description?: string | null
    is247?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    building: BuildingCreateNestedOneWithoutDepartmentsInput
    schedule?: DepartmentScheduleCreateNestedOneWithoutDepartmentsInput
    services?: ServiceCreateNestedManyWithoutDepartmentInput
    allocations?: AllocationCreateNestedManyWithoutDepartmentInput
    departmentCapabilities?: DepartmentCapabilityCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutPortersInput = {
    id?: string
    name: string
    buildingId: string
    scheduleId?: string | null
    description?: string | null
    is247?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ServiceUncheckedCreateNestedManyWithoutDepartmentInput
    allocations?: AllocationUncheckedCreateNestedManyWithoutDepartmentInput
    departmentCapabilities?: DepartmentCapabilityUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutPortersInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutPortersInput, DepartmentUncheckedCreateWithoutPortersInput>
  }

  export type AllocationCreateWithoutPorterInput = {
    id?: string
    startDatetime: Date | string
    endDatetime?: Date | string | null
    type: $Enums.AllocationType
    reason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department: DepartmentCreateNestedOneWithoutAllocationsInput
    service?: ServiceCreateNestedOneWithoutAllocationsInput
  }

  export type AllocationUncheckedCreateWithoutPorterInput = {
    id?: string
    departmentId: string
    serviceId?: string | null
    startDatetime: Date | string
    endDatetime?: Date | string | null
    type: $Enums.AllocationType
    reason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AllocationCreateOrConnectWithoutPorterInput = {
    where: AllocationWhereUniqueInput
    create: XOR<AllocationCreateWithoutPorterInput, AllocationUncheckedCreateWithoutPorterInput>
  }

  export type AllocationCreateManyPorterInputEnvelope = {
    data: AllocationCreateManyPorterInput | AllocationCreateManyPorterInput[]
    skipDuplicates?: boolean
  }

  export type AvailabilityCreateWithoutPorterInput = {
    id?: string
    startDatetime: Date | string
    endDatetime: Date | string
    status: $Enums.AvailabilityStatus
    reason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AvailabilityUncheckedCreateWithoutPorterInput = {
    id?: string
    startDatetime: Date | string
    endDatetime: Date | string
    status: $Enums.AvailabilityStatus
    reason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AvailabilityCreateOrConnectWithoutPorterInput = {
    where: AvailabilityWhereUniqueInput
    create: XOR<AvailabilityCreateWithoutPorterInput, AvailabilityUncheckedCreateWithoutPorterInput>
  }

  export type AvailabilityCreateManyPorterInputEnvelope = {
    data: AvailabilityCreateManyPorterInput | AvailabilityCreateManyPorterInput[]
    skipDuplicates?: boolean
  }

  export type PorterCapabilityCreateWithoutPorterInput = {
    expiryDate?: Date | string | null
    createdAt?: Date | string
    capability: CapabilityCreateNestedOneWithoutPorterCapabilitiesInput
  }

  export type PorterCapabilityUncheckedCreateWithoutPorterInput = {
    capabilityId: string
    expiryDate?: Date | string | null
    createdAt?: Date | string
  }

  export type PorterCapabilityCreateOrConnectWithoutPorterInput = {
    where: PorterCapabilityWhereUniqueInput
    create: XOR<PorterCapabilityCreateWithoutPorterInput, PorterCapabilityUncheckedCreateWithoutPorterInput>
  }

  export type PorterCapabilityCreateManyPorterInputEnvelope = {
    data: PorterCapabilityCreateManyPorterInput | PorterCapabilityCreateManyPorterInput[]
    skipDuplicates?: boolean
  }

  export type ShiftUpsertWithoutPortersInput = {
    update: XOR<ShiftUpdateWithoutPortersInput, ShiftUncheckedUpdateWithoutPortersInput>
    create: XOR<ShiftCreateWithoutPortersInput, ShiftUncheckedCreateWithoutPortersInput>
    where?: ShiftWhereInput
  }

  export type ShiftUpdateToOneWithWhereWithoutPortersInput = {
    where?: ShiftWhereInput
    data: XOR<ShiftUpdateWithoutPortersInput, ShiftUncheckedUpdateWithoutPortersInput>
  }

  export type ShiftUpdateWithoutPortersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shiftMode?: EnumShiftModeFieldUpdateOperationsInput | $Enums.ShiftMode
    ident?: StringFieldUpdateOperationsInput | string
    daysOn?: IntFieldUpdateOperationsInput | number
    daysOff?: IntFieldUpdateOperationsInput | number
    offsetDays?: IntFieldUpdateOperationsInput | number
    groundZero?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pattern?: ShiftPatternUpdateOneRequiredWithoutShiftsNestedInput
  }

  export type ShiftUncheckedUpdateWithoutPortersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    patternId?: StringFieldUpdateOperationsInput | string
    shiftMode?: EnumShiftModeFieldUpdateOperationsInput | $Enums.ShiftMode
    ident?: StringFieldUpdateOperationsInput | string
    daysOn?: IntFieldUpdateOperationsInput | number
    daysOff?: IntFieldUpdateOperationsInput | number
    offsetDays?: IntFieldUpdateOperationsInput | number
    groundZero?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentUpsertWithoutPortersInput = {
    update: XOR<DepartmentUpdateWithoutPortersInput, DepartmentUncheckedUpdateWithoutPortersInput>
    create: XOR<DepartmentCreateWithoutPortersInput, DepartmentUncheckedCreateWithoutPortersInput>
    where?: DepartmentWhereInput
  }

  export type DepartmentUpdateToOneWithWhereWithoutPortersInput = {
    where?: DepartmentWhereInput
    data: XOR<DepartmentUpdateWithoutPortersInput, DepartmentUncheckedUpdateWithoutPortersInput>
  }

  export type DepartmentUpdateWithoutPortersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is247?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    building?: BuildingUpdateOneRequiredWithoutDepartmentsNestedInput
    schedule?: DepartmentScheduleUpdateOneWithoutDepartmentsNestedInput
    services?: ServiceUpdateManyWithoutDepartmentNestedInput
    allocations?: AllocationUpdateManyWithoutDepartmentNestedInput
    departmentCapabilities?: DepartmentCapabilityUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutPortersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    buildingId?: StringFieldUpdateOperationsInput | string
    scheduleId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is247?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceUncheckedUpdateManyWithoutDepartmentNestedInput
    allocations?: AllocationUncheckedUpdateManyWithoutDepartmentNestedInput
    departmentCapabilities?: DepartmentCapabilityUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type AllocationUpsertWithWhereUniqueWithoutPorterInput = {
    where: AllocationWhereUniqueInput
    update: XOR<AllocationUpdateWithoutPorterInput, AllocationUncheckedUpdateWithoutPorterInput>
    create: XOR<AllocationCreateWithoutPorterInput, AllocationUncheckedCreateWithoutPorterInput>
  }

  export type AllocationUpdateWithWhereUniqueWithoutPorterInput = {
    where: AllocationWhereUniqueInput
    data: XOR<AllocationUpdateWithoutPorterInput, AllocationUncheckedUpdateWithoutPorterInput>
  }

  export type AllocationUpdateManyWithWhereWithoutPorterInput = {
    where: AllocationScalarWhereInput
    data: XOR<AllocationUpdateManyMutationInput, AllocationUncheckedUpdateManyWithoutPorterInput>
  }

  export type AvailabilityUpsertWithWhereUniqueWithoutPorterInput = {
    where: AvailabilityWhereUniqueInput
    update: XOR<AvailabilityUpdateWithoutPorterInput, AvailabilityUncheckedUpdateWithoutPorterInput>
    create: XOR<AvailabilityCreateWithoutPorterInput, AvailabilityUncheckedCreateWithoutPorterInput>
  }

  export type AvailabilityUpdateWithWhereUniqueWithoutPorterInput = {
    where: AvailabilityWhereUniqueInput
    data: XOR<AvailabilityUpdateWithoutPorterInput, AvailabilityUncheckedUpdateWithoutPorterInput>
  }

  export type AvailabilityUpdateManyWithWhereWithoutPorterInput = {
    where: AvailabilityScalarWhereInput
    data: XOR<AvailabilityUpdateManyMutationInput, AvailabilityUncheckedUpdateManyWithoutPorterInput>
  }

  export type AvailabilityScalarWhereInput = {
    AND?: AvailabilityScalarWhereInput | AvailabilityScalarWhereInput[]
    OR?: AvailabilityScalarWhereInput[]
    NOT?: AvailabilityScalarWhereInput | AvailabilityScalarWhereInput[]
    id?: StringFilter<"Availability"> | string
    porterId?: StringFilter<"Availability"> | string
    startDatetime?: DateTimeFilter<"Availability"> | Date | string
    endDatetime?: DateTimeFilter<"Availability"> | Date | string
    status?: EnumAvailabilityStatusFilter<"Availability"> | $Enums.AvailabilityStatus
    reason?: StringNullableFilter<"Availability"> | string | null
    createdAt?: DateTimeFilter<"Availability"> | Date | string
    updatedAt?: DateTimeFilter<"Availability"> | Date | string
  }

  export type PorterCapabilityUpsertWithWhereUniqueWithoutPorterInput = {
    where: PorterCapabilityWhereUniqueInput
    update: XOR<PorterCapabilityUpdateWithoutPorterInput, PorterCapabilityUncheckedUpdateWithoutPorterInput>
    create: XOR<PorterCapabilityCreateWithoutPorterInput, PorterCapabilityUncheckedCreateWithoutPorterInput>
  }

  export type PorterCapabilityUpdateWithWhereUniqueWithoutPorterInput = {
    where: PorterCapabilityWhereUniqueInput
    data: XOR<PorterCapabilityUpdateWithoutPorterInput, PorterCapabilityUncheckedUpdateWithoutPorterInput>
  }

  export type PorterCapabilityUpdateManyWithWhereWithoutPorterInput = {
    where: PorterCapabilityScalarWhereInput
    data: XOR<PorterCapabilityUpdateManyMutationInput, PorterCapabilityUncheckedUpdateManyWithoutPorterInput>
  }

  export type PorterCapabilityScalarWhereInput = {
    AND?: PorterCapabilityScalarWhereInput | PorterCapabilityScalarWhereInput[]
    OR?: PorterCapabilityScalarWhereInput[]
    NOT?: PorterCapabilityScalarWhereInput | PorterCapabilityScalarWhereInput[]
    porterId?: StringFilter<"PorterCapability"> | string
    capabilityId?: StringFilter<"PorterCapability"> | string
    expiryDate?: DateTimeNullableFilter<"PorterCapability"> | Date | string | null
    createdAt?: DateTimeFilter<"PorterCapability"> | Date | string
  }

  export type ShiftPatternCreateWithoutShiftsInput = {
    id?: string
    name: string
    patternJson: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShiftPatternUncheckedCreateWithoutShiftsInput = {
    id?: string
    name: string
    patternJson: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShiftPatternCreateOrConnectWithoutShiftsInput = {
    where: ShiftPatternWhereUniqueInput
    create: XOR<ShiftPatternCreateWithoutShiftsInput, ShiftPatternUncheckedCreateWithoutShiftsInput>
  }

  export type PorterCreateWithoutShiftInput = {
    id?: string
    name: string
    contractType: $Enums.ContractType
    weeklyMinHours?: number | null
    contractedHours?: number | null
    porterType?: $Enums.PorterType
    countsTowardsStaffing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    regularDepartment?: DepartmentCreateNestedOneWithoutPortersInput
    allocations?: AllocationCreateNestedManyWithoutPorterInput
    availability?: AvailabilityCreateNestedManyWithoutPorterInput
    porterCapabilities?: PorterCapabilityCreateNestedManyWithoutPorterInput
  }

  export type PorterUncheckedCreateWithoutShiftInput = {
    id?: string
    name: string
    contractType: $Enums.ContractType
    weeklyMinHours?: number | null
    contractedHours?: number | null
    regularDepartmentId?: string | null
    porterType?: $Enums.PorterType
    countsTowardsStaffing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    allocations?: AllocationUncheckedCreateNestedManyWithoutPorterInput
    availability?: AvailabilityUncheckedCreateNestedManyWithoutPorterInput
    porterCapabilities?: PorterCapabilityUncheckedCreateNestedManyWithoutPorterInput
  }

  export type PorterCreateOrConnectWithoutShiftInput = {
    where: PorterWhereUniqueInput
    create: XOR<PorterCreateWithoutShiftInput, PorterUncheckedCreateWithoutShiftInput>
  }

  export type PorterCreateManyShiftInputEnvelope = {
    data: PorterCreateManyShiftInput | PorterCreateManyShiftInput[]
    skipDuplicates?: boolean
  }

  export type ShiftPatternUpsertWithoutShiftsInput = {
    update: XOR<ShiftPatternUpdateWithoutShiftsInput, ShiftPatternUncheckedUpdateWithoutShiftsInput>
    create: XOR<ShiftPatternCreateWithoutShiftsInput, ShiftPatternUncheckedCreateWithoutShiftsInput>
    where?: ShiftPatternWhereInput
  }

  export type ShiftPatternUpdateToOneWithWhereWithoutShiftsInput = {
    where?: ShiftPatternWhereInput
    data: XOR<ShiftPatternUpdateWithoutShiftsInput, ShiftPatternUncheckedUpdateWithoutShiftsInput>
  }

  export type ShiftPatternUpdateWithoutShiftsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    patternJson?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftPatternUncheckedUpdateWithoutShiftsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    patternJson?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PorterUpsertWithWhereUniqueWithoutShiftInput = {
    where: PorterWhereUniqueInput
    update: XOR<PorterUpdateWithoutShiftInput, PorterUncheckedUpdateWithoutShiftInput>
    create: XOR<PorterCreateWithoutShiftInput, PorterUncheckedCreateWithoutShiftInput>
  }

  export type PorterUpdateWithWhereUniqueWithoutShiftInput = {
    where: PorterWhereUniqueInput
    data: XOR<PorterUpdateWithoutShiftInput, PorterUncheckedUpdateWithoutShiftInput>
  }

  export type PorterUpdateManyWithWhereWithoutShiftInput = {
    where: PorterScalarWhereInput
    data: XOR<PorterUpdateManyMutationInput, PorterUncheckedUpdateManyWithoutShiftInput>
  }

  export type ShiftCreateWithoutPatternInput = {
    id?: string
    name: string
    shiftMode: $Enums.ShiftMode
    ident: string
    daysOn: number
    daysOff: number
    offsetDays?: number
    groundZero: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    porters?: PorterCreateNestedManyWithoutShiftInput
  }

  export type ShiftUncheckedCreateWithoutPatternInput = {
    id?: string
    name: string
    shiftMode: $Enums.ShiftMode
    ident: string
    daysOn: number
    daysOff: number
    offsetDays?: number
    groundZero: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    porters?: PorterUncheckedCreateNestedManyWithoutShiftInput
  }

  export type ShiftCreateOrConnectWithoutPatternInput = {
    where: ShiftWhereUniqueInput
    create: XOR<ShiftCreateWithoutPatternInput, ShiftUncheckedCreateWithoutPatternInput>
  }

  export type ShiftCreateManyPatternInputEnvelope = {
    data: ShiftCreateManyPatternInput | ShiftCreateManyPatternInput[]
    skipDuplicates?: boolean
  }

  export type ShiftUpsertWithWhereUniqueWithoutPatternInput = {
    where: ShiftWhereUniqueInput
    update: XOR<ShiftUpdateWithoutPatternInput, ShiftUncheckedUpdateWithoutPatternInput>
    create: XOR<ShiftCreateWithoutPatternInput, ShiftUncheckedCreateWithoutPatternInput>
  }

  export type ShiftUpdateWithWhereUniqueWithoutPatternInput = {
    where: ShiftWhereUniqueInput
    data: XOR<ShiftUpdateWithoutPatternInput, ShiftUncheckedUpdateWithoutPatternInput>
  }

  export type ShiftUpdateManyWithWhereWithoutPatternInput = {
    where: ShiftScalarWhereInput
    data: XOR<ShiftUpdateManyMutationInput, ShiftUncheckedUpdateManyWithoutPatternInput>
  }

  export type ShiftScalarWhereInput = {
    AND?: ShiftScalarWhereInput | ShiftScalarWhereInput[]
    OR?: ShiftScalarWhereInput[]
    NOT?: ShiftScalarWhereInput | ShiftScalarWhereInput[]
    id?: StringFilter<"Shift"> | string
    name?: StringFilter<"Shift"> | string
    patternId?: StringFilter<"Shift"> | string
    shiftMode?: EnumShiftModeFilter<"Shift"> | $Enums.ShiftMode
    ident?: StringFilter<"Shift"> | string
    daysOn?: IntFilter<"Shift"> | number
    daysOff?: IntFilter<"Shift"> | number
    offsetDays?: IntFilter<"Shift"> | number
    groundZero?: DateTimeFilter<"Shift"> | Date | string
    createdAt?: DateTimeFilter<"Shift"> | Date | string
    updatedAt?: DateTimeFilter<"Shift"> | Date | string
  }

  export type DepartmentCreateWithoutScheduleInput = {
    id?: string
    name: string
    description?: string | null
    is247?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    building: BuildingCreateNestedOneWithoutDepartmentsInput
    services?: ServiceCreateNestedManyWithoutDepartmentInput
    porters?: PorterCreateNestedManyWithoutRegularDepartmentInput
    allocations?: AllocationCreateNestedManyWithoutDepartmentInput
    departmentCapabilities?: DepartmentCapabilityCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutScheduleInput = {
    id?: string
    name: string
    buildingId: string
    description?: string | null
    is247?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ServiceUncheckedCreateNestedManyWithoutDepartmentInput
    porters?: PorterUncheckedCreateNestedManyWithoutRegularDepartmentInput
    allocations?: AllocationUncheckedCreateNestedManyWithoutDepartmentInput
    departmentCapabilities?: DepartmentCapabilityUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutScheduleInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutScheduleInput, DepartmentUncheckedCreateWithoutScheduleInput>
  }

  export type DepartmentCreateManyScheduleInputEnvelope = {
    data: DepartmentCreateManyScheduleInput | DepartmentCreateManyScheduleInput[]
    skipDuplicates?: boolean
  }

  export type DepartmentSchedulePeriodCreateWithoutScheduleInput = {
    id?: string
    dayOfWeek: $Enums.DayOfWeek
    openTime: string
    closeTime: string
    requiredPorters: number
  }

  export type DepartmentSchedulePeriodUncheckedCreateWithoutScheduleInput = {
    id?: string
    dayOfWeek: $Enums.DayOfWeek
    openTime: string
    closeTime: string
    requiredPorters: number
  }

  export type DepartmentSchedulePeriodCreateOrConnectWithoutScheduleInput = {
    where: DepartmentSchedulePeriodWhereUniqueInput
    create: XOR<DepartmentSchedulePeriodCreateWithoutScheduleInput, DepartmentSchedulePeriodUncheckedCreateWithoutScheduleInput>
  }

  export type DepartmentSchedulePeriodCreateManyScheduleInputEnvelope = {
    data: DepartmentSchedulePeriodCreateManyScheduleInput | DepartmentSchedulePeriodCreateManyScheduleInput[]
    skipDuplicates?: boolean
  }

  export type DepartmentUpsertWithWhereUniqueWithoutScheduleInput = {
    where: DepartmentWhereUniqueInput
    update: XOR<DepartmentUpdateWithoutScheduleInput, DepartmentUncheckedUpdateWithoutScheduleInput>
    create: XOR<DepartmentCreateWithoutScheduleInput, DepartmentUncheckedCreateWithoutScheduleInput>
  }

  export type DepartmentUpdateWithWhereUniqueWithoutScheduleInput = {
    where: DepartmentWhereUniqueInput
    data: XOR<DepartmentUpdateWithoutScheduleInput, DepartmentUncheckedUpdateWithoutScheduleInput>
  }

  export type DepartmentUpdateManyWithWhereWithoutScheduleInput = {
    where: DepartmentScalarWhereInput
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyWithoutScheduleInput>
  }

  export type DepartmentSchedulePeriodUpsertWithWhereUniqueWithoutScheduleInput = {
    where: DepartmentSchedulePeriodWhereUniqueInput
    update: XOR<DepartmentSchedulePeriodUpdateWithoutScheduleInput, DepartmentSchedulePeriodUncheckedUpdateWithoutScheduleInput>
    create: XOR<DepartmentSchedulePeriodCreateWithoutScheduleInput, DepartmentSchedulePeriodUncheckedCreateWithoutScheduleInput>
  }

  export type DepartmentSchedulePeriodUpdateWithWhereUniqueWithoutScheduleInput = {
    where: DepartmentSchedulePeriodWhereUniqueInput
    data: XOR<DepartmentSchedulePeriodUpdateWithoutScheduleInput, DepartmentSchedulePeriodUncheckedUpdateWithoutScheduleInput>
  }

  export type DepartmentSchedulePeriodUpdateManyWithWhereWithoutScheduleInput = {
    where: DepartmentSchedulePeriodScalarWhereInput
    data: XOR<DepartmentSchedulePeriodUpdateManyMutationInput, DepartmentSchedulePeriodUncheckedUpdateManyWithoutScheduleInput>
  }

  export type DepartmentSchedulePeriodScalarWhereInput = {
    AND?: DepartmentSchedulePeriodScalarWhereInput | DepartmentSchedulePeriodScalarWhereInput[]
    OR?: DepartmentSchedulePeriodScalarWhereInput[]
    NOT?: DepartmentSchedulePeriodScalarWhereInput | DepartmentSchedulePeriodScalarWhereInput[]
    id?: StringFilter<"DepartmentSchedulePeriod"> | string
    scheduleId?: StringFilter<"DepartmentSchedulePeriod"> | string
    dayOfWeek?: EnumDayOfWeekFilter<"DepartmentSchedulePeriod"> | $Enums.DayOfWeek
    openTime?: StringFilter<"DepartmentSchedulePeriod"> | string
    closeTime?: StringFilter<"DepartmentSchedulePeriod"> | string
    requiredPorters?: IntFilter<"DepartmentSchedulePeriod"> | number
  }

  export type DepartmentScheduleCreateWithoutPeriodsInput = {
    id?: string
    name: string
    patternId?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentCreateNestedManyWithoutScheduleInput
  }

  export type DepartmentScheduleUncheckedCreateWithoutPeriodsInput = {
    id?: string
    name: string
    patternId?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentUncheckedCreateNestedManyWithoutScheduleInput
  }

  export type DepartmentScheduleCreateOrConnectWithoutPeriodsInput = {
    where: DepartmentScheduleWhereUniqueInput
    create: XOR<DepartmentScheduleCreateWithoutPeriodsInput, DepartmentScheduleUncheckedCreateWithoutPeriodsInput>
  }

  export type DepartmentScheduleUpsertWithoutPeriodsInput = {
    update: XOR<DepartmentScheduleUpdateWithoutPeriodsInput, DepartmentScheduleUncheckedUpdateWithoutPeriodsInput>
    create: XOR<DepartmentScheduleCreateWithoutPeriodsInput, DepartmentScheduleUncheckedCreateWithoutPeriodsInput>
    where?: DepartmentScheduleWhereInput
  }

  export type DepartmentScheduleUpdateToOneWithWhereWithoutPeriodsInput = {
    where?: DepartmentScheduleWhereInput
    data: XOR<DepartmentScheduleUpdateWithoutPeriodsInput, DepartmentScheduleUncheckedUpdateWithoutPeriodsInput>
  }

  export type DepartmentScheduleUpdateWithoutPeriodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    patternId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUpdateManyWithoutScheduleNestedInput
  }

  export type DepartmentScheduleUncheckedUpdateWithoutPeriodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    patternId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUncheckedUpdateManyWithoutScheduleNestedInput
  }

  export type PorterCapabilityCreateWithoutCapabilityInput = {
    expiryDate?: Date | string | null
    createdAt?: Date | string
    porter: PorterCreateNestedOneWithoutPorterCapabilitiesInput
  }

  export type PorterCapabilityUncheckedCreateWithoutCapabilityInput = {
    porterId: string
    expiryDate?: Date | string | null
    createdAt?: Date | string
  }

  export type PorterCapabilityCreateOrConnectWithoutCapabilityInput = {
    where: PorterCapabilityWhereUniqueInput
    create: XOR<PorterCapabilityCreateWithoutCapabilityInput, PorterCapabilityUncheckedCreateWithoutCapabilityInput>
  }

  export type PorterCapabilityCreateManyCapabilityInputEnvelope = {
    data: PorterCapabilityCreateManyCapabilityInput | PorterCapabilityCreateManyCapabilityInput[]
    skipDuplicates?: boolean
  }

  export type DepartmentCapabilityCreateWithoutCapabilityInput = {
    requiredLevel: $Enums.RequiredLevel
    department: DepartmentCreateNestedOneWithoutDepartmentCapabilitiesInput
  }

  export type DepartmentCapabilityUncheckedCreateWithoutCapabilityInput = {
    departmentId: string
    requiredLevel: $Enums.RequiredLevel
  }

  export type DepartmentCapabilityCreateOrConnectWithoutCapabilityInput = {
    where: DepartmentCapabilityWhereUniqueInput
    create: XOR<DepartmentCapabilityCreateWithoutCapabilityInput, DepartmentCapabilityUncheckedCreateWithoutCapabilityInput>
  }

  export type DepartmentCapabilityCreateManyCapabilityInputEnvelope = {
    data: DepartmentCapabilityCreateManyCapabilityInput | DepartmentCapabilityCreateManyCapabilityInput[]
    skipDuplicates?: boolean
  }

  export type ServiceCapabilityCreateWithoutCapabilityInput = {
    requiredLevel: $Enums.RequiredLevel
    service: ServiceCreateNestedOneWithoutServiceCapabilitiesInput
  }

  export type ServiceCapabilityUncheckedCreateWithoutCapabilityInput = {
    serviceId: string
    requiredLevel: $Enums.RequiredLevel
  }

  export type ServiceCapabilityCreateOrConnectWithoutCapabilityInput = {
    where: ServiceCapabilityWhereUniqueInput
    create: XOR<ServiceCapabilityCreateWithoutCapabilityInput, ServiceCapabilityUncheckedCreateWithoutCapabilityInput>
  }

  export type ServiceCapabilityCreateManyCapabilityInputEnvelope = {
    data: ServiceCapabilityCreateManyCapabilityInput | ServiceCapabilityCreateManyCapabilityInput[]
    skipDuplicates?: boolean
  }

  export type PorterCapabilityUpsertWithWhereUniqueWithoutCapabilityInput = {
    where: PorterCapabilityWhereUniqueInput
    update: XOR<PorterCapabilityUpdateWithoutCapabilityInput, PorterCapabilityUncheckedUpdateWithoutCapabilityInput>
    create: XOR<PorterCapabilityCreateWithoutCapabilityInput, PorterCapabilityUncheckedCreateWithoutCapabilityInput>
  }

  export type PorterCapabilityUpdateWithWhereUniqueWithoutCapabilityInput = {
    where: PorterCapabilityWhereUniqueInput
    data: XOR<PorterCapabilityUpdateWithoutCapabilityInput, PorterCapabilityUncheckedUpdateWithoutCapabilityInput>
  }

  export type PorterCapabilityUpdateManyWithWhereWithoutCapabilityInput = {
    where: PorterCapabilityScalarWhereInput
    data: XOR<PorterCapabilityUpdateManyMutationInput, PorterCapabilityUncheckedUpdateManyWithoutCapabilityInput>
  }

  export type DepartmentCapabilityUpsertWithWhereUniqueWithoutCapabilityInput = {
    where: DepartmentCapabilityWhereUniqueInput
    update: XOR<DepartmentCapabilityUpdateWithoutCapabilityInput, DepartmentCapabilityUncheckedUpdateWithoutCapabilityInput>
    create: XOR<DepartmentCapabilityCreateWithoutCapabilityInput, DepartmentCapabilityUncheckedCreateWithoutCapabilityInput>
  }

  export type DepartmentCapabilityUpdateWithWhereUniqueWithoutCapabilityInput = {
    where: DepartmentCapabilityWhereUniqueInput
    data: XOR<DepartmentCapabilityUpdateWithoutCapabilityInput, DepartmentCapabilityUncheckedUpdateWithoutCapabilityInput>
  }

  export type DepartmentCapabilityUpdateManyWithWhereWithoutCapabilityInput = {
    where: DepartmentCapabilityScalarWhereInput
    data: XOR<DepartmentCapabilityUpdateManyMutationInput, DepartmentCapabilityUncheckedUpdateManyWithoutCapabilityInput>
  }

  export type ServiceCapabilityUpsertWithWhereUniqueWithoutCapabilityInput = {
    where: ServiceCapabilityWhereUniqueInput
    update: XOR<ServiceCapabilityUpdateWithoutCapabilityInput, ServiceCapabilityUncheckedUpdateWithoutCapabilityInput>
    create: XOR<ServiceCapabilityCreateWithoutCapabilityInput, ServiceCapabilityUncheckedCreateWithoutCapabilityInput>
  }

  export type ServiceCapabilityUpdateWithWhereUniqueWithoutCapabilityInput = {
    where: ServiceCapabilityWhereUniqueInput
    data: XOR<ServiceCapabilityUpdateWithoutCapabilityInput, ServiceCapabilityUncheckedUpdateWithoutCapabilityInput>
  }

  export type ServiceCapabilityUpdateManyWithWhereWithoutCapabilityInput = {
    where: ServiceCapabilityScalarWhereInput
    data: XOR<ServiceCapabilityUpdateManyMutationInput, ServiceCapabilityUncheckedUpdateManyWithoutCapabilityInput>
  }

  export type PorterCreateWithoutPorterCapabilitiesInput = {
    id?: string
    name: string
    contractType: $Enums.ContractType
    weeklyMinHours?: number | null
    contractedHours?: number | null
    porterType?: $Enums.PorterType
    countsTowardsStaffing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    shift?: ShiftCreateNestedOneWithoutPortersInput
    regularDepartment?: DepartmentCreateNestedOneWithoutPortersInput
    allocations?: AllocationCreateNestedManyWithoutPorterInput
    availability?: AvailabilityCreateNestedManyWithoutPorterInput
  }

  export type PorterUncheckedCreateWithoutPorterCapabilitiesInput = {
    id?: string
    name: string
    contractType: $Enums.ContractType
    shiftId?: string | null
    weeklyMinHours?: number | null
    contractedHours?: number | null
    regularDepartmentId?: string | null
    porterType?: $Enums.PorterType
    countsTowardsStaffing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    allocations?: AllocationUncheckedCreateNestedManyWithoutPorterInput
    availability?: AvailabilityUncheckedCreateNestedManyWithoutPorterInput
  }

  export type PorterCreateOrConnectWithoutPorterCapabilitiesInput = {
    where: PorterWhereUniqueInput
    create: XOR<PorterCreateWithoutPorterCapabilitiesInput, PorterUncheckedCreateWithoutPorterCapabilitiesInput>
  }

  export type CapabilityCreateWithoutPorterCapabilitiesInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departmentCapabilities?: DepartmentCapabilityCreateNestedManyWithoutCapabilityInput
    serviceCapabilities?: ServiceCapabilityCreateNestedManyWithoutCapabilityInput
  }

  export type CapabilityUncheckedCreateWithoutPorterCapabilitiesInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departmentCapabilities?: DepartmentCapabilityUncheckedCreateNestedManyWithoutCapabilityInput
    serviceCapabilities?: ServiceCapabilityUncheckedCreateNestedManyWithoutCapabilityInput
  }

  export type CapabilityCreateOrConnectWithoutPorterCapabilitiesInput = {
    where: CapabilityWhereUniqueInput
    create: XOR<CapabilityCreateWithoutPorterCapabilitiesInput, CapabilityUncheckedCreateWithoutPorterCapabilitiesInput>
  }

  export type PorterUpsertWithoutPorterCapabilitiesInput = {
    update: XOR<PorterUpdateWithoutPorterCapabilitiesInput, PorterUncheckedUpdateWithoutPorterCapabilitiesInput>
    create: XOR<PorterCreateWithoutPorterCapabilitiesInput, PorterUncheckedCreateWithoutPorterCapabilitiesInput>
    where?: PorterWhereInput
  }

  export type PorterUpdateToOneWithWhereWithoutPorterCapabilitiesInput = {
    where?: PorterWhereInput
    data: XOR<PorterUpdateWithoutPorterCapabilitiesInput, PorterUncheckedUpdateWithoutPorterCapabilitiesInput>
  }

  export type PorterUpdateWithoutPorterCapabilitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contractType?: EnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType
    weeklyMinHours?: NullableIntFieldUpdateOperationsInput | number | null
    contractedHours?: NullableIntFieldUpdateOperationsInput | number | null
    porterType?: EnumPorterTypeFieldUpdateOperationsInput | $Enums.PorterType
    countsTowardsStaffing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shift?: ShiftUpdateOneWithoutPortersNestedInput
    regularDepartment?: DepartmentUpdateOneWithoutPortersNestedInput
    allocations?: AllocationUpdateManyWithoutPorterNestedInput
    availability?: AvailabilityUpdateManyWithoutPorterNestedInput
  }

  export type PorterUncheckedUpdateWithoutPorterCapabilitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contractType?: EnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType
    shiftId?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyMinHours?: NullableIntFieldUpdateOperationsInput | number | null
    contractedHours?: NullableIntFieldUpdateOperationsInput | number | null
    regularDepartmentId?: NullableStringFieldUpdateOperationsInput | string | null
    porterType?: EnumPorterTypeFieldUpdateOperationsInput | $Enums.PorterType
    countsTowardsStaffing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    allocations?: AllocationUncheckedUpdateManyWithoutPorterNestedInput
    availability?: AvailabilityUncheckedUpdateManyWithoutPorterNestedInput
  }

  export type CapabilityUpsertWithoutPorterCapabilitiesInput = {
    update: XOR<CapabilityUpdateWithoutPorterCapabilitiesInput, CapabilityUncheckedUpdateWithoutPorterCapabilitiesInput>
    create: XOR<CapabilityCreateWithoutPorterCapabilitiesInput, CapabilityUncheckedCreateWithoutPorterCapabilitiesInput>
    where?: CapabilityWhereInput
  }

  export type CapabilityUpdateToOneWithWhereWithoutPorterCapabilitiesInput = {
    where?: CapabilityWhereInput
    data: XOR<CapabilityUpdateWithoutPorterCapabilitiesInput, CapabilityUncheckedUpdateWithoutPorterCapabilitiesInput>
  }

  export type CapabilityUpdateWithoutPorterCapabilitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departmentCapabilities?: DepartmentCapabilityUpdateManyWithoutCapabilityNestedInput
    serviceCapabilities?: ServiceCapabilityUpdateManyWithoutCapabilityNestedInput
  }

  export type CapabilityUncheckedUpdateWithoutPorterCapabilitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departmentCapabilities?: DepartmentCapabilityUncheckedUpdateManyWithoutCapabilityNestedInput
    serviceCapabilities?: ServiceCapabilityUncheckedUpdateManyWithoutCapabilityNestedInput
  }

  export type DepartmentCreateWithoutDepartmentCapabilitiesInput = {
    id?: string
    name: string
    description?: string | null
    is247?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    building: BuildingCreateNestedOneWithoutDepartmentsInput
    schedule?: DepartmentScheduleCreateNestedOneWithoutDepartmentsInput
    services?: ServiceCreateNestedManyWithoutDepartmentInput
    porters?: PorterCreateNestedManyWithoutRegularDepartmentInput
    allocations?: AllocationCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutDepartmentCapabilitiesInput = {
    id?: string
    name: string
    buildingId: string
    scheduleId?: string | null
    description?: string | null
    is247?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ServiceUncheckedCreateNestedManyWithoutDepartmentInput
    porters?: PorterUncheckedCreateNestedManyWithoutRegularDepartmentInput
    allocations?: AllocationUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutDepartmentCapabilitiesInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutDepartmentCapabilitiesInput, DepartmentUncheckedCreateWithoutDepartmentCapabilitiesInput>
  }

  export type CapabilityCreateWithoutDepartmentCapabilitiesInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    porterCapabilities?: PorterCapabilityCreateNestedManyWithoutCapabilityInput
    serviceCapabilities?: ServiceCapabilityCreateNestedManyWithoutCapabilityInput
  }

  export type CapabilityUncheckedCreateWithoutDepartmentCapabilitiesInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    porterCapabilities?: PorterCapabilityUncheckedCreateNestedManyWithoutCapabilityInput
    serviceCapabilities?: ServiceCapabilityUncheckedCreateNestedManyWithoutCapabilityInput
  }

  export type CapabilityCreateOrConnectWithoutDepartmentCapabilitiesInput = {
    where: CapabilityWhereUniqueInput
    create: XOR<CapabilityCreateWithoutDepartmentCapabilitiesInput, CapabilityUncheckedCreateWithoutDepartmentCapabilitiesInput>
  }

  export type DepartmentUpsertWithoutDepartmentCapabilitiesInput = {
    update: XOR<DepartmentUpdateWithoutDepartmentCapabilitiesInput, DepartmentUncheckedUpdateWithoutDepartmentCapabilitiesInput>
    create: XOR<DepartmentCreateWithoutDepartmentCapabilitiesInput, DepartmentUncheckedCreateWithoutDepartmentCapabilitiesInput>
    where?: DepartmentWhereInput
  }

  export type DepartmentUpdateToOneWithWhereWithoutDepartmentCapabilitiesInput = {
    where?: DepartmentWhereInput
    data: XOR<DepartmentUpdateWithoutDepartmentCapabilitiesInput, DepartmentUncheckedUpdateWithoutDepartmentCapabilitiesInput>
  }

  export type DepartmentUpdateWithoutDepartmentCapabilitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is247?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    building?: BuildingUpdateOneRequiredWithoutDepartmentsNestedInput
    schedule?: DepartmentScheduleUpdateOneWithoutDepartmentsNestedInput
    services?: ServiceUpdateManyWithoutDepartmentNestedInput
    porters?: PorterUpdateManyWithoutRegularDepartmentNestedInput
    allocations?: AllocationUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutDepartmentCapabilitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    buildingId?: StringFieldUpdateOperationsInput | string
    scheduleId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is247?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceUncheckedUpdateManyWithoutDepartmentNestedInput
    porters?: PorterUncheckedUpdateManyWithoutRegularDepartmentNestedInput
    allocations?: AllocationUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type CapabilityUpsertWithoutDepartmentCapabilitiesInput = {
    update: XOR<CapabilityUpdateWithoutDepartmentCapabilitiesInput, CapabilityUncheckedUpdateWithoutDepartmentCapabilitiesInput>
    create: XOR<CapabilityCreateWithoutDepartmentCapabilitiesInput, CapabilityUncheckedCreateWithoutDepartmentCapabilitiesInput>
    where?: CapabilityWhereInput
  }

  export type CapabilityUpdateToOneWithWhereWithoutDepartmentCapabilitiesInput = {
    where?: CapabilityWhereInput
    data: XOR<CapabilityUpdateWithoutDepartmentCapabilitiesInput, CapabilityUncheckedUpdateWithoutDepartmentCapabilitiesInput>
  }

  export type CapabilityUpdateWithoutDepartmentCapabilitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    porterCapabilities?: PorterCapabilityUpdateManyWithoutCapabilityNestedInput
    serviceCapabilities?: ServiceCapabilityUpdateManyWithoutCapabilityNestedInput
  }

  export type CapabilityUncheckedUpdateWithoutDepartmentCapabilitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    porterCapabilities?: PorterCapabilityUncheckedUpdateManyWithoutCapabilityNestedInput
    serviceCapabilities?: ServiceCapabilityUncheckedUpdateManyWithoutCapabilityNestedInput
  }

  export type ServiceCreateWithoutServiceCapabilitiesInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    inheritsSchedule?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    department: DepartmentCreateNestedOneWithoutServicesInput
    allocations?: AllocationCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutServiceCapabilitiesInput = {
    id?: string
    name: string
    departmentId: string
    description?: string | null
    isActive?: boolean
    inheritsSchedule?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    allocations?: AllocationUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutServiceCapabilitiesInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutServiceCapabilitiesInput, ServiceUncheckedCreateWithoutServiceCapabilitiesInput>
  }

  export type CapabilityCreateWithoutServiceCapabilitiesInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    porterCapabilities?: PorterCapabilityCreateNestedManyWithoutCapabilityInput
    departmentCapabilities?: DepartmentCapabilityCreateNestedManyWithoutCapabilityInput
  }

  export type CapabilityUncheckedCreateWithoutServiceCapabilitiesInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    porterCapabilities?: PorterCapabilityUncheckedCreateNestedManyWithoutCapabilityInput
    departmentCapabilities?: DepartmentCapabilityUncheckedCreateNestedManyWithoutCapabilityInput
  }

  export type CapabilityCreateOrConnectWithoutServiceCapabilitiesInput = {
    where: CapabilityWhereUniqueInput
    create: XOR<CapabilityCreateWithoutServiceCapabilitiesInput, CapabilityUncheckedCreateWithoutServiceCapabilitiesInput>
  }

  export type ServiceUpsertWithoutServiceCapabilitiesInput = {
    update: XOR<ServiceUpdateWithoutServiceCapabilitiesInput, ServiceUncheckedUpdateWithoutServiceCapabilitiesInput>
    create: XOR<ServiceCreateWithoutServiceCapabilitiesInput, ServiceUncheckedCreateWithoutServiceCapabilitiesInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutServiceCapabilitiesInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutServiceCapabilitiesInput, ServiceUncheckedUpdateWithoutServiceCapabilitiesInput>
  }

  export type ServiceUpdateWithoutServiceCapabilitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    inheritsSchedule?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneRequiredWithoutServicesNestedInput
    allocations?: AllocationUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutServiceCapabilitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    inheritsSchedule?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    allocations?: AllocationUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type CapabilityUpsertWithoutServiceCapabilitiesInput = {
    update: XOR<CapabilityUpdateWithoutServiceCapabilitiesInput, CapabilityUncheckedUpdateWithoutServiceCapabilitiesInput>
    create: XOR<CapabilityCreateWithoutServiceCapabilitiesInput, CapabilityUncheckedCreateWithoutServiceCapabilitiesInput>
    where?: CapabilityWhereInput
  }

  export type CapabilityUpdateToOneWithWhereWithoutServiceCapabilitiesInput = {
    where?: CapabilityWhereInput
    data: XOR<CapabilityUpdateWithoutServiceCapabilitiesInput, CapabilityUncheckedUpdateWithoutServiceCapabilitiesInput>
  }

  export type CapabilityUpdateWithoutServiceCapabilitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    porterCapabilities?: PorterCapabilityUpdateManyWithoutCapabilityNestedInput
    departmentCapabilities?: DepartmentCapabilityUpdateManyWithoutCapabilityNestedInput
  }

  export type CapabilityUncheckedUpdateWithoutServiceCapabilitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    porterCapabilities?: PorterCapabilityUncheckedUpdateManyWithoutCapabilityNestedInput
    departmentCapabilities?: DepartmentCapabilityUncheckedUpdateManyWithoutCapabilityNestedInput
  }

  export type PorterCreateWithoutAllocationsInput = {
    id?: string
    name: string
    contractType: $Enums.ContractType
    weeklyMinHours?: number | null
    contractedHours?: number | null
    porterType?: $Enums.PorterType
    countsTowardsStaffing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    shift?: ShiftCreateNestedOneWithoutPortersInput
    regularDepartment?: DepartmentCreateNestedOneWithoutPortersInput
    availability?: AvailabilityCreateNestedManyWithoutPorterInput
    porterCapabilities?: PorterCapabilityCreateNestedManyWithoutPorterInput
  }

  export type PorterUncheckedCreateWithoutAllocationsInput = {
    id?: string
    name: string
    contractType: $Enums.ContractType
    shiftId?: string | null
    weeklyMinHours?: number | null
    contractedHours?: number | null
    regularDepartmentId?: string | null
    porterType?: $Enums.PorterType
    countsTowardsStaffing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    availability?: AvailabilityUncheckedCreateNestedManyWithoutPorterInput
    porterCapabilities?: PorterCapabilityUncheckedCreateNestedManyWithoutPorterInput
  }

  export type PorterCreateOrConnectWithoutAllocationsInput = {
    where: PorterWhereUniqueInput
    create: XOR<PorterCreateWithoutAllocationsInput, PorterUncheckedCreateWithoutAllocationsInput>
  }

  export type DepartmentCreateWithoutAllocationsInput = {
    id?: string
    name: string
    description?: string | null
    is247?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    building: BuildingCreateNestedOneWithoutDepartmentsInput
    schedule?: DepartmentScheduleCreateNestedOneWithoutDepartmentsInput
    services?: ServiceCreateNestedManyWithoutDepartmentInput
    porters?: PorterCreateNestedManyWithoutRegularDepartmentInput
    departmentCapabilities?: DepartmentCapabilityCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutAllocationsInput = {
    id?: string
    name: string
    buildingId: string
    scheduleId?: string | null
    description?: string | null
    is247?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ServiceUncheckedCreateNestedManyWithoutDepartmentInput
    porters?: PorterUncheckedCreateNestedManyWithoutRegularDepartmentInput
    departmentCapabilities?: DepartmentCapabilityUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutAllocationsInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutAllocationsInput, DepartmentUncheckedCreateWithoutAllocationsInput>
  }

  export type ServiceCreateWithoutAllocationsInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    inheritsSchedule?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    department: DepartmentCreateNestedOneWithoutServicesInput
    serviceCapabilities?: ServiceCapabilityCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutAllocationsInput = {
    id?: string
    name: string
    departmentId: string
    description?: string | null
    isActive?: boolean
    inheritsSchedule?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceCapabilities?: ServiceCapabilityUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutAllocationsInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutAllocationsInput, ServiceUncheckedCreateWithoutAllocationsInput>
  }

  export type PorterUpsertWithoutAllocationsInput = {
    update: XOR<PorterUpdateWithoutAllocationsInput, PorterUncheckedUpdateWithoutAllocationsInput>
    create: XOR<PorterCreateWithoutAllocationsInput, PorterUncheckedCreateWithoutAllocationsInput>
    where?: PorterWhereInput
  }

  export type PorterUpdateToOneWithWhereWithoutAllocationsInput = {
    where?: PorterWhereInput
    data: XOR<PorterUpdateWithoutAllocationsInput, PorterUncheckedUpdateWithoutAllocationsInput>
  }

  export type PorterUpdateWithoutAllocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contractType?: EnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType
    weeklyMinHours?: NullableIntFieldUpdateOperationsInput | number | null
    contractedHours?: NullableIntFieldUpdateOperationsInput | number | null
    porterType?: EnumPorterTypeFieldUpdateOperationsInput | $Enums.PorterType
    countsTowardsStaffing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shift?: ShiftUpdateOneWithoutPortersNestedInput
    regularDepartment?: DepartmentUpdateOneWithoutPortersNestedInput
    availability?: AvailabilityUpdateManyWithoutPorterNestedInput
    porterCapabilities?: PorterCapabilityUpdateManyWithoutPorterNestedInput
  }

  export type PorterUncheckedUpdateWithoutAllocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contractType?: EnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType
    shiftId?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyMinHours?: NullableIntFieldUpdateOperationsInput | number | null
    contractedHours?: NullableIntFieldUpdateOperationsInput | number | null
    regularDepartmentId?: NullableStringFieldUpdateOperationsInput | string | null
    porterType?: EnumPorterTypeFieldUpdateOperationsInput | $Enums.PorterType
    countsTowardsStaffing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    availability?: AvailabilityUncheckedUpdateManyWithoutPorterNestedInput
    porterCapabilities?: PorterCapabilityUncheckedUpdateManyWithoutPorterNestedInput
  }

  export type DepartmentUpsertWithoutAllocationsInput = {
    update: XOR<DepartmentUpdateWithoutAllocationsInput, DepartmentUncheckedUpdateWithoutAllocationsInput>
    create: XOR<DepartmentCreateWithoutAllocationsInput, DepartmentUncheckedCreateWithoutAllocationsInput>
    where?: DepartmentWhereInput
  }

  export type DepartmentUpdateToOneWithWhereWithoutAllocationsInput = {
    where?: DepartmentWhereInput
    data: XOR<DepartmentUpdateWithoutAllocationsInput, DepartmentUncheckedUpdateWithoutAllocationsInput>
  }

  export type DepartmentUpdateWithoutAllocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is247?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    building?: BuildingUpdateOneRequiredWithoutDepartmentsNestedInput
    schedule?: DepartmentScheduleUpdateOneWithoutDepartmentsNestedInput
    services?: ServiceUpdateManyWithoutDepartmentNestedInput
    porters?: PorterUpdateManyWithoutRegularDepartmentNestedInput
    departmentCapabilities?: DepartmentCapabilityUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutAllocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    buildingId?: StringFieldUpdateOperationsInput | string
    scheduleId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is247?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceUncheckedUpdateManyWithoutDepartmentNestedInput
    porters?: PorterUncheckedUpdateManyWithoutRegularDepartmentNestedInput
    departmentCapabilities?: DepartmentCapabilityUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type ServiceUpsertWithoutAllocationsInput = {
    update: XOR<ServiceUpdateWithoutAllocationsInput, ServiceUncheckedUpdateWithoutAllocationsInput>
    create: XOR<ServiceCreateWithoutAllocationsInput, ServiceUncheckedCreateWithoutAllocationsInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutAllocationsInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutAllocationsInput, ServiceUncheckedUpdateWithoutAllocationsInput>
  }

  export type ServiceUpdateWithoutAllocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    inheritsSchedule?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneRequiredWithoutServicesNestedInput
    serviceCapabilities?: ServiceCapabilityUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutAllocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    inheritsSchedule?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceCapabilities?: ServiceCapabilityUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type PorterCreateWithoutAvailabilityInput = {
    id?: string
    name: string
    contractType: $Enums.ContractType
    weeklyMinHours?: number | null
    contractedHours?: number | null
    porterType?: $Enums.PorterType
    countsTowardsStaffing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    shift?: ShiftCreateNestedOneWithoutPortersInput
    regularDepartment?: DepartmentCreateNestedOneWithoutPortersInput
    allocations?: AllocationCreateNestedManyWithoutPorterInput
    porterCapabilities?: PorterCapabilityCreateNestedManyWithoutPorterInput
  }

  export type PorterUncheckedCreateWithoutAvailabilityInput = {
    id?: string
    name: string
    contractType: $Enums.ContractType
    shiftId?: string | null
    weeklyMinHours?: number | null
    contractedHours?: number | null
    regularDepartmentId?: string | null
    porterType?: $Enums.PorterType
    countsTowardsStaffing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    allocations?: AllocationUncheckedCreateNestedManyWithoutPorterInput
    porterCapabilities?: PorterCapabilityUncheckedCreateNestedManyWithoutPorterInput
  }

  export type PorterCreateOrConnectWithoutAvailabilityInput = {
    where: PorterWhereUniqueInput
    create: XOR<PorterCreateWithoutAvailabilityInput, PorterUncheckedCreateWithoutAvailabilityInput>
  }

  export type PorterUpsertWithoutAvailabilityInput = {
    update: XOR<PorterUpdateWithoutAvailabilityInput, PorterUncheckedUpdateWithoutAvailabilityInput>
    create: XOR<PorterCreateWithoutAvailabilityInput, PorterUncheckedCreateWithoutAvailabilityInput>
    where?: PorterWhereInput
  }

  export type PorterUpdateToOneWithWhereWithoutAvailabilityInput = {
    where?: PorterWhereInput
    data: XOR<PorterUpdateWithoutAvailabilityInput, PorterUncheckedUpdateWithoutAvailabilityInput>
  }

  export type PorterUpdateWithoutAvailabilityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contractType?: EnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType
    weeklyMinHours?: NullableIntFieldUpdateOperationsInput | number | null
    contractedHours?: NullableIntFieldUpdateOperationsInput | number | null
    porterType?: EnumPorterTypeFieldUpdateOperationsInput | $Enums.PorterType
    countsTowardsStaffing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shift?: ShiftUpdateOneWithoutPortersNestedInput
    regularDepartment?: DepartmentUpdateOneWithoutPortersNestedInput
    allocations?: AllocationUpdateManyWithoutPorterNestedInput
    porterCapabilities?: PorterCapabilityUpdateManyWithoutPorterNestedInput
  }

  export type PorterUncheckedUpdateWithoutAvailabilityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contractType?: EnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType
    shiftId?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyMinHours?: NullableIntFieldUpdateOperationsInput | number | null
    contractedHours?: NullableIntFieldUpdateOperationsInput | number | null
    regularDepartmentId?: NullableStringFieldUpdateOperationsInput | string | null
    porterType?: EnumPorterTypeFieldUpdateOperationsInput | $Enums.PorterType
    countsTowardsStaffing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    allocations?: AllocationUncheckedUpdateManyWithoutPorterNestedInput
    porterCapabilities?: PorterCapabilityUncheckedUpdateManyWithoutPorterNestedInput
  }

  export type DepartmentCreateManyBuildingInput = {
    id?: string
    name: string
    scheduleId?: string | null
    description?: string | null
    is247?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentUpdateWithoutBuildingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is247?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedule?: DepartmentScheduleUpdateOneWithoutDepartmentsNestedInput
    services?: ServiceUpdateManyWithoutDepartmentNestedInput
    porters?: PorterUpdateManyWithoutRegularDepartmentNestedInput
    allocations?: AllocationUpdateManyWithoutDepartmentNestedInput
    departmentCapabilities?: DepartmentCapabilityUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutBuildingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    scheduleId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is247?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceUncheckedUpdateManyWithoutDepartmentNestedInput
    porters?: PorterUncheckedUpdateManyWithoutRegularDepartmentNestedInput
    allocations?: AllocationUncheckedUpdateManyWithoutDepartmentNestedInput
    departmentCapabilities?: DepartmentCapabilityUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateManyWithoutBuildingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    scheduleId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is247?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceCreateManyDepartmentInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    inheritsSchedule?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PorterCreateManyRegularDepartmentInput = {
    id?: string
    name: string
    contractType: $Enums.ContractType
    shiftId?: string | null
    weeklyMinHours?: number | null
    contractedHours?: number | null
    porterType?: $Enums.PorterType
    countsTowardsStaffing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AllocationCreateManyDepartmentInput = {
    id?: string
    porterId: string
    serviceId?: string | null
    startDatetime: Date | string
    endDatetime?: Date | string | null
    type: $Enums.AllocationType
    reason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentCapabilityCreateManyDepartmentInput = {
    capabilityId: string
    requiredLevel: $Enums.RequiredLevel
  }

  export type ServiceUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    inheritsSchedule?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    allocations?: AllocationUpdateManyWithoutServiceNestedInput
    serviceCapabilities?: ServiceCapabilityUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    inheritsSchedule?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    allocations?: AllocationUncheckedUpdateManyWithoutServiceNestedInput
    serviceCapabilities?: ServiceCapabilityUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateManyWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    inheritsSchedule?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PorterUpdateWithoutRegularDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contractType?: EnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType
    weeklyMinHours?: NullableIntFieldUpdateOperationsInput | number | null
    contractedHours?: NullableIntFieldUpdateOperationsInput | number | null
    porterType?: EnumPorterTypeFieldUpdateOperationsInput | $Enums.PorterType
    countsTowardsStaffing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shift?: ShiftUpdateOneWithoutPortersNestedInput
    allocations?: AllocationUpdateManyWithoutPorterNestedInput
    availability?: AvailabilityUpdateManyWithoutPorterNestedInput
    porterCapabilities?: PorterCapabilityUpdateManyWithoutPorterNestedInput
  }

  export type PorterUncheckedUpdateWithoutRegularDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contractType?: EnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType
    shiftId?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyMinHours?: NullableIntFieldUpdateOperationsInput | number | null
    contractedHours?: NullableIntFieldUpdateOperationsInput | number | null
    porterType?: EnumPorterTypeFieldUpdateOperationsInput | $Enums.PorterType
    countsTowardsStaffing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    allocations?: AllocationUncheckedUpdateManyWithoutPorterNestedInput
    availability?: AvailabilityUncheckedUpdateManyWithoutPorterNestedInput
    porterCapabilities?: PorterCapabilityUncheckedUpdateManyWithoutPorterNestedInput
  }

  export type PorterUncheckedUpdateManyWithoutRegularDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contractType?: EnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType
    shiftId?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyMinHours?: NullableIntFieldUpdateOperationsInput | number | null
    contractedHours?: NullableIntFieldUpdateOperationsInput | number | null
    porterType?: EnumPorterTypeFieldUpdateOperationsInput | $Enums.PorterType
    countsTowardsStaffing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AllocationUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    endDatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: EnumAllocationTypeFieldUpdateOperationsInput | $Enums.AllocationType
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    porter?: PorterUpdateOneRequiredWithoutAllocationsNestedInput
    service?: ServiceUpdateOneWithoutAllocationsNestedInput
  }

  export type AllocationUncheckedUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    porterId?: StringFieldUpdateOperationsInput | string
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    startDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    endDatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: EnumAllocationTypeFieldUpdateOperationsInput | $Enums.AllocationType
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AllocationUncheckedUpdateManyWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    porterId?: StringFieldUpdateOperationsInput | string
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    startDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    endDatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: EnumAllocationTypeFieldUpdateOperationsInput | $Enums.AllocationType
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentCapabilityUpdateWithoutDepartmentInput = {
    requiredLevel?: EnumRequiredLevelFieldUpdateOperationsInput | $Enums.RequiredLevel
    capability?: CapabilityUpdateOneRequiredWithoutDepartmentCapabilitiesNestedInput
  }

  export type DepartmentCapabilityUncheckedUpdateWithoutDepartmentInput = {
    capabilityId?: StringFieldUpdateOperationsInput | string
    requiredLevel?: EnumRequiredLevelFieldUpdateOperationsInput | $Enums.RequiredLevel
  }

  export type DepartmentCapabilityUncheckedUpdateManyWithoutDepartmentInput = {
    capabilityId?: StringFieldUpdateOperationsInput | string
    requiredLevel?: EnumRequiredLevelFieldUpdateOperationsInput | $Enums.RequiredLevel
  }

  export type AllocationCreateManyServiceInput = {
    id?: string
    porterId: string
    departmentId: string
    startDatetime: Date | string
    endDatetime?: Date | string | null
    type: $Enums.AllocationType
    reason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceCapabilityCreateManyServiceInput = {
    capabilityId: string
    requiredLevel: $Enums.RequiredLevel
  }

  export type AllocationUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    endDatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: EnumAllocationTypeFieldUpdateOperationsInput | $Enums.AllocationType
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    porter?: PorterUpdateOneRequiredWithoutAllocationsNestedInput
    department?: DepartmentUpdateOneRequiredWithoutAllocationsNestedInput
  }

  export type AllocationUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    porterId?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    startDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    endDatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: EnumAllocationTypeFieldUpdateOperationsInput | $Enums.AllocationType
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AllocationUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    porterId?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    startDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    endDatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: EnumAllocationTypeFieldUpdateOperationsInput | $Enums.AllocationType
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceCapabilityUpdateWithoutServiceInput = {
    requiredLevel?: EnumRequiredLevelFieldUpdateOperationsInput | $Enums.RequiredLevel
    capability?: CapabilityUpdateOneRequiredWithoutServiceCapabilitiesNestedInput
  }

  export type ServiceCapabilityUncheckedUpdateWithoutServiceInput = {
    capabilityId?: StringFieldUpdateOperationsInput | string
    requiredLevel?: EnumRequiredLevelFieldUpdateOperationsInput | $Enums.RequiredLevel
  }

  export type ServiceCapabilityUncheckedUpdateManyWithoutServiceInput = {
    capabilityId?: StringFieldUpdateOperationsInput | string
    requiredLevel?: EnumRequiredLevelFieldUpdateOperationsInput | $Enums.RequiredLevel
  }

  export type AllocationCreateManyPorterInput = {
    id?: string
    departmentId: string
    serviceId?: string | null
    startDatetime: Date | string
    endDatetime?: Date | string | null
    type: $Enums.AllocationType
    reason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AvailabilityCreateManyPorterInput = {
    id?: string
    startDatetime: Date | string
    endDatetime: Date | string
    status: $Enums.AvailabilityStatus
    reason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PorterCapabilityCreateManyPorterInput = {
    capabilityId: string
    expiryDate?: Date | string | null
    createdAt?: Date | string
  }

  export type AllocationUpdateWithoutPorterInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    endDatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: EnumAllocationTypeFieldUpdateOperationsInput | $Enums.AllocationType
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneRequiredWithoutAllocationsNestedInput
    service?: ServiceUpdateOneWithoutAllocationsNestedInput
  }

  export type AllocationUncheckedUpdateWithoutPorterInput = {
    id?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    startDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    endDatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: EnumAllocationTypeFieldUpdateOperationsInput | $Enums.AllocationType
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AllocationUncheckedUpdateManyWithoutPorterInput = {
    id?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    startDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    endDatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: EnumAllocationTypeFieldUpdateOperationsInput | $Enums.AllocationType
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AvailabilityUpdateWithoutPorterInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    endDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAvailabilityStatusFieldUpdateOperationsInput | $Enums.AvailabilityStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AvailabilityUncheckedUpdateWithoutPorterInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    endDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAvailabilityStatusFieldUpdateOperationsInput | $Enums.AvailabilityStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AvailabilityUncheckedUpdateManyWithoutPorterInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    endDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAvailabilityStatusFieldUpdateOperationsInput | $Enums.AvailabilityStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PorterCapabilityUpdateWithoutPorterInput = {
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    capability?: CapabilityUpdateOneRequiredWithoutPorterCapabilitiesNestedInput
  }

  export type PorterCapabilityUncheckedUpdateWithoutPorterInput = {
    capabilityId?: StringFieldUpdateOperationsInput | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PorterCapabilityUncheckedUpdateManyWithoutPorterInput = {
    capabilityId?: StringFieldUpdateOperationsInput | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PorterCreateManyShiftInput = {
    id?: string
    name: string
    contractType: $Enums.ContractType
    weeklyMinHours?: number | null
    contractedHours?: number | null
    regularDepartmentId?: string | null
    porterType?: $Enums.PorterType
    countsTowardsStaffing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PorterUpdateWithoutShiftInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contractType?: EnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType
    weeklyMinHours?: NullableIntFieldUpdateOperationsInput | number | null
    contractedHours?: NullableIntFieldUpdateOperationsInput | number | null
    porterType?: EnumPorterTypeFieldUpdateOperationsInput | $Enums.PorterType
    countsTowardsStaffing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    regularDepartment?: DepartmentUpdateOneWithoutPortersNestedInput
    allocations?: AllocationUpdateManyWithoutPorterNestedInput
    availability?: AvailabilityUpdateManyWithoutPorterNestedInput
    porterCapabilities?: PorterCapabilityUpdateManyWithoutPorterNestedInput
  }

  export type PorterUncheckedUpdateWithoutShiftInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contractType?: EnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType
    weeklyMinHours?: NullableIntFieldUpdateOperationsInput | number | null
    contractedHours?: NullableIntFieldUpdateOperationsInput | number | null
    regularDepartmentId?: NullableStringFieldUpdateOperationsInput | string | null
    porterType?: EnumPorterTypeFieldUpdateOperationsInput | $Enums.PorterType
    countsTowardsStaffing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    allocations?: AllocationUncheckedUpdateManyWithoutPorterNestedInput
    availability?: AvailabilityUncheckedUpdateManyWithoutPorterNestedInput
    porterCapabilities?: PorterCapabilityUncheckedUpdateManyWithoutPorterNestedInput
  }

  export type PorterUncheckedUpdateManyWithoutShiftInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contractType?: EnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType
    weeklyMinHours?: NullableIntFieldUpdateOperationsInput | number | null
    contractedHours?: NullableIntFieldUpdateOperationsInput | number | null
    regularDepartmentId?: NullableStringFieldUpdateOperationsInput | string | null
    porterType?: EnumPorterTypeFieldUpdateOperationsInput | $Enums.PorterType
    countsTowardsStaffing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftCreateManyPatternInput = {
    id?: string
    name: string
    shiftMode: $Enums.ShiftMode
    ident: string
    daysOn: number
    daysOff: number
    offsetDays?: number
    groundZero: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShiftUpdateWithoutPatternInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shiftMode?: EnumShiftModeFieldUpdateOperationsInput | $Enums.ShiftMode
    ident?: StringFieldUpdateOperationsInput | string
    daysOn?: IntFieldUpdateOperationsInput | number
    daysOff?: IntFieldUpdateOperationsInput | number
    offsetDays?: IntFieldUpdateOperationsInput | number
    groundZero?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    porters?: PorterUpdateManyWithoutShiftNestedInput
  }

  export type ShiftUncheckedUpdateWithoutPatternInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shiftMode?: EnumShiftModeFieldUpdateOperationsInput | $Enums.ShiftMode
    ident?: StringFieldUpdateOperationsInput | string
    daysOn?: IntFieldUpdateOperationsInput | number
    daysOff?: IntFieldUpdateOperationsInput | number
    offsetDays?: IntFieldUpdateOperationsInput | number
    groundZero?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    porters?: PorterUncheckedUpdateManyWithoutShiftNestedInput
  }

  export type ShiftUncheckedUpdateManyWithoutPatternInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shiftMode?: EnumShiftModeFieldUpdateOperationsInput | $Enums.ShiftMode
    ident?: StringFieldUpdateOperationsInput | string
    daysOn?: IntFieldUpdateOperationsInput | number
    daysOff?: IntFieldUpdateOperationsInput | number
    offsetDays?: IntFieldUpdateOperationsInput | number
    groundZero?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentCreateManyScheduleInput = {
    id?: string
    name: string
    buildingId: string
    description?: string | null
    is247?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentSchedulePeriodCreateManyScheduleInput = {
    id?: string
    dayOfWeek: $Enums.DayOfWeek
    openTime: string
    closeTime: string
    requiredPorters: number
  }

  export type DepartmentUpdateWithoutScheduleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is247?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    building?: BuildingUpdateOneRequiredWithoutDepartmentsNestedInput
    services?: ServiceUpdateManyWithoutDepartmentNestedInput
    porters?: PorterUpdateManyWithoutRegularDepartmentNestedInput
    allocations?: AllocationUpdateManyWithoutDepartmentNestedInput
    departmentCapabilities?: DepartmentCapabilityUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutScheduleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    buildingId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is247?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceUncheckedUpdateManyWithoutDepartmentNestedInput
    porters?: PorterUncheckedUpdateManyWithoutRegularDepartmentNestedInput
    allocations?: AllocationUncheckedUpdateManyWithoutDepartmentNestedInput
    departmentCapabilities?: DepartmentCapabilityUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateManyWithoutScheduleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    buildingId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is247?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentSchedulePeriodUpdateWithoutScheduleInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumDayOfWeekFieldUpdateOperationsInput | $Enums.DayOfWeek
    openTime?: StringFieldUpdateOperationsInput | string
    closeTime?: StringFieldUpdateOperationsInput | string
    requiredPorters?: IntFieldUpdateOperationsInput | number
  }

  export type DepartmentSchedulePeriodUncheckedUpdateWithoutScheduleInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumDayOfWeekFieldUpdateOperationsInput | $Enums.DayOfWeek
    openTime?: StringFieldUpdateOperationsInput | string
    closeTime?: StringFieldUpdateOperationsInput | string
    requiredPorters?: IntFieldUpdateOperationsInput | number
  }

  export type DepartmentSchedulePeriodUncheckedUpdateManyWithoutScheduleInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumDayOfWeekFieldUpdateOperationsInput | $Enums.DayOfWeek
    openTime?: StringFieldUpdateOperationsInput | string
    closeTime?: StringFieldUpdateOperationsInput | string
    requiredPorters?: IntFieldUpdateOperationsInput | number
  }

  export type PorterCapabilityCreateManyCapabilityInput = {
    porterId: string
    expiryDate?: Date | string | null
    createdAt?: Date | string
  }

  export type DepartmentCapabilityCreateManyCapabilityInput = {
    departmentId: string
    requiredLevel: $Enums.RequiredLevel
  }

  export type ServiceCapabilityCreateManyCapabilityInput = {
    serviceId: string
    requiredLevel: $Enums.RequiredLevel
  }

  export type PorterCapabilityUpdateWithoutCapabilityInput = {
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    porter?: PorterUpdateOneRequiredWithoutPorterCapabilitiesNestedInput
  }

  export type PorterCapabilityUncheckedUpdateWithoutCapabilityInput = {
    porterId?: StringFieldUpdateOperationsInput | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PorterCapabilityUncheckedUpdateManyWithoutCapabilityInput = {
    porterId?: StringFieldUpdateOperationsInput | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentCapabilityUpdateWithoutCapabilityInput = {
    requiredLevel?: EnumRequiredLevelFieldUpdateOperationsInput | $Enums.RequiredLevel
    department?: DepartmentUpdateOneRequiredWithoutDepartmentCapabilitiesNestedInput
  }

  export type DepartmentCapabilityUncheckedUpdateWithoutCapabilityInput = {
    departmentId?: StringFieldUpdateOperationsInput | string
    requiredLevel?: EnumRequiredLevelFieldUpdateOperationsInput | $Enums.RequiredLevel
  }

  export type DepartmentCapabilityUncheckedUpdateManyWithoutCapabilityInput = {
    departmentId?: StringFieldUpdateOperationsInput | string
    requiredLevel?: EnumRequiredLevelFieldUpdateOperationsInput | $Enums.RequiredLevel
  }

  export type ServiceCapabilityUpdateWithoutCapabilityInput = {
    requiredLevel?: EnumRequiredLevelFieldUpdateOperationsInput | $Enums.RequiredLevel
    service?: ServiceUpdateOneRequiredWithoutServiceCapabilitiesNestedInput
  }

  export type ServiceCapabilityUncheckedUpdateWithoutCapabilityInput = {
    serviceId?: StringFieldUpdateOperationsInput | string
    requiredLevel?: EnumRequiredLevelFieldUpdateOperationsInput | $Enums.RequiredLevel
  }

  export type ServiceCapabilityUncheckedUpdateManyWithoutCapabilityInput = {
    serviceId?: StringFieldUpdateOperationsInput | string
    requiredLevel?: EnumRequiredLevelFieldUpdateOperationsInput | $Enums.RequiredLevel
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use BuildingCountOutputTypeDefaultArgs instead
     */
    export type BuildingCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BuildingCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DepartmentCountOutputTypeDefaultArgs instead
     */
    export type DepartmentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DepartmentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServiceCountOutputTypeDefaultArgs instead
     */
    export type ServiceCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServiceCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PorterCountOutputTypeDefaultArgs instead
     */
    export type PorterCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PorterCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ShiftCountOutputTypeDefaultArgs instead
     */
    export type ShiftCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ShiftCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ShiftPatternCountOutputTypeDefaultArgs instead
     */
    export type ShiftPatternCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ShiftPatternCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DepartmentScheduleCountOutputTypeDefaultArgs instead
     */
    export type DepartmentScheduleCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DepartmentScheduleCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CapabilityCountOutputTypeDefaultArgs instead
     */
    export type CapabilityCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CapabilityCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BuildingDefaultArgs instead
     */
    export type BuildingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BuildingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DepartmentDefaultArgs instead
     */
    export type DepartmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DepartmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServiceDefaultArgs instead
     */
    export type ServiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServiceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PorterDefaultArgs instead
     */
    export type PorterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PorterDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ShiftDefaultArgs instead
     */
    export type ShiftArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ShiftDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ShiftPatternDefaultArgs instead
     */
    export type ShiftPatternArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ShiftPatternDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DepartmentScheduleDefaultArgs instead
     */
    export type DepartmentScheduleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DepartmentScheduleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DepartmentSchedulePeriodDefaultArgs instead
     */
    export type DepartmentSchedulePeriodArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DepartmentSchedulePeriodDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CapabilityDefaultArgs instead
     */
    export type CapabilityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CapabilityDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PorterCapabilityDefaultArgs instead
     */
    export type PorterCapabilityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PorterCapabilityDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DepartmentCapabilityDefaultArgs instead
     */
    export type DepartmentCapabilityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DepartmentCapabilityDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServiceCapabilityDefaultArgs instead
     */
    export type ServiceCapabilityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServiceCapabilityDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AllocationDefaultArgs instead
     */
    export type AllocationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AllocationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AvailabilityDefaultArgs instead
     */
    export type AvailabilityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AvailabilityDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SystemSettingDefaultArgs instead
     */
    export type SystemSettingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SystemSettingDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}